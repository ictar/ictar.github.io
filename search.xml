<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Celery从入门到放弃：celery是什么？</title>
    <url>/2017/04/15/Celery%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%9Acelery%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://i.ytimg.com/vi/YSBAq-npCt4/maxresdefault.jpg" /></p>
<p>第一次知道celery是因为想给django加入异步。</p>
<p>众所周知，django对单个请求是同步的，这里同步的意思是，客户端发起一个request，django完全处理完毕之后才返回response。这种情况下，如果django处理的时间很长很长，客户端就会出现等待不到响应超时的情况。而当时我刚好需要通过django调用ansible进行一些长时间的任务。这些任务耗时之长，可以达到1h。而让客户端一直等待响应1h显然是非常不可取的。</p>
<figure>
<img src="/img/328607BAB02D46F3A7EF40E15DAE0D00.jpg" alt="示意图1" /><figcaption aria-hidden="true">示意图1</figcaption>
</figure>
<p>此时，一个解决方案就是，django把长耗时的任务交由某种机制进行处理，然后立即返回response。之后，客户端通过另外的接口，查询任务处理情况。</p>
<figure>
<img src="/img/E6D7AF2A44AB464591EE59D45EDA76F7.jpg" alt="示意图2" /><figcaption aria-hidden="true">示意图2</figcaption>
</figure>
<p>于是，celery就闪亮登场了。</p>
<p>摘抄官方文档中对celery的定义： &gt; celery是一个简单、灵活且可靠的分布式系统，用来处理大量的消息，同时提供维护这样一个系统所需的操作工具。</p>
<blockquote>
<p>它是一个专注于实时处理的任务队列，同时也支持任务调度。</p>
</blockquote>
<h3 id="celery初体验">celery初体验</h3>
<blockquote>
<p>详情见<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">First Steps with Celery</a></p>
</blockquote>
<h4 id="选择并安装消息传输方式broker">选择并安装消息传输方式(broker)</h4>
<p>celery自身并不保存数据，而是借助broker来发送和接收消息。celery支持多种broker： * RabbitMQ * Redis * 其他（详见<a href="http://docs.celeryproject.org/en/latest/getting-started/brokers/index.html#broker-overview">Broker Overview</a>）</p>
<p>因此，我们需要根据所需选择并安装合适的broker。 &gt; 注：具体broker的安装方式详见所选broker的官网。这里只聚焦celery哈。</p>
<h4 id="安装celery">安装celery</h4>
<p>通过pip，即可安装celery： <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> celery</span><br></pre></td></tr></table></figure> #### 创建任务 首先，我们需要创建一个Celery实例<code>app</code>，通过这个实例来访问celery的所有功能，例如创建人物或者管理worker等等。</p>
<p>让我们新建一个文件，起名为<code>tasks.py</code>： <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个参数是当前模块的名字</span></span><br><span class="line"><span class="comment"># 第二个参数是所选broker的URL。这里，我们使用RabbitMQ</span></span><br><span class="line">app = Celery(<span class="string">&#x27;eletest&#x27;</span>, broker=<span class="string">&#x27;amqp://ele@localhost//&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们定义一个简单的任务，休眠100秒后，打印一句&quot;hello, &#123;&#123;name&#125;&#125;&quot;</span></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">100</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;hello,&quot;</span>, name</span><br></pre></td></tr></table></figure> #### 运行worker 运行以下命令即可： <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ celery -A eletest worker <span class="attribute">--loglevel</span>=info</span><br></pre></td></tr></table></figure> &gt; 注：如果想通过守护模式启动celery的话，可以考虑借助supervisord</p>
<p><code>celery worker</code>提供了多种选项，可以通过<code>celery worker -h</code>进行了解使用</p>
<p>celery还提供了很多种命令。这里就不一一说明了。</p>
<h4 id="调用任务">调用任务</h4>
<p>通过上面的步骤，我们已经把接收消息进行处理这一步完成了。现在，我们需要看看怎么发送消息。</p>
<p>在没有使用celery之前，我们是这样调用我们的任务的： <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sayHello(<span class="string">&quot;ele&quot;</span>) <span class="comment"># hello, ele</span></span><br></pre></td></tr></table></figure> 使用celery，则只需要将上面替换成下面的代码： <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tasks <span class="keyword">import</span> sayHello</span><br><span class="line"></span><br><span class="line">sayHello.delay(<span class="string">&quot;ele&quot;</span>)</span><br><span class="line"><span class="comment"># 执行上面这一句代码的时候，celery会把相关参数整理成某种格式，然后扔到你指定的broker。然后，前面启动的worker就会从broker里面读取相关参数，调用任务sayHello。</span></span><br><span class="line"><span class="comment"># 可以通过worker的控制台输出来看到执行过程</span></span><br></pre></td></tr></table></figure> 这里有几点要说明一下： * 调用<code>sayHello.delay</code>会立即返回一个<code>AsyncResult</code>实例。通过这个实例，我们就可以检查任务执行的状态，获取任务执行完后的返回值等等。这样，我们在django中，就可以返回给客户端一个taskid（通过该实例获得），然后客户端就可以使用这个taskid来了解任务真正的处理状态了。 * <a href="http://docs.celeryproject.org/en/latest/reference/celery.app.task.html#celery.app.task.Task.delay">delay方法</a>：<a href="http://docs.celeryproject.org/en/latest/reference/celery.app.task.html#celery.app.task.Task.apply_async">apply_async方法</a>的简略版，只接受两个参数，一个是任务的位置参数，另一个是任务的关键字参数。使用这个方法，只需要把<code>task(...)</code>直接改成<code>task.delay(...)</code>即可。懒人方法，后面的事情celery都帮你做好了。如果需要进一步的定制，则可以使用后者。后者提供了详尽的参数，你可以自己指定taskid、broker的相关信息、连接等等。</p>
<h4 id="保存任务执行结果">保存任务执行结果</h4>
<p>默认情况下，调用任务是不会保存结果的。因此，可以指定<code>backend</code>来实现任务结果的存储。对于backend，可以选择SQLAlchemy/Django ORM, Memcached, Redis, RPC (RabbitMQ/AMQP)，或者也可以自定义。</p>
<p>使用也很简单，只需要在初始化celery实例的时候给参数<code>backend</code>赋值即可： <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">app = Celery(<span class="string">&#x27;eletest&#x27;</span>, backend=<span class="string">&#x27;redis://localhost&#x27;</span>, broker=<span class="string">&#x27;amqp://ele@localhost//&#x27;</span>)</span><br></pre></td></tr></table></figure> ### celery + django = django异步化 有了celery的助攻，我们终于可以把同步的django异步掉了！！！</p>
<figure>
<img src="/img/9EE1168C9AEB4DF6925CAE3F53F143C1.jpg" alt="示意图3" /><figcaption aria-hidden="true">示意图3</figcaption>
</figure>
<p>具体如何在django中加入celery，详见<a href="http://docs.celeryproject.org/en/latest/django/first-steps-with-django.html">first steps with django</a></p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://www.celeryproject.org/">celery</a></li>
<li><a href="http://docs.celeryproject.org/en/latest/index.html">celery documentation</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Celery</tag>
      </tags>
  </entry>
  <entry>
    <title>Go, go|小白的go小抄：并发和错误</title>
    <url>/2017/08/10/Go-go-%E5%B0%8F%E7%99%BD%E7%9A%84go%E5%B0%8F%E6%8A%84%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%92%8C%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h3 id="并发">并发</h3>
<p>并发编程是一个很大的主题，这里之提一些Go特有的重点 #### 通过通信共享 共享值通过<code>channel</code>进行传递。在任意给定的时间内，只有一个goroutine可以访问到该值。在设计上，不会出现数据竞争。即</p>
<pre><code>不通过共享内存通信，相反，通过通信来共享内存</code></pre>
<p>还可以再过些。例如，也许最好将一个<code>mutext</code>放在一个整型变量附近来实现引用计数。但是，作为高级方法，使用<code>channel</code>来控制访问，会使得编写清晰正确的程序更容易。</p>
<p>关于这样一个模型，想象一下：有一个在单CPU上运行的典型的单线程程序。它无需同步原语。现在，运行另一个这样的实例，它也无需同步。然后，让这两个实例进行通信。如果这样的通信是同步器，那么仍然无需其他同步。例如，Unix的管道就完美契合这个模型。虽然，Go的并发方法起源于Hoare的CSP模型，但是它也可以被看成Unix管道的一种类型安全的泛化。</p>
<h4 id="goroutine">goroutine</h4>
<p>一个goroutine有一个简单的模型：它是一个与其他goroutine在相同的地址空间内并发地执行的函数。</p>
<p>它轻量，仅仅消耗栈空间的分配。</p>
<p>goroutine多路复用到多个OS线程，因此，如果一个goroutine阻塞了（例如等待I/O），那么，其他goroutine会继续运行。其设计隐藏了许多线程创建和管理的复杂的东西。</p>
<p>在一个方法或者函数调用前面加上前缀<code>go</code>，从而使得该调用在一个新的goroutine内运行。当调用完成的时候，这个goroutine会悄悄地退出。 <figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">go list.<span class="built_in">Sort</span>() <span class="comment">// 并发运行list.Sort。不等待</span></span><br></pre></td></tr></table></figure> 在goroutine调用中，一个函数字面量可以很方便： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Do</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(message)</span><br><span class="line">    &#125;() <span class="comment">// 注意这里的括号：必须调用这个函数！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在Go中，函数字面量是闭包：这种实现确保被函数引用的变量只要有用，就是存活着的。</p>
<h4 id="channel">channel</h4>
<p><code>channel</code>是用<code>make</code>来分配的，结果值指向一个底层的数据结构。如果给<code>make</code>提供了第二个参数，那么这个参数是<code>channel</code>的缓存大小。默认值是0，表示一个不缓存/同步channel <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cj := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 不缓存的整型channel</span></span><br><span class="line">cj := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">// 不缓存的整型channel</span></span><br><span class="line">cs := <span class="built_in">make</span>(<span class="keyword">chan</span> *os.File, <span class="number">100</span>) <span class="comment">// 指向File的缓存channel</span></span><br></pre></td></tr></table></figure> 不缓存的channel将通信（值交换）与同步结合在一起，保证两个计算（goroutine）处于已知状态。</p>
<p>一个channel能让启动的goroutine等待某些工作的完成。例如： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 分配一个channel（不缓存）</span></span><br><span class="line"><span class="comment">// 在goroutine中开始排序。当排序完成后，给channel发信号</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list.Sort()</span><br><span class="line">    c &lt;- <span class="number">1</span> <span class="comment">// 发送一个信号，值无所谓</span></span><br><span class="line">&#125;</span><br><span class="line">doSomethingForAWhile()</span><br><span class="line">&lt;- c <span class="comment">// 等待排序完成。丢弃接收到的值</span></span><br></pre></td></tr></table></figure> channel的接收者往往在收到数据之前处于阻塞状态。而对于发送者： 1. 如果channel是不缓存的，那么，发送者会一直阻塞，直到接收者接收到所发送的值。 2. 如果channel具有缓存，那么，发送者会一直阻塞，直到发送值已经拷贝到缓存中了；如果缓存满了，那么意味着，发送者会一直等待，直到某接收者收到了一个值。</p>
<p>一个带缓存的channel可以被当成一个信号量使用，例如用来限制生产量。在下面这个例子中，过来的请求被传递给<code>handle</code>。<code>handle</code>会发送一个值给某个<code>channel</code>，处理请求，然后从这个<code>channel</code>接收一个值，从而为下一个消费者准备好“信号量”。这个<code>channel</code>的缓存容量限制了对<code>process</code>同步调用的次数。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sem = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, MaxOutstanding)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">    sem &lt;- <span class="number">1</span> <span class="comment">// 等待活跃队列耗尽（这样才能执行下一行代码）</span></span><br><span class="line">    process(r) <span class="comment">// 大概也许可能会耗时较长</span></span><br><span class="line">    sem &lt;- <span class="comment">// 完成；下一个请求可以开始运行了。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一旦MaxOutstanding个handle正在执行process，</span></span><br><span class="line"><span class="comment">// 其他handle将会阻塞在往已满的channel缓存中发送数据，</span></span><br><span class="line"><span class="comment">// 直到MaxOutstanding个handle中的一个handle完成，然后从缓存中接收数据。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        req := &lt;- queue</span><br><span class="line">        <span class="keyword">go</span> handle(req) <span class="comment">// 不等待handle结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这里有一个问题：<code>Serve</code>为每个过来的请求都创建一个新的goroutine。结果是，如果请求来得太快，那么程序将会消耗无限的资源。我们可以让<code>Serve</code>为goroutine的创建设置门槛： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">        sem &lt;- <span class="number">1</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(req *Request)</span></span>&#123;</span><br><span class="line">            process(req)</span><br><span class="line">            &lt;- sem</span><br><span class="line">        &#125;(req)</span><br><span class="line">        <span class="comment">// 这里，我们不能直接在goroutine中使用req（这样的话，req变量将会在所有goroutine之间共享）</span></span><br><span class="line">        <span class="comment">// 而是将其作为一个参数传给goroutine的函数调用，从而确保对于每个goroutine而言，req都是唯一的。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 好了，让我们回到编写server的一般性问题上来。比较好的管理资源的另一个方法是，启动固定数量的<code>handle</code> goroutine，让它们都从请求channel中读取请求： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> r := <span class="keyword">range</span> queue &#123; <span class="comment">// 阻塞在接收请求中。</span></span><br><span class="line">        process(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(clientRequests <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 启动处理器</span></span><br><span class="line">    <span class="comment">// 这里，goroutine的数量（MaxOutstanding个）限制了对process的并发调用数。</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; MaxOutstanding; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> handle(clientRequests)</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;- quit <span class="comment">// 等待退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### channel的channel Go中的一个最重要的特性之一是，channel属于第一类值，它可以像其他第一类值一样，被分配和传递。对此特性的常见使用场景是实现安全并行的多路分解。</p>
<p>在前面一小节的例子中，<code>handle</code>是一个请求处理器，但是我们并没有定义它处理的请求类型。如果请求类型包含了一个用以回复的channel，那么，每个客户端就可以为其回复提供自己的路径了。我们可以将请求类型定义如下： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">    args        []<span class="keyword">int</span></span><br><span class="line">    f           <span class="function"><span class="keyword">func</span><span class="params">([]<span class="keyword">int</span>)</span> <span class="title">int</span> // <span class="title">f</span><span class="params">(args)</span></span></span><br><span class="line">    resultChan  <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 接收结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这样，我们的客户端就可以这样写了： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        s += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request := &amp;Request&#123;[]<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, sum, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)&#125;</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">clientRequests &lt;- request</span><br><span class="line"><span class="comment">// 等待响应</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;answer: %d\n&quot;</span>, &lt;-request.resultChan)</span><br></pre></td></tr></table></figure> 而对应的服务器端实现只需要修改<code>handle</code>函数： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">        req.resultChan &lt;- req.f(req.args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 并行 如果某个任务可以分成几个可以独立执行的块，那么这个任务就可以被并行处理，当每个块完成的时候，借助channel来发送信号。</p>
<p>以下面为例： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vector []<span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将操作应用到v[i], v[i+1], .., v[n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vector)</span> <span class="title">DoSome</span><span class="params">(i, n <span class="keyword">int</span>, u Vector, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ; i &lt; n; i++ &#123;</span><br><span class="line">        v[i] += u.Op(v[i])</span><br><span class="line">    &#125;</span><br><span class="line">    c &lt;- <span class="number">1</span> <span class="comment">// 发送信号表明完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 我们在循环里独立加载每个部分，一个占一个CPU。它们可以以任意顺序完成，但是，这没关系。我们仅仅是在启动所有goroutine后，通过耗尽channel来计算完成信号。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CPU核数</span></span><br><span class="line"><span class="keyword">const</span> numCPU = <span class="number">4</span></span><br><span class="line"><span class="comment">// 这里可以使用runtime.NumCPU()来返回当前机器的硬件CPU核数，从而取得硬编码</span></span><br><span class="line"><span class="comment">// 还可以使用runtime.GOMAXPROCS，它报告（或设置）一个Go程序可以同时运行的用户指定核数。默认为runtime.NumCPU()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vector)</span> <span class="title">DoAll</span><span class="params">(u Vector)</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, numCPU)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCPU; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> v.DoSome(i*<span class="built_in">len</span>(v)/numCPU, (i+<span class="number">1</span>)*<span class="built_in">len</span>(v)/numCPU, u, c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 耗尽channel</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCPU; i++ &#123;</span><br><span class="line">        &lt;- c <span class="comment">// 等待任务完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部完成啦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; <strong>注意</strong>：Go是一个并发语言，不是一个并行语言。并不是所有的并行问题都适合Go的模型的。</p>
<h3 id="错误">错误</h3>
<p>Go的多值返回使得返回一个详细的错误描述和正常的返回值成为可能。 一般来说，错误的类型为<code>error</code>，这是一个简单的内置接口： <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">type <span class="builtin-name">error</span><span class="built_in"> interface </span>&#123;</span><br><span class="line">	<span class="builtin-name">Error</span>() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 我们可以随意实现这个接口，使其变成一个更丰富的模型，这样，除了错误之外，还可以提供一些上下文信息。例如： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Op <span class="keyword">string</span></span><br><span class="line">	Path <span class="keyword">string</span></span><br><span class="line">	Err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.Op + <span class="string">&quot; &quot;</span> + e.Path + <span class="string">&quot;: &quot;</span> + e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 当可行时，错误字符串应该标识其来源，例如，带一个命名产生该错误的操作或者包的前缀。</p>
<p>关心准确错误细节的调用者可以使用类型选择或者类型断言来查找特定的错误和准确的细节。例如： <figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="meta">file</span>, err = os.<span class="meta">Create</span>(<span class="meta">filename</span>)</span><br><span class="line"><span class="meta">if</span> err == nil &#123;</span><br><span class="line">	<span class="meta">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">if</span> e, ok := err.(<span class="comment">*os.PathError);</span> ok <span class="variable">&amp;&amp;</span> e.Err == syscall.ENOSPC &#123;</span><br><span class="line">	// <span class="meta">do</span> something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### panic 向调用者报告错误的常见方式是将错误作为一个额外的返回值返回。但是，如果该错误是不可修复的呢？此时程序往往会无法运行下去。</p>
<p>出于这个原因，内置函数<code>panic</code>实际上创建了一个运行时错误，这个错误将会停止程序。该函数接收一个任意类型的参数（通常是一个字符串），这个参数会在程序挂掉的时候被打印出来。这也是一种暗示某些不可能的事情发生了的方式，例如存在死循环。</p>
<p>对于真实的库函数来说，应该避免<code>panic</code>。如果错误可以被掩盖或解决，那么相比把整个程序搞挂而言，让程序继续运行会更好些。一个可能的反例是在初始化期间：如果库真的没法设置自己，那么panic是合理的。 <figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">user</span> <span class="title">= os</span>.Getenv(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"></span><br><span class="line">func init()&#123;</span><br><span class="line">	if <span class="keyword">user</span> <span class="title">== &quot;&quot; &#123;</span></span><br><span class="line"><span class="title">		panic</span>(<span class="string">&quot;no value for $USER&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### recover 当<code>panic</code>被调用的时候（包括运行时错误的隐式调用），会立即停止当前函数的执行，然后开始沿着goroutine的堆栈展开往上退，找到被defer的函数并运行。如果退到了该goroutine栈的顶层，那么，程序就挂掉了。</p>
<p>但是，我们可以使用内置的<code>recover</code>来重新获得此goroutine的控制权，然后恢复正常的执行。</p>
<p>对<code>recover</code>的调用停止堆栈展开，然后返回传给<code>panic</code>的参数。由于在堆栈展开过长中唯一运行的代码位于被defer的函数内，所以，<code>recover</code>只有在被defer的函数内才有用。</p>
<p><code>recover</code>的应用之一是在不会杀死其他正在执行的goroutine的情况下，关闭服务器内一个失败的goroutine。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(workChan &lt;-<span class="keyword">chan</span> *Work)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> work := <span class="keyword">range</span> workChan &#123;</span><br><span class="line">        <span class="keyword">go</span> safelyDo(work)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safelyDo</span><span class="params">(work *Work)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">&quot;work failed:&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    do(work) <span class="comment">// 因为用了recover,所以这个函数可以通过调用panic来干净地摆脱任何困境。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 除非直接从一个被defer的函数内调用，否则<code>recover</code>总是返回<code>nil</code>。因此，被defer的代码可以正常地调用使用了<code>panic</code>和<code>recover</code>的库程序。</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>HelloWorld</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go, go|小白的go小抄：控制结构和函数</title>
    <url>/2017/08/03/Go-go-%E5%B0%8F%E7%99%BD%E7%9A%84go%E5%B0%8F%E6%8A%84%EF%BC%9A%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>言小白年初许下了关于golang的愿望，这是来践约的。</p>
<p>另外，本小抄无扫盲功效，如需从零开始，参见<a href="https://tour.golang.org/">A Tour of Go</a></p>
<h3 id="控制结构">控制结构</h3>
<h4 id="重新声明和重新赋值">重新声明和重新赋值</h4>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">f, <span class="keyword">err</span> := os.<span class="keyword">Open</span>(name)</span><br><span class="line"><span class="comment">// 声明两个变量：f和err</span></span><br><span class="line"><span class="keyword">d</span>, <span class="keyword">err</span> := f.Stat()</span><br><span class="line"><span class="comment">// 此处，err已经在上面语句中声明了，因此这里仅仅是重新赋值。这意味着，对f.Stat的调用使用上面已经声明的变量err，并仅仅给它赋予一个新的值</span></span><br></pre></td></tr></table></figure>
<p>在<code>:=</code>声明中，变量<code>v</code>即使已经声明过，也可以出现在<code>:=</code>的左端，只要它满足以下： * 声明和变量<code>v</code>的现有声明位于同一个作用域（如果<code>v</code>在外部作用域中已经被声明了，那么，该声明将会创建一个新的变量。这里需要注意的是，在Go中，函数参数和函数返回值的作用域和函数体相同，即使在语义上，它们出现在函数花括号外部） * 初始化中相应的值是可以被赋予v的（注意：重新声明并非引进一个新变量，而是可以看成重新赋值），并且 * 在此声明中，至少存在一个新声明的变量</p>
<h4 id="for">For</h4>
<p>三种用法： <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 就像C的<span class="keyword">for</span></span><br><span class="line"><span class="keyword">for</span> init; condition; post &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 就像C的<span class="keyword">while</span></span><br><span class="line"><span class="keyword">for</span> condition &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 就像C的f(;;)</span><br><span class="line"><span class="keyword">for</span> &#123;&#125;</span><br></pre></td></tr></table></figure> 第一种用法可以用来很容易的在循环中声明索引变量： <figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sum</span> := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">sum</span> += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 当遍历数组/切片/字符串/map，或者从channel读取值的时候，可以使用<code>range</code>: <figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">key</span>, value := <span class="built_in">range</span> oldMap &#123;</span><br><span class="line">    newMap[<span class="built_in">key</span>] = value</span><br><span class="line">&#125;</span><br><span class="line">// 当仅需要第一个项的时候，也可以把第二个省略掉</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">key</span> := <span class="built_in">range</span> m &#123;</span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="built_in">key</span>)</span><br><span class="line">&#125;</span><br><span class="line">// 当只需要第二项的时候，使用<span class="symbol">_</span></span><br><span class="line"><span class="built_in">sum</span> := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="symbol">_</span>, value := rang <span class="built_in">array</span> &#123;</span><br><span class="line">    <span class="built_in">sum</span> += value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 注意：对于string，range的每个元素都是一个rune</p>
<h4 id="switch">Switch</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unhex</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        caes <span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Go的switch语句比<code>C</code>跟广泛一些。 * 表达式无需是常量或者整型。如果switch没有表达式，那么默认为true。 * 对于<code>case</code>的评估是自上而下直至找到一个匹配的 * 可以使用<code>break</code>。<code>break</code>默认情况下退出当前的<code>switch</code>。如果<code>switch</code>语句外层嵌套了<code>for</code>循环，而要退出外层的<code>for</code>循环的话，那么可以使用标签，即在循环上面放一个标签（例如：<code>Loop</code>），然后直接<code>break</code>此标签（例如：<code>break Loop</code>）。当然，<code>continue</code>也接受一个可选的标签作为参数，但是它仅对循环有效</p>
<h4 id="type-switch">type-switch</h4>
<p>用来发现一个接口变量的动态类型。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="comment">// 下面定义了一个变量v，这个变量在各个case语句中都有对应的类型。</span></span><br><span class="line"><span class="comment">// 在这种情况下，建议重用变量名，即switch v := v.(type)。这样实际上，在每个case中声明了一个具有相同名称，但是不同类型的新变量。</span></span><br><span class="line"><span class="keyword">switch</span> v := a.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">    <span class="comment">// v类型为bool</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T %t\n&quot;</span>, v, v)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">    <span class="comment">// v类型为int</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T %d\n&quot;</span>, v, v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Printf(<span class="string">&quot;unexpected type %T\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数">函数</h3>
<h4 id="多值返回">多值返回</h4>
<p>和Python不一样，对于go的多值返回，在指定输入参数后，需要指定要返回的值列表。例如： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 否则会报错：<code>too many arguments to return</code></p>
<p>多值返回的好处在于： * 带错误返回 * 避免的需要传递一个指针来返回一个值</p>
<h4 id="命名返回参数">命名返回参数</h4>
<p>在Go中，可以命名一个函数的返回参数，并将其作为常规变量使用（就如函数接收参数一样）。此时，返回参数会被初始化为其类型的零值。如果函数直接<code>return</code>（不带任何参数），那么返回参数的当前值就会被当成返回值返回。</p>
<p>不强制命名返回参数，但是这能让代码更短更清晰。</p>
<h4 id="missing-return-at-end-of-function"><code>missing return at end of function</code></h4>
<p>在Go 1.1，无需总是在函数末端添加return语句，但是需要有个结束声明。</p>
<p>推荐阅读： - <a href="https://golang.org/doc/go1.1#return">return</a> - <a href="https://golang.org/ref/spec#Terminating_statements">Terminating statement</a></p>
<h4 id="defer">Defer</h4>
<p>Go会在执行<code>defer</code>语句的函数返回之前立即执行<code>defer</code>语句后面的函数。常见的使用场景为解锁一个mux，或者关闭文件。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contents</span><span class="params">(filename <span class="keyword">string</span>)</span><span class="params">(<span class="keyword">string</span> error)</span></span> &#123;</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 对诸如<code>Close()</code>这样的函数使用<code>defer</code>有两个好处： * 保证你永远不会忘记做清理操作 * 将其放在诸如<code>Open()</code>这样的函数后面，使得代码更清晰</p>
<p><strong>注意</strong>：在<code>defer func()</code>中，函数<code>func</code>的参数（如果函数是个方法，那么也包含接收者）会在<code>defer</code>执行的时候计算，而不是在函数<code>func</code>执行的时候计算。这样避免了在函数执行的时候变量值的改变，也意味着单个<code>defer</code>调用可以defer多个函数执行。例如： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：4 3 2 1 0</span></span><br></pre></td></tr></table></figure> 另外，可以看出，被defer的函数执行顺序遵循LIFO</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>HelloWorld</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go, go|小白的go小抄：方法、接口和其他类型</title>
    <url>/2017/08/06/Go-go-%E5%B0%8F%E7%99%BD%E7%9A%84go%E5%B0%8F%E6%8A%84%EF%BC%9A%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="方法">方法</h3>
<h4 id="指针-vs.-值">指针 VS. 值</h4>
<p>可以为任何命名类型（除了指针或者接口外）定义方法。方法的接收者不是一定要是结构的。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteSlice []<span class="keyword">byte</span></span><br><span class="line"><span class="comment">// 值方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(slice ByteSlice)</span> <span class="title">Append</span><span class="params">(data []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123; <span class="comment">// 要求该方法返回更新的值</span></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指针方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ByteSlice)</span> <span class="title">Append</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123; <span class="comment">// 这个方法可以修改调用者，因此不用返回</span></span><br><span class="line">    slice := *p</span><br><span class="line">    ....</span><br><span class="line">    *p = slice</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ByteSlice)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    slice := *p</span><br><span class="line">    <span class="comment">// Again as above.</span></span><br><span class="line">    *p = slice</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(data), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义了Write方法后，类型*ByteSlice就满足了标准接口io.Write的要求。</span></span><br><span class="line"><span class="keyword">var</span> b ByteSlice</span><br><span class="line">fmt.Fprintf(&amp;b, <span class="string">&quot;This hour has %d days\n&quot;</span>, <span class="number">7</span>)</span><br><span class="line"><span class="comment">// 这里传递ByteSlice的地址是因为，只有*ByteSlice满足了标准接口io.Write的要求。</span></span><br></pre></td></tr></table></figure> 对于接收者而言，关于指针vs.值的规则是：<strong>可以对指针和值引用值方法，但是，只能对指针引用指针方法。</strong></p>
<p>这是因为，指针方法可以修改接收者，而对值引用指针方法可能会造成该方法接收到该值的一份拷贝，从而使得任何的修改都会被丢弃。因此，Go不允许这种错误。当该值是可寻址的时候，Go会自动插入取址运算符（&amp;），来处理在值上引用指针方法的这种常见场景。例如，在上面的例子中，变量<code>b</code>是可寻址的，因此，通过<code>b.Write</code>就可以调用它的<code>Write</code>方法。编译器会为我们重写成<code>(&amp;b).Write</code>。</p>
<h3 id="接口和其他类型">接口和其他类型</h3>
<h4 id="接口">接口</h4>
<p>Go中的接口提供了一种指定对象行为的方式：如果某个东东可以做这个事，那么，它就可以被用在这里。在Go中，只有一两个方法的接口比比皆是，并且常常会根据方法来赐名，例如，<code>io.Writer</code>就是那些实现了<code>Write</code>的东东。</p>
<p>一个类型可以实现多个接口。例如，一个集合可以被包<code>sort</code>中的程序排序，只要它实现了<code>sort.Interface</code>（包括<code>Len()</code> / <code>Less(i, j int) bool</code> / <code>Swap(i, j int)</code>），另外，它还可以有一个自定义的格式器（<code>String</code>方法）。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Sequence []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort.Interface所要求的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s[i] &lt; s[j]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用以打印的方法：在打印前先排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    sort.Sort(s)</span><br><span class="line">    str := <span class="string">&quot;[&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i, elem := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            str += <span class="string">&quot; &quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        str += fmt.Sprint(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str + <span class="string">&quot;]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 转换 在上面的例子中，<code>Sequence</code>的<code>String</code>方法重新实现了<code>Sprint</code>已经为切片实现的东西，因此，我们可以在调用<code>Sprint</code>之前将<code>Sequence</code>转换成一个普通的<code>[]int</code>，从而来利用它已实现的东东： <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">func (s Sequence) <span class="constructor">String()</span> <span class="built_in">string</span> &#123;</span><br><span class="line">    sort.<span class="constructor">Sort(<span class="params">s</span>)</span></span><br><span class="line">    return fmt.<span class="constructor">Sprint([]<span class="params">int</span>(<span class="params">s</span>)</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这里的转换并不会创造一个新的值，它只是暂时假装现有的值有一个新的类型。（有其他合法的转换，例如从整型到浮点数，这确实会创造一个新的值。）</p>
<p>在Go程序中，会转换一个表达式的类型，从而访问一个不同的方法集。还是上面的这个例子，我们可以使用现有的类型<code>sort.IntSlice</code>来把上面的代码缩减成: <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Sequence <span class="literal">[]</span><span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用以打印的方法：在打印前先排序</span></span><br><span class="line">func (s Sequence) <span class="constructor">String()</span> <span class="built_in">string</span> &#123;</span><br><span class="line">    sort.<span class="constructor">IntSlice(<span class="params">s</span>)</span>.<span class="constructor">Sort()</span></span><br><span class="line">    return fmt.<span class="constructor">Sprint([]<span class="params">int</span>(<span class="params">s</span>)</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这样，Sequence就不需要实现多个接口（排序和打印）了。使用一个数据项能转换成多种类型（<code>Sequence</code> / <code>sort.IntSlice</code> / <code>[]int</code>）的能力，这些类型每一种都完成部分的工作。</p>
<h4 id="接口转换和类型断言type-assertion">接口转换和类型断言（type assertion）</h4>
<p>类型选择（type switch）是这样一个东东的：接收一个接口，然后对于<code>switch</code>中的每一个<code>case</code>，在某种意义上将其转换成那个<code>case</code>的类型。下面是<code>fmt.Printf</code>中的代码如何使用类型选择来将一个值转换成一个字符串的简化示例： <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="built_in">String</span>() <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 调用者提供的值</span></span><br><span class="line"><span class="keyword">switch</span> str := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="built_in">string</span>:</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">case</span> Stringer:</span><br><span class="line">    <span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 类型断言（type assertion）：接收一个接口值，然后从中提取所指定的显式类型的值。 * 语法为<code>newVal, ok := value.(typeName)</code> * 其中，<code>newVal</code>是一个具有静态类型<code>typeName</code>的新值 * <code>typeName</code>必须是该接口<code>value</code>具有的具体类型，或者是<code>value</code>可以转换的第二个接口类型。 * <code>ok</code>是个可选项。如果不带，那么当值不是/无法转换成<code>typeName</code>的时候，程序会崩溃并抛出运行时错误。因此，可以使用<code>ok</code>（“comma, ok”习语）来安全地测试该值是否为<code>typeName</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>, ok := value.(string)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;string value is: %q\n&quot;</span>, <span class="built_in">str</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;value is not a string\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">// 如果类型断言失败，那么，<span class="built_in">str</span>将仍然存在，并且类型为string，但是它将是一个零值，即<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure> ### 参考 - <a href="https://golang.org/doc/effective_go.html">Effective Go</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>HelloWorld</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go | http.Server 优雅退出方式简析</title>
    <url>/2018/09/04/Go-%E7%9A%84-http-Server-%E4%BC%98%E9%9B%85%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[<p>Go 1.8 为我们带来了 http 服务优雅退出的方式：<code>Server.Shutdown</code>。对于该方法，代码中的解释是：</p>
<blockquote>
<p><code>Shutdown</code> 方法会在不干扰任何活跃连接的情况下关闭服务器。首先，它会关闭所有开着的监听器，然后关闭所有空闲连接，接着无限等待所有连接变成空闲状态，最后关闭。</p>
<p>如果提供的 <code>context.Context</code> 对象在关闭完成之前过期了，那么，<code>Shutdown</code> 方法返回该 <code>Context</code> 对象的错误信息。否则，它会将正在关闭的服务器的底层监听器的错误返回（如果有的话）。</p>
<p>一旦调用了 <code>Shutdown</code> 方法，<code>Serve</code>、<code>ListenAndServe</code> 和 <code>ListenAndServeTLS</code> 会立即返回 <code>ErrServerClosed</code>。需要确保程序不退出，而是等待 <code>Shutdown</code> 返回。</p>
<p><code>Shutdown</code> 并不会像 <code>WebSockets</code> 那样尝试关闭或者等待被劫持的连接。<code>Shutdown</code> 的调用者应该在需要的时候，挨个通知这些长期存在的连接关闭，并且等待它们关闭。</p>
</blockquote>
<p>接下来我们来看下 <code>Shutdown</code> 方法的实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Shutdown</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        atomic.AddInt32(&amp;srv.inShutdown, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">defer</span> atomic.AddInt32(&amp;srv.inShutdown, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        srv.mu.Lock()</span><br><span class="line">        lnerr := srv.closeListenersLocked()</span><br><span class="line">        srv.closeDoneChanLocked()</span><br><span class="line">        <span class="keyword">for</span> _, f := <span class="keyword">range</span> srv.onShutdown &#123;</span><br><span class="line">                <span class="keyword">go</span> f()</span><br><span class="line">        &#125;</span><br><span class="line">        srv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">        ticker := time.NewTicker(shutdownPollInterval)</span><br><span class="line">        <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> srv.closeIdleConns() &#123;</span><br><span class="line">                        <span class="keyword">return</span> lnerr</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                        <span class="keyword">return</span> ctx.Err()</span><br><span class="line">                <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>基于 go 1.9.2</p>
</blockquote>
<p>上面的代码做了几件事： 1. 将 Server 的字段 <code>inShutdown int32</code> 加一。这个字段用于 Server 非公开方法 <code>shuttingDown</code> 中，非零表示 Server 正在关闭。 2. 调用 <code>closeListenersLocked</code> 方法，关闭所有打开的监听器。 3. 调用 <code>closeDoneChanLocked</code> 方法，关闭 <code>doneChan   chan struct&#123;&#125;</code>。从而通知 <code>Serve</code>、<code>ListenAndServe</code> 和 <code>ListenAndServeTLS</code> 退出并返回 <code>ErrServerClosed</code> 错误。 4. 将所有使用 <code>RegisterOnShutdown</code> 方法注册的方法（保存在 <code>onShutdown []func()</code> 中）放在单独的 goroutine 中调用，并且不等待方法返回。这些方法不应该等待关闭完成。 5. 创建一个定时器，定时时间由 <code>shutdownPollInterval</code> 指定，默认是 500ms。目前没有可以修改该值的方法。 6. 每到步骤 5 创建的定时时间调用一次 <code>closeIdleConns</code> 方法关闭空闲连接。无限循环直到该方法返回 true（表示服务器已经处于静默模式），或者当 <code>ctx</code> 过期了。如果是前者，则返回步骤 2 的执行结果。后者则返回 <code>ctx</code> 的错误信息。</p>
<p>由此可见，<code>Shutdown</code> 方法主要是做了两件事：关闭监听器和关闭空闲连接。</p>
<p>前者直接调用监听器的 <code>Close</code> 方法。这里需要注意的是，一旦该方法调用失败，只会保存错误信息，并且继续调用下一个监听器的 <code>Close</code> 方法。如果存在多个监听器关闭错误，也只会返回其中一个错误。</p>
<p>我们来看看后者的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// closeIdleConns closes all idle connections and reports whether the</span></span><br><span class="line"><span class="comment">// server is quiescent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">closeIdleConns</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        s.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">        quiescent := <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> c := <span class="keyword">range</span> s.activeConn &#123;</span><br><span class="line">                st, ok := c.curState.Load().(ConnState)</span><br><span class="line">                <span class="keyword">if</span> !ok || st != StateIdle &#123;</span><br><span class="line">                        quiescent = <span class="literal">false</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                c.rwc.Close()</span><br><span class="line">                <span class="built_in">delete</span>(s.activeConn, c)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quiescent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码做了几件事： 1. 检查 <code>activeConn map[*conn]struct&#123;&#125;</code> 中的每个连接状态 2. 如果连接不是 idle 的，那么设置服务器为非静默模式，然后继续检查下一个连接 3. 如果连接已经是 idle 的了，那么关闭该连接，并且将其从 <code>activeConn</code> 中删除 4. 最后返回服务器是否处于静默状态。</p>
<p>和一般的 <code>Close</code> 方法进行对比：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Close immediately closes all active net.Listeners and any</span></span><br><span class="line"><span class="comment">// connections in state StateNew, StateActive, or StateIdle. For a</span></span><br><span class="line"><span class="comment">// graceful shutdown, use Shutdown.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Close does not attempt to close (and does not even know about)</span></span><br><span class="line"><span class="comment">// any hijacked connections, such as WebSockets.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Close returns any error returned from closing the Server&#x27;s</span></span><br><span class="line"><span class="comment">// underlying Listener(s).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        srv.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> srv.mu.Unlock()</span><br><span class="line">        srv.closeDoneChanLocked()</span><br><span class="line">        err := srv.closeListenersLocked()</span><br><span class="line">        <span class="keyword">for</span> c := <span class="keyword">range</span> srv.activeConn &#123;</span><br><span class="line">                c.rwc.Close()</span><br><span class="line">                <span class="built_in">delete</span>(srv.activeConn, c)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区别如下： 1. <code>Shutdown</code> 方法会调用注册的关闭时执行的方法，而 <code>Close</code> 方法没有。 2. <code>Shutdown</code> 方法会等待所有活跃连接变成 idle 状态才关闭连接，而 <code>Close</code> 方法则直接关闭连接。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>读代码</tag>
      </tags>
  </entry>
  <entry>
    <title>Go/HTTP | 标准库对请求头的处理简析</title>
    <url>/2018/03/14/Go%E7%9A%84HTTP%E6%A0%87%E5%87%86%E5%BA%93%E5%AF%B9%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%9A%84%E5%A4%84%E7%90%86%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[<p>某次测试一个用 Go 编写的 HTTP 服务（使用 nginx 进行了反向代理）的时候，发现请求直接返回了 <code>400 Bad Request: invalid header value</code>。而在 handler 入口处的调试日志并没有打印。同时，nginx 日志显示，请求已经被转发到了后面的 HTTP 服务。也就是说，这个 400 错误是 Go 在接受请求后，进入 handler 之前返回的。故而在此记录下，Go 的 HTTP 标准库对请求 header 的处理方式。</p>
<h2 id="httplex"><code>httplex</code></h2>
<p>golang 的标准库 <code>net/http</code> 使用 <a href="https://godoc.org/golang.org/x/net/lex/httplex"><code>golang.org/x/net/lex/httplex</code></a> 对请求头进行校验。其中，有三个校验函数：</p>
<ul>
<li><p><code>func ValidHeaderFieldName(v string) bool</code></p>
<p>用以检验 <code>v</code> 是否为一个有效的 HTTP/1.x 的 header 字段名。（对于 HTTP/2 有额外的限制：不允许大写的 ASCII 字母）</p>
<blockquote>
<p>检验标准：RFC 7230。不能为空，并且字符范围为："!" / "#" / "$" / "%" / "&amp;" / "'" / "*" / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~" / DIGIT（数字） / ALPHA（字母，不区分大小写）</p>
</blockquote></li>
<li><p><code>func ValidHeaderFieldValue(v string) bool</code></p>
<p>用以检验 <code>v</code> 是哦否为一个有效的 header 字段值。</p>
<blockquote>
<p>检验标准：<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2">http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2</a></p>
</blockquote></li>
<li><p><code>func ValidHostHeader(h string) bool</code></p>
<p>用以检验 <code>h</code> 是否为一个有效的 <code>Host</code> 头。</p>
<blockquote>
<p>当前的校验标准：不完全受 rfc7230 限制，只要字符范围为 "!" / "$" / "%" / "&amp;" / "(" / ")" / "*" / "+" / "," / "-" / "." / ":" / ";" / "=" / "[" / "'" / "]" / "_" / "~" / DIGIT（数字） / ALPHA（字母，不区分大小写）即可。</p>
</blockquote></li>
</ul>
<h2 id="nethttp-对请求头的校验"><code>net/http</code> 对请求头的校验</h2>
<blockquote>
<p>使用 go 1.9.2，HTTP/1.x。代码位于 <code>net/http/server.go</code> 中</p>
</blockquote>
<ul>
<li><code>Host</code> 头的数目不能超过 1，否则： <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ curl http:<span class="regexp">//</span>localhost:<span class="number">18080</span>/ -H <span class="string">&quot;Host: 123&quot;</span> -H <span class="string">&quot;Host: 456&quot;</span></span><br><span class="line"><span class="number">400</span> Bad Request: too many Host headers</span><br></pre></td></tr></table></figure></li>
<li><code>Host</code> 头的值可以通过 <code>httplex.ValidHostHeader</code> 方法的校验，否则： <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ curl http:<span class="regexp">//</span>localhost:<span class="number">18080</span>/ -H <span class="string">&quot;Host: 123@&quot;</span></span><br><span class="line"><span class="number">400</span> Bad Request: malformed Host header</span><br></pre></td></tr></table></figure></li>
<li>每一个 header 的字段名都可以通过 <code>httplex.ValidHeaderFieldName</code> 的校验，否则： <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ curl http:<span class="regexp">//</span>localhost:<span class="number">18080</span>/ -H <span class="string">&quot;Host: 123&quot;</span> -H <span class="string">&quot;X-Custome@tes123: 123abc&quot;</span></span><br><span class="line"><span class="number">400</span> Bad Request: invalid header name</span><br></pre></td></tr></table></figure></li>
<li>每一个 header 的字段值都可以通过 <code>httplex.ValidHeaderFieldValue</code> 的校验，否则返回： <figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">400 </span>Bad Request: invalid header value</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="碎碎念">碎碎念</h2>
<p>当发送 HTTP 请求后，收到 Go 自身标准库的错误返回，而不是自己编写的错误返回时，如果错误信息模糊无法确定真正的异常原因。那么只好拿着错误信息到 <code>net/http</code> 包代码所在到位置直接暴力搜索了。有时候可以加上日志打印，把错误抛出的上下文打印出来（记得备份源代码，记得删除 <code>http.a</code> 文件，记得重新编译！！）。这样，就可以让服务“直接”告诉你根因所在了。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>2016年点亮技能树的某个枝桠</title>
    <url>/2016/03/01/2016%E5%B9%B4%E7%82%B9%E4%BA%AE%E6%8A%80%E8%83%BD%E6%A0%91%E7%9A%84%E6%9F%90%E4%B8%AA%E6%9E%9D%E6%A1%A0/</url>
    <content><![CDATA[<p>这是一篇散文。 首页就挂着一篇文，感觉丑不拉几的。所以决定写点什么来缓冲下。</p>
<p>2015年的后几个月大体就做了几件事：把Python的官文看了一下（部分），顺手翻了几篇；把Scrapy的官文看了一下，忘记翻了；把Django的官文看了一下（部分），顺手翻了几篇（基本都是又臭又长呀Q_Q）；入门了Flask，给我家小派写了一个小网站；为了给我家Eva做个人网站，整体看了下CSS和JQuery，前端这个分支算是正式入了门，写点页面还是没问题的。哦，期间还折腾了好几家的登录，Chrome上F12按得越来越多；玩了一下我家的小派，只是因为暂时还没有做啥智能硬件的想法，因此Arduino还处在吃灰的状态。哦，还有就是每周六还是周日翻一两篇Pycoder weekly推的文。</p>
<p>总结一下，就是Python好好的学了下，idea驱动下作了一些乱七八糟的东西，以及翻译。</p>
<p>表示其实挺失败的呀。这段时间不断的跟拖延症大魔王及小说邪神做抗争，屡战屡败，屡败屡战，整个人都不好不好哒。</p>
<p>但是我很感谢这段gap time。因为没有心理压力，所以可以好好的做自己想做的事，好好的系统的看一些书，好好的看一些电影电视剧然后笑得像个傻瓜。</p>
<p>而今天呢，已经是2016的第三个月了。我对自己期许还是挺多的。前几天有人问我我的职业规划是什么。我其实不是很清楚。在这个行业里，我喜欢的东西很多很多，我希望我有机会尽可能的尝试，不管是作为职业，还是作为个人爱好。我最近常常在想，作为一个female，在年龄的诅咒下该如何存活。有友曰，如果想coding，那就一直coding下去呀。亦有友言，你可以努力做到让别人忽略你的性别。Both of them are right, I think.</p>
<p>所以，对于2016年的期许，就是我能再点亮技能树的某个枝桠：</p>
<ol type="1">
<li>关于Python
<ul>
<li>把Python带进工作。除了个人需求，应该去看看它在实际中是怎么玩的</li>
<li>看完Python源代码剖析，学习Python高级编程（硬盘下python的深入目录多看看）</li>
<li>把我家Eva的个人网站弄上线</li>
</ul></li>
<li>关于翻译君
<ul>
<li>每周的Pycoder weekly翻译不要忘记。如果可以的话，还要继续翻那些官文。因为你的初衷不过是，练练翻译水平从而练练英语，有了中文版阅读更方便。</li>
</ul></li>
<li>关于android
<ul>
<li>新的技能呀</li>
<li>我的wunderlist里面还躺着两个关于android的idea呢。</li>
<li>不要抗拒，好好学它，这是征服自己的一步棋。年底的时候，用两个app来检验吧</li>
</ul></li>
<li>关于算法与数据结构
<ul>
<li>不多说了，保持思维很重要</li>
<li>leetcode和checkio的题尽量刷完并整理掉吧</li>
</ul></li>
<li>关于安全
<ul>
<li>我还记得当年玩破解的那段安静燃烧的时光</li>
<li>所以，安全什么的，今年的目标就是逆向吧。书单已写好。</li>
<li>关注智能家居的安全，关注java类，C/C++类应用的逆向</li>
</ul></li>
<li>关于shell
<ul>
<li>这个也是新技能，光会看是不够的，你还要会写！</li>
<li>不要抗拒，好好学它，这也是征服自己的一步棋。</li>
</ul></li>
<li>关于idea
<ul>
<li>每个人都会有很多一闪而过的想法，我也有。所以现在要做的，就是一有想法就把它记下来！</li>
<li>idea驱动真的是学东西最好的方法！！</li>
</ul></li>
</ol>
<p>在2016年剩下的时间里，如果拖延症大魔王又来找你，如果又迷迷糊糊不知道怎么走，就来看看这篇散文吧。当你不知道该怎么办的时候，你可以做的，就是先走下去。</p>
]]></content>
      <categories>
        <category>这就是生活</category>
      </categories>
      <tags>
        <tag>Ele在思考</tag>
      </tags>
  </entry>
  <entry>
    <title>UnicodeDecodeError实录</title>
    <url>/2015/11/22/UnicodeDecodeError%E5%AE%9E%E5%BD%95/</url>
    <content><![CDATA[<p>UnicodeDecodeError错误是在使用Python的时候最常碰到的问题。谁让我们博大精深的中文不能用简简单单256个字符表示呢。 加之有很多错误犯了又犯。因此，整理此UnicodeDecodeError菜谱。（此文会不定时更新╮(╯▽╰)╭）</p>
<ul>
<li><p>解析网页返回值时使用例如<code>resp.decode("utf-8")</code>出现<code>'utf8' codec can't decode byte 0x8b in position 1:</code> 查看response header有<code>Content-Type:application/x-javascript; charset=UTF-8</code>。因此使用utf-8解码是没有问题的。去掉decode直接print到控制台却发现resp为一堆乱码。 此时，查看response header发现<code>Content-Encoding:gzip</code>。(关于gzip，可以参考<a href="http://www.cnblogs.com/TankXiao/archive/2012/11/13/2749055.html">HTTP协议 (三) 压缩</a>)因此，可以选择手动解压，或者去掉<code>Content-Encoding:gzip</code> 参考: <a href="http://segmentfault.com/q/1010000000187171">urllib2 乱码问题</a></p></li>
<li><p>json.dump生成的文件中中文被保存成<code>\uXXXX\uXXXX</code>的形式。 因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False。 参考：<a href="http://www.cnblogs.com/biangbiang/archive/2013/02/19/2916780.html">python json.dumps 中的ensure_ascii 参数引起的中文编码问题</a></p></li>
<li><p>使用scrapy时，用export feed导出的json文件中若出现中文，中文会被保存成<code>\uXXXX\uXXXX</code>的形式。 原因同上.修改方式是： 找到<code>scrapy/extensions/feedexport.py</code>文件，将<code>FeedExporter</code>类中的<code>open_spider</code>方法修改为如下: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_spider</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">        uri = self.urifmt % self._get_uri_params(spider)</span><br><span class="line">        storage = self._get_storage(uri)</span><br><span class="line">        file = storage.<span class="built_in">open</span>(spider)</span><br><span class="line">        <span class="comment"># enable user defined feed parameters</span></span><br><span class="line">        kw = self.settings.get(<span class="string">&#x27;FEED_PARAMS&#x27;</span>,&#123;&#125;)</span><br><span class="line">        exporter = self._get_exporter(file, fields_to_export=self.export_fields,**kw)</span><br><span class="line">        exporter.start_exporting()</span><br><span class="line">        self.slot = SpiderSlot(file, exporter, storage, uri)</span><br></pre></td></tr></table></figure> 然后在project的<code>settings.py</code>文件中增加一行配置项：<code>FEED_PARAMS = &#123;'ensure_ascii': False, 'indent': 4&#125;</code></p></li>
<li><p>解析html，根据charset得知编码方式为gb2312，因此解码使用html.decode("gb2312")，结果报错：<code>UnicodeDecodeError: 'gb2312' codec can't decode bytes in position 218066-218067</code> 有些网站虽然声明了编码方式为gb2312，但实际上应该使用这个字符集的超集GBK来解码。修改成html.decode("gbk")即可。</p></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Checkio.org | Mono Captcha题解</title>
    <url>/2015/10/08/%5BCheckio.org%5DMono%20Captcha%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>昨天在<a href="http://www.checkio.org">checkio</a>上做了一道挺有意思的题。这道题中同时用上了列表推导、filter、int、join、map、bin和数字异或的特性。将解题思路记下来，也算是对自己近期学习Python的一个总结吧~~</p>
<h1 id="题目译">题目(译)</h1>
<p>原题地址：<a href="http://www.checkio.org/mission/mono-captcha/">Mono Captcha</a> 让我们来教教机器人Stephan识别简单的数字。机器人使用低分辨率的等宽字体。你可以看看下面图片中的字体感受一下。这个字体具备一个像素错误的抗噪能力。 <img src="https://checkio.s3.amazonaws.com/task/media/f42e5164c8bc4dd8a1cf73d34f74715f/font.png" /> 你的程序应该能够读取以二进制数字矩阵图像显示的数字。每一个数字最多只允许包含一个错误的像素。每个数字之间是一个像素的空间（例如"1"虽然比其他数字窄，但是还是具有3个像素的宽度）。 <img src="https://checkio.s3.amazonaws.com/task/media/f42e5164c8bc4dd8a1cf73d34f74715f/captcha.png" /></p>
<h2 id="输入">输入</h2>
<p>一个图片，该图片用拥有取值为1或0的列表组成的列表 ## 输出 整型数字</p>
<h2 id="例子">例子</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">checkio([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]]) == <span class="number">394</span></span><br><span class="line">checkio([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]]) == <span class="number">394</span></span><br></pre></td></tr></table></figure>
<h2 id="前提条件">前提条件</h2>
<p>矩阵行数 == 5 5 ≤ 矩阵列数 &lt; 30 ∀ x ∈ 矩阵 : x == 0 or x == 1 数字宽度 == 3 每一个数字至多包含一个像素错误。 数字间宽度 == 1</p>
<h1 id="题解">题解</h1>
<p>由于每个数字的宽度和数字间的间隔是固定的，因此可以分割输入矩阵为一个一个的数字块，然后比较该数字块与哪一个数字块最接近即可。因此，思路梳理为：分割 -&gt; 查找 -&gt; 拼接</p>
<h2 id="分割">分割</h2>
<p>由于只能使用Python自带模块，因此不能考虑使用例如第三方模块numpy来进行简单快速的矩阵操作进行矩阵分割。此时，可以使用列表推导代替。 另外，由于每个数字的宽度是3， 数字间宽度为1，因此，第i个数字为矩阵的第1+i<em>4列到第3+i</em>4列。 此时，可以写出类似下面的代码来分割： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slice</span>(<span class="params">array, index=<span class="number">0</span></span>):</span></span><br><span class="line">	<span class="keyword">return</span> [item[<span class="number">1</span>+index*<span class="number">4</span>:<span class="number">4</span>+index*<span class="number">4</span>] <span class="keyword">for</span> item <span class="keyword">in</span> array]</span><br></pre></td></tr></table></figure> ## 查找 首先，我们需要建立一个正确的数字二进制矩阵集。这样的话，就可以将分割出来的每一个数字与标准进行对比。只要找到一个数字n，与分割出来的数字i最多存在一个位的不同，那么说明i所表示的就是数字n。 这里使用二进制异或的概念来实现。由于每个矩阵都是由0或1组成的，那么很容易就可以将每个数字转换为一个15位的二进制字符串。将二进制字符串m与分割出来的数字所转换成的二进制字符串j进行异或运算得到结果z。当z为0或者z的二进制表示中只包含一个"1"时，表明这个m对应的数字就是我们要找的数字。 根据上面分析得到的正确的数字二进制矩阵集如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">digits = &#123;<span class="number">0b010110010010010</span>:<span class="string">&#x27;1&#x27;</span>,<span class="number">0b111001011100111</span>:<span class="string">&#x27;2&#x27;</span>,<span class="number">0b111001010001111</span>:<span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">		<span class="number">0b101101111001001</span>:<span class="string">&#x27;4&#x27;</span>,<span class="number">0b111100110001110</span>:<span class="string">&#x27;5&#x27;</span>,<span class="number">0b011100111101011</span>:<span class="string">&#x27;6&#x27;</span>,</span><br><span class="line">		<span class="number">0b111001010100100</span>:<span class="string">&#x27;7&#x27;</span>,<span class="number">0b111101111101111</span>:<span class="string">&#x27;8&#x27;</span>,<span class="number">0b011101111001110</span>:<span class="string">&#x27;9&#x27;</span>,<span class="number">0b110101101101011</span>:<span class="string">&#x27;0&#x27;</span>&#125;</span><br></pre></td></tr></table></figure> 需要修改一下分割函数，使得返回的也是编码后的数字： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span>(<span class="params">array, index=<span class="number">0</span></span>):</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join([<span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="keyword">lambda</span> i:<span class="built_in">str</span>(i),item[<span class="number">1</span>+index*<span class="number">4</span>:<span class="number">4</span>+index*<span class="number">4</span>])) <span class="keyword">for</span> item <span class="keyword">in</span> array]),<span class="number">2</span>)</span><br></pre></td></tr></table></figure> 对应的判断函数如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">func = <span class="keyword">lambda</span> value, real=transfer(array,i): <span class="number">1</span> == <span class="built_in">bin</span>(value^real).count(<span class="string">&quot;1&quot;</span>) <span class="keyword">or</span> <span class="string">&#x27;0b0&#x27;</span> == <span class="built_in">bin</span>(value^real)</span><br></pre></td></tr></table></figure> ## 拼接 怎么根据查找到的二进制字符串找到对应的数字呢？此时我们可以用filter函数：<code>filter(func,digits)</code> 由于digits是字典，因此实际上func中的value取的是digits的键，这就是为什么digits长得这么怪异。另外，我们也可以利用digits的键值查找到对应的数字。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">digits[<span class="built_in">filter</span>(func,digits)[<span class="number">0</span>]]</span><br></pre></td></tr></table></figure> # 完整代码 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span>(<span class="params">array, index=<span class="number">0</span></span>):</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join([<span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="keyword">lambda</span> i:<span class="built_in">str</span>(i),item[<span class="number">1</span>+index*<span class="number">4</span>:<span class="number">4</span>+index*<span class="number">4</span>])) <span class="keyword">for</span> item <span class="keyword">in</span> array]),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkio</span>(<span class="params">array</span>):</span></span><br><span class="line">	digits = &#123;<span class="number">0b010110010010010</span>:<span class="string">&#x27;1&#x27;</span>,<span class="number">0b111001011100111</span>:<span class="string">&#x27;2&#x27;</span>,<span class="number">0b111001010001111</span>:<span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">		<span class="number">0b101101111001001</span>:<span class="string">&#x27;4&#x27;</span>,<span class="number">0b111100110001110</span>:<span class="string">&#x27;5&#x27;</span>,<span class="number">0b011100111101011</span>:<span class="string">&#x27;6&#x27;</span>,</span><br><span class="line">		<span class="number">0b111001010100100</span>:<span class="string">&#x27;7&#x27;</span>,<span class="number">0b111101111101111</span>:<span class="string">&#x27;8&#x27;</span>,<span class="number">0b011101111001110</span>:<span class="string">&#x27;9&#x27;</span>,<span class="number">0b110101101101011</span>:<span class="string">&#x27;0&#x27;</span>&#125;</span><br><span class="line">	</span><br><span class="line">	res = <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="comment">#数字的个数可以用矩阵的列数len(array[0])/4得到，当然，python3k在这里需要修改一下</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="built_in">len</span>(array[<span class="number">0</span>])/<span class="number">4</span>): </span><br><span class="line">		func = <span class="keyword">lambda</span> value, real=transfer(array,i): <span class="number">1</span> == <span class="built_in">bin</span>(value^real).count(<span class="string">&quot;1&quot;</span>) <span class="keyword">or</span> <span class="string">&#x27;0b0&#x27;</span> == <span class="built_in">bin</span>(value^real)</span><br><span class="line">		res+=digits[<span class="built_in">filter</span>(func,digits)[<span class="number">0</span>]]</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">int</span>(res)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>checkio</tag>
      </tags>
  </entry>
  <entry>
    <title>Python | 沪江部落自动登录打卡</title>
    <url>/2015/09/26/%5BPython%5D%E6%B2%AA%E6%B1%9F%E9%83%A8%E8%90%BD%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E6%89%93%E5%8D%A1/</url>
    <content><![CDATA[<p>现在好多网站都有打卡或者领金币之类的功能。但素，那么多网站，肿么可能记着都要打卡~~而且，每个网站都要上去点几下超级花费时间的。恰好又有banana pro，就想着要不弄个脚本，记个定时任务，让打卡这件事自动化好了。</p>
<p><a href="www.hujiang.com/">沪江</a>是个棒棒哒的外语学习网站。就以其为目标好了~</p>
<p>整个思路是 1. 模拟用户登录 2. 打卡</p>
<p>是不是So easy~~ 妈妈再也不用怕我忘记打卡了</p>
<h1 id="登录">登录</h1>
<h2 id="准备工作">准备工作</h2>
<p>一般来说，网站的登录模式就是客户端发送一个请求，这个请求包含了用户的信息（用户名、密码之类的）。服务端会对这个请求进行校验鉴权，然后返回给客户端一个响应，告知客户端用户是否登录成功。因此，首先，要先分析客户端给服务器发送了一个神马样子的请求。打开chrome，F12，尝试用沪江账号登录，可以得到一个GET请求，见下图</p>
<p><img src="/img/2501509261131.PNG" /></p>
<pre><code>这里要注意一下，“Perserver log”选项要勾上，否则跳转可能会将登录请求给刷新掉，这样我们就看不到了。</code></pre>
<p>从Query String Parameters里面可以看到请求参数。这些请求参数有的看一眼基本可以确认传固定值，有的需要分析是怎么来的</p>
<pre><code>token:暂时还不清楚这个是干嘛的
remeberdays:记住密码的天数，这里使用固定值14即可
callback:jQuery18308307662333827466_1443247777543
_:1443247800524</code></pre>
<p>由于WEB知识基本小白，因此被callback和_这两个参数困扰了N久。看js代码也没找出来这两个参数是哪里来的。后来想想，这两个参数是不是标准的语法参数而与网站自身无关呢。跑到google上一查，果然。</p>
<pre><code>&quot;jsonp&quot;: 以 JSONP 的方式载入 JSON 数据块。会自动在所请求的URL最后添加&quot;?callback=?&quot;。默认情况下会通过在URL中附加查询字符串变量 ，_=[TIMESTAMP]， 禁用缓存结果，除非设置了cache参数为true。</code></pre>
<p>闹了半天，原来是个时间戳呀。后边验证发现callback的前半部分不重要，只要后面替换为当前时间即可。而“_”参数也是一个当前时间戳。</p>
<p>继续研究token参数。在上面的链接中并未出现用户名密码，那服务器是怎么知道哪个用户在做登录请求呢？在过滤器中输入用户名，发现有一个链接出现了用户名密码</p>
<p><img src="./2501509261411.PNG" /></p>
<p>查看这个链接的响应，发现了有个参数是ssotoken，这个响应参数的值恰好跟登录请求里面的token值一模一样！！Lucky~~</p>
<p>那么我们来看看这个链接的请求参数，其中callback参数和_参数我们有了上面的解析，很容易就可以得到</p>
<pre><code>callback:jQuery18307904950501397252_1443237280922
account:用户名
password:密码，看起来像是一个MD5加密的字段，验证一下，果然真是
_:1443238132704</code></pre>
<p>接着研究响应。在Preview中可以看到，当返回的code值为0时表示登录成功。此时，可以输几次错误的密码看看登录失败的code值。</p>
<h2 id="开始写代码">开始写代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">	self._cookie = cookielib.LWPCookieJar()</span><br><span class="line">	self._opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self._cookie))</span><br><span class="line">	self.INDEX_URL = <span class="string">&quot;http://bulo.hujiang.com/&quot;</span></span><br><span class="line">	self._callback = <span class="string">&quot;jQuery18307142652559559792_1442495521490&quot;</span></span><br><span class="line">	self.TOKEN_URL = <span class="string">&quot;http://pass.hujiang.com/quick/account/?callback=%s&amp;account=%s&amp;password=%s&amp;code=&amp;act=loginverify&amp;source=bulo_anon&amp;_=%s&quot;</span></span><br><span class="line">	self.LOGIN_URL = <span class="string">&quot;http://pass.hujiang.com/quick/synclogin.aspx?token=%s&amp;remeberdays=14&amp;callback=%s&amp;_=%s&quot;</span></span><br><span class="line">	<span class="comment">#下面是日志部分</span></span><br><span class="line">	self._logger = logging.getLogger(__name__)</span><br><span class="line">	self._logger.setLevel(logging.INFO)</span><br><span class="line">	self._handler = logging.FileHandler(os.path.join(sys.path[<span class="number">0</span>],<span class="string">&#x27;gargets_autoSignIn.log&#x27;</span>))</span><br><span class="line">	self._handler.setLevel(logging.INFO)</span><br><span class="line">	self._handler.setFormatter(logging.Formatter(<span class="string">&#x27;%(asctime)s - %(filename)s:%(lineno)d - %(levelname)s - %(message)s&#x27;</span>))</span><br><span class="line">	self._logger.addHandler(self._handler)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self,user=<span class="string">&quot;&quot;</span>,psw=<span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;user is: &quot;</span>, user</span><br><span class="line">	self._logger.info(<span class="string">&quot;user is: %s&quot;</span> % user)</span><br><span class="line">	self._getToken(user,psw)</span><br><span class="line">	hjHeaders = &#123;</span><br><span class="line">            <span class="string">&quot;Accept&quot;</span>:<span class="string">&quot;*/*&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Accept-Encoding&quot;</span>:<span class="string">&quot;gzip, deflate, sdch&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Accept-Language&quot;</span>:<span class="string">&quot;zh-CN,zh;q=0.8&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Host&quot;</span>:<span class="string">&quot;pass.hujiang.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Referer&quot;</span>:<span class="string">&quot;http://bulo.hujiang.com/anon/?source=nbulo&amp;returnurl=http%3a%2f%2fbulo.hujiang.com%2fhome%2f&quot;</span>,</span><br><span class="line">            <span class="string">&quot;User-Agent&quot;</span>:<span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.152 Safari/537.36&quot;</span>,</span><br><span class="line">         &#125;</span><br><span class="line">	req = urllib2.Request(self.LOGIN_URL%(self._token,self._callback,<span class="built_in">str</span>(<span class="built_in">int</span>(time.time()*<span class="number">1000</span>))), headers = hjHeaders)</span><br><span class="line">	resp = <span class="built_in">eval</span>(self._opener.<span class="built_in">open</span>(req).read().decode(<span class="string">&quot;utf-8&quot;</span>).replace(self._callback,<span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;;&quot;</span>,<span class="string">&quot;&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> resp[<span class="string">&quot;code&quot;</span>] == <span class="number">0</span>:</span><br><span class="line">		<span class="built_in">print</span> <span class="string">&quot;Login Success!&quot;</span></span><br><span class="line">		self._logger.info(<span class="string">&quot;Login Success!&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> self._opener</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="built_in">print</span> <span class="string">&quot;Wooooo, there must be something wrong~&quot;</span>, resp[<span class="string">&quot;code&quot;</span>].encode(<span class="string">&quot;utf-8&quot;</span>), resp[<span class="string">&quot;message&quot;</span>].encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">		self._logger.info(<span class="string">&quot;Wooooo, there must be something wrong~\n code = %s \n message = %s \n&quot;</span> % (resp[<span class="string">&quot;code&quot;</span>].encode(<span class="string">&quot;utf-8&quot;</span>), resp[<span class="string">&quot;message&quot;</span>].encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#MD5加密，用于加密密码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_md5</span>(<span class="params">self,pwd</span>):</span></span><br><span class="line">	m = hashlib.md5()</span><br><span class="line">	m.update(pwd)</span><br><span class="line">	<span class="keyword">return</span> m.hexdigest()</span><br><span class="line"><span class="comment">#获取登录请求中的token值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_getToken</span>(<span class="params">self,user,psw</span>):</span></span><br><span class="line">	hjHeaders = &#123;</span><br><span class="line">            <span class="string">&quot;Accept&quot;</span>:<span class="string">&quot;*/*&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Accept-Encoding&quot;</span>:<span class="string">&quot;gzip, deflate, sdch&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Accept-Language&quot;</span>:<span class="string">&quot;zh-CN,zh;q=0.8&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Host&quot;</span>:<span class="string">&quot;pass.hujiang.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Referer&quot;</span>:<span class="string">&quot;http://bulo.hujiang.com/anon/?source=nbulo&amp;returnurl=http%3a%2f%2fbulo.hujiang.com%2fhome%2f&quot;</span>,</span><br><span class="line">            <span class="string">&quot;User-Agent&quot;</span>:<span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.152 Safari/537.36&quot;</span>,</span><br><span class="line">         &#125;</span><br><span class="line">	req = urllib2.Request(self.TOKEN_URL%(self._callback,user,self._md5(psw),<span class="built_in">str</span>(<span class="built_in">int</span>(time.time()*<span class="number">1000</span>))), headers = hjHeaders)</span><br><span class="line">	true, false, null = <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;false&#x27;</span>, <span class="string">&#x27;&#x27;</span></span><br><span class="line">	resp = <span class="built_in">eval</span>(self._opener.<span class="built_in">open</span>(req).read().replace(self._callback,<span class="string">&quot;&quot;</span>))</span><br><span class="line">	<span class="comment">#print resp</span></span><br><span class="line">	<span class="keyword">if</span> resp[<span class="string">&quot;code&quot;</span>] == <span class="number">0</span>:</span><br><span class="line">		<span class="built_in">print</span> <span class="string">&quot;Get Token succeed~~&quot;</span></span><br><span class="line">		self._logger.info(<span class="string">&quot;Get Token succeed~~&quot;</span>)</span><br><span class="line">		self._token = resp[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;ssotoken&quot;</span>]</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="built_in">print</span> <span class="string">&quot;Wooooo, there must be something wrong~&quot;</span>, resp[code], resp[message]</span><br><span class="line">		self._logger.info(<span class="string">&quot;Wooooo, there must be something wrong~\n code = %s \n message = %s \n&quot;</span> % (resp[<span class="string">&quot;code&quot;</span>].encode(<span class="string">&quot;utf-8&quot;</span>), resp[<span class="string">&quot;message&quot;</span>].encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br></pre></td></tr></table></figure>
<h1 id="打卡">打卡</h1>
<h2 id="准备工作-1">准备工作</h2>
<p>紧跟登录的思路。打卡也是客户端给服务器发请求。继续chrome, F12.点击打卡后，我们可以发现我们签到的时候发送了一个GET请求http://bulo.hujiang.com/app/api/ajax_take_card.ashx?0.5263887415640056。其中，0.5263887415640056这个值不重要，因此可以随便生成一个满足位数要求的随机数即可。</p>
<p>退出登录在发送一次上面的打卡请求，发现返回了["-1",""]。再次登录后再发送一次打卡请求，发现返回了["","406"]。总结得出，第一次打卡的时候列表的第一项是有值，且值为正。以打卡则此项值为空。</p>
<h2 id="开始写代码-1">开始写代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#签到</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signIn</span>(<span class="params">self</span>):</span></span><br><span class="line">	signHeaders = &#123;</span><br><span class="line">			<span class="string">&quot;Accept&quot;</span>:<span class="string">&quot;application/json, text/javascript, */*; q=0.01&quot;</span>,</span><br><span class="line">			<span class="string">&quot;Accept-Encoding&quot;</span>:<span class="string">&quot;gzip, deflate, sdch&quot;</span>,</span><br><span class="line">			<span class="string">&quot;Accept-Language&quot;</span>:<span class="string">&quot;zh-CN,zh;q=0.8&quot;</span>,</span><br><span class="line">            <span class="string">&quot;User-Agent&quot;</span>:<span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36 LBBROWSER&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Host&quot;</span>:<span class="string">&quot;bulo.hujiang.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Referer&quot;</span>:<span class="string">&quot;http://bulo.hujiang.com/home/&quot;</span>,</span><br><span class="line">          &#125;</span><br><span class="line">	SIGN_URL = <span class="string">&quot;http://bulo.hujiang.com/app/api/ajax_take_card.ashx?%.17f&quot;</span></span><br><span class="line">	req = urllib2.Request(SIGN_URL%random.random(), headers = signHeaders)</span><br><span class="line">	resp = self._opener.<span class="built_in">open</span>(req).read()</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">int</span>(resp[<span class="number">0</span>]) &gt; <span class="number">0</span>:</span><br><span class="line">			<span class="built_in">print</span> <span class="string">&quot;打卡成功，获得%s沪元，共打卡%s天~~&quot;</span> % (resp[<span class="number">0</span>],resp[<span class="number">1</span>])</span><br><span class="line">			self._logger.info(<span class="string">u&quot;打卡成功，获得%s沪元，共打卡%s天~~&quot;</span> % (resp[<span class="number">0</span>],resp[<span class="number">1</span>]))</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">int</span>(resp[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">			<span class="built_in">print</span> <span class="string">&quot;已经打过卡了喔~~&quot;</span></span><br><span class="line">			self._logger.info(<span class="string">u&quot;已经打过卡了喔~~&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">int</span>(resp[<span class="number">0</span>]) == -<span class="number">1</span>:</span><br><span class="line">			<span class="built_in">print</span> <span class="string">&quot;用户未激活&quot;</span></span><br><span class="line">			self._logger.info(<span class="string">u&quot;用户未激活&quot;</span>)</span><br><span class="line">	<span class="keyword">except</span> Exception, e:</span><br><span class="line">		<span class="built_in">print</span> resp</span><br><span class="line">		self._logger.info(<span class="string">u&quot;未知错误！\n %s&quot;</span> % resp)</span><br></pre></td></tr></table></figure>
<h1 id="碎碎念">碎碎念</h1>
<p>完整代码在<a href="https://github.com/ictar/XIXI/blob/master/Source/gargets/autoSignIn.py">autoSignIn</a></p>
<p>其实研究自动登录自动打卡的模式大概是这样的 1. 研究客户端与服务端的交互。有时候没法直接看出链接或者请求参数是怎么来的，这个时候可以借助fiddler或者浏览器自带的调试工具。参数的话，实在没辙的情况下可以研究对应的js代码。一般对应于登录按钮的click事件。 2. 代码中尽可能的模仿真实用户的行为，欺骗服务器。</p>
<p>另外，前端知识很重要</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="http://talk.acgtea.com/play-with-python-baidu-tieba-auto-sign-side-a/">玩耍Python — 百度贴吧自动签到（上）</a></li>
<li><a href="http://www.css88.com/jqapi-1.9/jQuery.ajax/">jQuery.ajax()</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>香蕉派</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>pythonchallenge.com | Python Challenge 第1关 题解</title>
    <url>/2014/04/06/%5Bpythonchallenge.com%5DPython%20Challenge%20%E7%AC%AC1%E5%85%B3%20%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>再接再厉，继续玩吧~</p>
<h1 id="内容">内容</h1>
<p>这次的题目是： <img src="/img/1396797202074.png" /></p>
<h1 id="题解">题解</h1>
<p>好吧，我承认，小小的做了下弊……</p>
<p>anyway, 就是对下面一串长长的字符串移位操作。</p>
<p>你问我怎么移？图告诉我们了呀~k变成m，移了2位；o变成q，移了2位；e变成g，也是移了2位。</p>
<p>ok，我们来写点代码吧~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;&quot;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&#x27;q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">res = <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> ch.islower():</span><br><span class="line">        res = res + <span class="built_in">str</span>(<span class="built_in">chr</span>(<span class="number">97</span>+(<span class="built_in">ord</span>(ch)+<span class="number">2</span>-<span class="number">97</span>)%<span class="number">26</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res = res + ch</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> res</span><br></pre></td></tr></table></figure>
<p>得到res的结果是：<code>i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that's why this text is so long. using string.maketrans() is recommended. now apply on the url</code>.</p>
<p>猜测是要将当前网页的名字，也就是map做移位操作。<code>map &gt;&gt;2</code> 就变成了ocr……</p>
<p>Ok, 开始第二关吧~</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pythonchallenge</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB初识之基本概念及安装使用</title>
    <url>/2015/11/10/MongoDB%E5%88%9D%E8%AF%86%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="一些概念">一些概念</h1>
<ul>
<li>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限</li>
<li>每一个文档都有一个特殊的键"_id"，它在文档所处的集合中是唯一的</li>
</ul>
<h2 id="文档">文档</h2>
<p>文档是MongoDB中数据的基本单元，类似于关系数据库中的行。多个键及其关联的值有序地放置在一起便是文档。 例如：{"greeting": "hello, ele~", "foo":3} 1. 文档中的键/值对是有序的。 2. 文档不但区分类型，也区分大小写 3. 文档不能有重复的键</p>
<h2 id="集合">集合</h2>
<p>集合就是一组文档，可以被看做没有模式的表 1. 集合是无模式的，因此一个集合里面的文档可以使各种各样的。 2. 可以用名字来标识集合 * 组织集合的一种惯例是使用“.”字符分开的按命名空间划分的子集合</p>
<h2 id="数据类型">数据类型</h2>
<ul>
<li>null</li>
<li>布尔(true/false)</li>
<li>32位整数、64位整数、64位浮点数</li>
<li>字符串、符号</li>
<li>对象id: {"x": ObjectId()}
<ol type="1">
<li>"_id"的默认类型</li>
<li>使用12字节的存储空间。前4个字节是从标准纪元开始的时间戳，接下来的3字节是所在主机的唯一标识符，接下来的2字节来自产生ObjectId的进程标识符。这9个字节保证了同一秒钟不同机器不同进程产生的ObjectId是唯一的。最后3个字节是一个自动增加的计数器，确保相同进程同一秒产生的ObjectId也是不一样的。</li>
</ol></li>
<li>日期: {"x": new Date()}</li>
<li>正则表达式</li>
<li>代码</li>
<li>二进制数据</li>
<li>最大值、最小值</li>
<li>未定义：{"x": undefined}</li>
<li>数组: {"x": ["a", "b", "c"]}</li>
<li>内嵌文档：{"x": {"foo": "bar"}}</li>
</ul>
<h1 id="安装与启动">安装与启动</h1>
<h2 id="安装windows">安装（Windows）</h2>
<p>step 1 <a href="https://www.mongodb.org/downloads#production">MongoDB官网</a>上直接选择对应的版本即可。 step 2 下载后解压</p>
<h2 id="启动windows">启动（Windows）</h2>
<p>step 1 新建目录：<code>E:\data\db</code> 这里，由于我的MongoDB是解压在E盘的，所以在E盘创建此目录。</p>
<pre><code>* 注意，若此目录不存在或者不可写，会导致启动失败。</code></pre>
<p>step 2 进入MongoDB解压路径后， CMD窗口执行：<code>.\bin&gt;mongod.exe</code></p>
<h2 id="运行mongodb-shell">运行MongoDB shell</h2>
<p><code>.\bin&gt;mongo</code> * 由于shell会在启动时自动连接MongoDB服务器，因此在使用shell之前需确保mongod已正常启动。 * 启动后，shell会连到MongoDB服务器的test数据库，并将这个数据库连接赋值给全局变量db * 选择使用的数据库 <figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">&gt; db</span><br><span class="line">test</span><br><span class="line">&gt; use foobar</span><br><span class="line">switched to db foobar</span><br><span class="line">&gt; db</span><br><span class="line">foobar</span><br></pre></td></tr></table></figure> ## shell中的基本操作 1. 创建 <figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"># 创建一个局部变量<span class="keyword">post</span></span><br><span class="line">&gt; <span class="keyword">post</span> = &#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;My Blog&quot;</span>,</span><br><span class="line">... <span class="string">&quot;content&quot;</span>:<span class="string">&quot;Here is my blog post.&quot;</span>,</span><br><span class="line">... <span class="string">&quot;date&quot;</span>:new <span class="built_in">Date</span>()&#125;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span> : <span class="string">&quot;My Blog&quot;</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span> : <span class="string">&quot;Here is my blog post.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;date&quot;</span> : ISODate(<span class="string">&quot;2015-11-10T12:32:12.975Z&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"># 将<span class="keyword">post</span>保存到blog集合中</span><br><span class="line">&gt; <span class="keyword">db</span>.blog.insert(<span class="keyword">post</span>)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : 1 &#125;)</span><br></pre></td></tr></table></figure> 2. 读取 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"># 调用集合的find方法查看所有文档</span><br><span class="line">&gt; db.blog.find<span class="literal">()</span></span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="constructor">ObjectId(<span class="string">&quot;5641e3d7245065418bab4329&quot;</span>)</span>, <span class="string">&quot;title&quot;</span> : <span class="string">&quot;My Blog&quot;</span>, <span class="string">&quot;content&quot;</span> : <span class="string">&quot;Here is my blog post.&quot;</span>, <span class="string">&quot;date&quot;</span> : <span class="constructor">ISODate(<span class="string">&quot;2015-11-10T12:32:12.975Z&quot;</span>)</span> &#125;</span><br><span class="line"># 查看集合中的一个文档</span><br><span class="line">&gt; db.blog.find<span class="constructor">One()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : <span class="constructor">ObjectId(<span class="string">&quot;5641e3d7245065418bab4329&quot;</span>)</span>,</span><br><span class="line">        <span class="string">&quot;title&quot;</span> : <span class="string">&quot;My Blog&quot;</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span> : <span class="string">&quot;Here is my blog post.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;date&quot;</span> : <span class="constructor">ISODate(<span class="string">&quot;2015-11-10T12:32:12.975Z&quot;</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 3. 更新 <figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">post</span>.comments = []</span><br><span class="line">[ ]</span><br><span class="line"># updaet接受至少两个参数：第一个是要更新文档的限定条件，第二个是新的文档</span><br><span class="line">&gt; <span class="keyword">db</span>.blog.<span class="keyword">update</span>(&#123;title:<span class="string">&quot;My Blog&quot;</span>&#125;, <span class="keyword">post</span>)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : 1, <span class="string">&quot;nUpserted&quot;</span> : 0, <span class="string">&quot;nModified&quot;</span> : 1 &#125;)</span><br><span class="line">&gt; <span class="keyword">db</span>.blog.find()</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5641e3d7245065418bab4329&quot;</span>), <span class="string">&quot;title&quot;</span> : <span class="string">&quot;My Blog&quot;</span>, <span class="string">&quot;content&quot;</span> : <span class="string">&quot;Here is my blog post.&quot;</span>, <span class="string">&quot;date&quot;</span> : ISODate(<span class="string">&quot;2015-11-10T12:32:12.975Z&quot;</span>), <span class="string">&quot;comments&quot;</span> : [ ] &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure> 4. 删除 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># remove用来永久性删除文档</span></span><br><span class="line"><span class="comment"># 如果参数是一个空的字典，会删除一个集合内的所有文档</span></span><br><span class="line"><span class="comment"># remove也可以接受一个文档以指定限定条件</span></span><br><span class="line">&gt; db.blog.<span class="builtin-name">remove</span>(&#123;title:<span class="string">&quot;My Blog&quot;</span>&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nRemoved&quot;</span> : 1 &#125;)</span><br><span class="line">&gt; db.blog.<span class="builtin-name">find</span>()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure> 5. 其他 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看shell的帮助</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">help</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看数据库级别的命令的帮助</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.help()</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集合相关的帮助</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.foo.help()</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 了解函数功能</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.foo.update</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当有属性与目标集合同名时，可以使用getCollection函数</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.getCollection(<span class="string">&quot;version&quot;</span>)</span></span><br><span class="line">foobar.version</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Go, go|小白的go小抄：数据和初始化</title>
    <url>/2017/08/04/Go-go-%E5%B0%8F%E7%99%BD%E7%9A%84go%E5%B0%8F%E6%8A%84%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h3 id="数据">数据</h3>
<h4 id="用newt进行分配">用<code>new(T)</code>进行分配</h4>
<p><code>new</code>是一个内置函数，用来为变量分配内存。但和其他语言中的<code>new</code>不一样，该方法并不会初始化所分配的内存，而只是清空它。也就是说，<code>new(T)</code>为一个类型为T的项分配已清零的内存，然后返回该内存地址（一个类型为<code>*T</code>的值）。用Go的话来讲，它会返回一个指向一个新分配的类型为T的零值的指针。</p>
<p>利用<code>new</code>返回的内存使用类型零值的特点，自定义的数据结构在调用<code>new</code>之后，其字段就可以直接使用而不需要进一步的初始化了。例如对于下面的类型声明： <figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> SyncedBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock sync.Mutext</span><br><span class="line">    buffer bytes.Buffer</span><br><span class="line">&#125;</span><br><span class="line">p := <span class="keyword">new</span>(SyncedBuffer) <span class="comment">// *SyncedBuffer类型</span></span><br><span class="line">var v SyncedBuffer <span class="comment">// SyncedBuffer类型</span></span><br></pre></td></tr></table></figure> 一旦分配或者仅仅声明，类型<code>SyncedBuffer</code>的值就已经可以被使用了。在上面的代码中，<code>p</code>和<code>v</code>都可以直接被使用。</p>
<h4 id="构造函数和复合字面量">构造函数和复合字面量</h4>
<p>有时候，零值并不能满足我们的需求，此时，就需要一个初始化构造函数了。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPersion</span><span class="params">(name String, age <span class="keyword">int</span>)</span> *<span class="title">Persion</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> age &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    p := <span class="built_in">new</span>(Persion)</span><br><span class="line">    p.name = name</span><br><span class="line">    p.age = age</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这里，我们可以使用复合字面量（每次计算的时候创建一个新的实例的表达式）来简化它： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPersion</span><span class="params">(name String, age <span class="keyword">int</span>)</span> *<span class="title">Persion</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> age &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不指定字段名，那么复合字面量中，字段的值的顺序都要按照所定义类型中字段的顺序，并且每个字段都要有</span></span><br><span class="line">    <span class="comment">// 使用下面这种键值对的形式，顺序任意，缺失的值会使用其零值。</span></span><br><span class="line">    <span class="keyword">return</span> &amp;Persion&#123;name: name, age: age&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 注意：不像C，返回一个本地变量的地址是完全没问题的。在函数返回之后，为该变量所分配的存储仍然存活。</p>
<p>复合字面量也适用于数组、切片和map，此时，视情况而定，字段标签是切片或者map键。例如： <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">	Enone = <span class="number">1</span></span><br><span class="line">	Eio   = <span class="number">3</span></span><br><span class="line">	Einval = <span class="number">5</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">a</span> := [...]<span class="built_in">string</span>   &#123;Enone: <span class="string">&quot;no error&quot;</span>, Eio: <span class="string">&quot;Eio&quot;</span>, Einva<span class="variable">l:</span> <span class="string">&quot;invalid argument&quot;</span>&#125;</span><br><span class="line">// 此时，<span class="keyword">a</span>的大小为<span class="number">6</span>，值为[<span class="string">&quot;&quot;</span>, <span class="keyword">no</span> error<span class="string">&quot;, &quot;</span><span class="string">&quot;, &quot;</span>Eio<span class="string">&quot;, &quot;</span><span class="string">&quot;, &quot;</span>invalid <span class="keyword">argument</span><span class="comment">&quot;]</span></span><br><span class="line">s := []<span class="built_in">string</span>      &#123;Enone: <span class="string">&quot;no error&quot;</span>, Eio: <span class="string">&quot;Eio&quot;</span>, Einva<span class="variable">l:</span> <span class="string">&quot;invalid argument&quot;</span>&#125;</span><br><span class="line">// 此时，s的大小为<span class="number">6</span>，值为[<span class="string">&quot;&quot;</span>, <span class="keyword">no</span> error<span class="string">&quot;, &quot;</span><span class="string">&quot;, &quot;</span>Eio<span class="string">&quot;, &quot;</span><span class="string">&quot;, &quot;</span>invalid <span class="keyword">argument</span><span class="comment">&quot;]</span></span><br><span class="line"><span class="keyword">m</span> := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="built_in">string</span>&#123;Enone: <span class="string">&quot;no error&quot;</span>, Eio: <span class="string">&quot;Eio&quot;</span>, Einva<span class="variable">l:</span> <span class="string">&quot;invalid argument&quot;</span>&#125;</span><br><span class="line">// 此时，<span class="keyword">m</span>的大小为<span class="number">6</span>，值为&#123;<span class="number">5</span>:<span class="string">&quot;invalid argument&quot;</span>, <span class="number">1</span>:<span class="string">&quot;no error&quot;</span>, <span class="number">3</span>:<span class="string">&quot;Eio&quot;</span>&#125;</span><br></pre></td></tr></table></figure> &gt; 此时，要求标签值是唯一的。</p>
<h4 id="用maket-args进行分配">用<code>make(T, args)</code>进行分配</h4>
<p>与<code>new</code>不同，内置函数<code>make</code>只创建切片、map和channel，返回一个类型为T（不是*T）的已初始化（非零值）的值。之所以有这样的差别是因为，这三种类型，内部指向在使用前必须被初始化的数据结构。以切片为例，一个切片是一个包含三个项（一个指向数据数组内部数据的指针、长度、容量）的描述器，在这三个项被初始化之前，切片都为<code>nil</code>。对于切片、map和channel，<code>make</code>初始化内部数据结构，准备要使用的值。例如： <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">make</span><span class="params">([]int, <span class="number">10</span>, <span class="number">100</span>)</span></span></span><br><span class="line"><span class="comment">// 分配一个包含100个int的数组，</span></span><br><span class="line"><span class="comment">// 然后创建一个长度为10，容量为100，指向该数组头10个元素的切片结构</span></span><br><span class="line"><span class="comment">// 作为对比</span></span><br><span class="line"><span class="function"><span class="title">new</span><span class="params">([]int)</span></span></span><br><span class="line"><span class="comment">// 返回一个指向新分配的清零切片结构的指针，即，指向一个nil切片值的指针</span></span><br></pre></td></tr></table></figure> 重要的事情说三遍： 1. <code>make</code>只对map、切片和channel有用，并且不返回指针！ 2. <code>make</code>只对map、切片和channel有用，并且不返回指针！ 3. <code>make</code>只对map、切片和channel有用，并且不返回指针！</p>
<blockquote>
<p>如果实在需要指针，那么使用<code>new</code>或者直接取值<code>&amp;p</code></p>
</blockquote>
<h4 id="数组">数组</h4>
<p>与C不同，在Go中： * 数组是值，将一个数组赋给另一个会拷贝所有的元素 * 特别是，如果你把一个数组传递给一个函数，该函数会收到该数组的一个拷贝，而不是指向这个数组的指针 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">ChangeArray</span><span class="params">(a [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   	a[<span class="number">1</span>] *= <span class="number">10</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(a) <span class="comment">// [1 2 3]</span></span><br><span class="line">ChangeArray(a)</span><br><span class="line">fmt.Println(a) <span class="comment">// [1 2 3]</span></span><br></pre></td></tr></table></figure> * 一个数组的大小是其类型的一部分。类型<code>[10]int</code>和<code>[20]int</code>是不同的。</p>
<h4 id="切片">切片</h4>
<p>切片保存到底层数组的引用： * 如果将一个切片赋值给另一个，那么，这两个切片都会指向同一个数组。 * 如果将一个切片传递给一个函数，那么在函数内对此切片所做的修改对函数的调用者来说是可见的。这类似于传递一个指向底层数组的指针 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">ChangeArray</span><span class="params">(a []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   	a[<span class="number">1</span>] *= <span class="number">10</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(a) <span class="comment">// [1 2 3]</span></span><br><span class="line">ChangeArray(a[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">fmt.Println(a) <span class="comment">// [1 20 3]</span></span><br></pre></td></tr></table></figure> * 一个切片的长度可以被改变，只要其长度不超过底层数组的限制。 * 一个切片的容量，可以通过内置函数<code>cap</code>获得，代表该切片的最大长度。当给切片附加数据的时候，如果数据超过容量，那么会重新分配切片，并返回结果切片。 * 对于<code>nil</code>切片，<code>len</code>和<code>cap</code>函数是合法的，会返回0</p>
<h4 id="二维切片二维数组">二维切片/二维数组</h4>
<p>Go的数组和切片都是一维的，如果需要创建二维数组/二维切片，可以如下定义： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Transform [<span class="number">3</span>][<span class="number">3</span>]<span class="keyword">float64</span> <span class="comment">// 一个3x3数组，即，一个元素为数组的数组</span></span><br><span class="line"><span class="keyword">type</span> LinesOfText [][]<span class="keyword">byte</span> <span class="comment">// 一个元素为byte切片的切片</span></span><br><span class="line">text := LinesOfTeXT &#123;</span><br><span class="line">    []<span class="keyword">byte</span>(<span class="string">&quot;Now is the time&quot;</span>),</span><br><span class="line">    []<span class="keyword">byte</span>(<span class="string">&quot;for all good gophers&quot;</span>),</span><br><span class="line">    []<span class="keyword">byte</span>(<span class="string">&quot;to bring some fun to the party&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于切片长度可变，因此，对于二维切片而言，每个元素的长度都是可变的。</span></span><br></pre></td></tr></table></figure> 有时候，需要为一个二维切片分配空间。有两种方式可实现这点： 1. 为二维切片中的每个切片元素独立分配空间 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配顶层的切片</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, YSize)</span><br><span class="line"><span class="comment">// 遍历每一行，为每一行分配切片空间</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">    picture[i] = <span class="built_in">make</span>([]<span class="keyword">uint8</span>, XSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 2. 分配单个数组，然后将各个切片指向它 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配顶层的切片</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, YSize)</span><br><span class="line"><span class="comment">// 分配一个大大的切片来保存所有的像素</span></span><br><span class="line">pixels := <span class="built_in">make</span>([]<span class="keyword">uint8</span>, XSize*YSize)</span><br><span class="line"><span class="comment">// 遍历每一行，从剩余的pixels切片的前面给每一行分配切片空间</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture&#123;</span><br><span class="line">    picture[i], pixels = pixels[:XSize], pixels[XSize:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 使用哪一种取决于你的应用。如果切片元素会增长或者收缩，那么应该选择第一种，避免覆盖其他元素。否则，选择第二种会更有效率些。</p>
<h4 id="map">Map</h4>
<p>map的键可以是任意定义了相等算子的类型，例如整型、浮点数、复数、字符串、指针、接口（只要该动态类型支持相等）、结构和数组。而切片则不能作为键。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明以及初始化</span></span><br><span class="line"><span class="keyword">var</span> timeZone = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> &#123;</span><br><span class="line">	<span class="string">&quot;UTC&quot;</span>: <span class="number">0</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">&quot;EST&quot;</span>: <span class="number">-5</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">&quot;CST&quot;</span>: <span class="number">-6</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">&quot;MST&quot;</span>: <span class="number">-7</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">&quot;PST&quot;</span>: <span class="number">-8</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">offset1 := timeZone[<span class="string">&quot;EST&quot;</span>]</span><br><span class="line">offset2, ok := timeZone[<span class="string">&quot;DST&quot;</span>]</span><br><span class="line"><span class="comment">// 可以使用ok来判断某个键是否存在于map中。</span></span><br><span class="line"><span class="comment">// 尝试获取一个键不存在的值将会返回map中值的类型的零值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除map中的某一项。即使某个项不存在，也不会发生异常。</span></span><br><span class="line"><span class="built_in">delete</span>(timeZone, <span class="string">&quot;PDT&quot;</span>)</span><br></pre></td></tr></table></figure> map也保存指向底层数据结构的引用。如果将一个map传递给一个函数，在函数体内对该map做的改动是可以被函数调用者感知到的。</p>
<p>另外，可以利用一个值类型为<code>bool</code>的map来实现集合。</p>
<h4 id="打印">打印</h4>
<p><code>fmt</code>包的Print家族有三类成员： * <code>Printf</code> / <code>Fprintf</code> / <code>Sprintf</code>：类似C，接受一个格式化字符串作为第一个参数。 * <code>Println</code> / <code>Fprintln</code> / <code>Sprintln</code>：无需使用格式化字符串，而是会为其每个参数生成一个默认的格式。另外，还会在每个参数之间插入一个空格，然后在输出后附加一个新行。 * <code>Print</code> / <code>Fprint</code> / <code>Sprint</code>：和<code>Println</code>版本一样，无需使用格式化字符串。这种版本只会在参数两边都没有字符串的情况下插入空格。 &gt; <code>Fprint</code>系列的函数的第一个参数为任何实现了<code>io.Writer</code>接口的对象，例如<code>os.Stout</code>和<code>os.Stderr</code></p>
<p>好了，下面来点跟C不同的东西： * 例如<code>%d</code>这样的数值格式符不会使用用于符号或者大小的标志。使用参数类型来决定符号或者大小这些属性。 <figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="symbol">x</span> uint64 = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %x; %d %x\n&quot;</span>, <span class="symbol">x</span>, <span class="symbol">x</span>, <span class="built_in">int64</span>(<span class="symbol">x</span>), <span class="built_in">int64</span>(<span class="symbol">x</span>))</span><br><span class="line"><span class="comment">// 输出：18446744073709551615 ffffffffffffffff; -1 -1</span></span><br></pre></td></tr></table></figure> * 如果你只是想要默认转换，那你可以使用万能的格式符<code>%v</code>（表示“value”，可以打印任何值，甚至是数组、切片、结构和map） * 当打印一个结构的时候，<code>%+v</code>会用结构的字段名来注释结构的每个字段。而对于任意值，<code>%#v</code>以完整的Go语法打印其值 <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> T struct &#123;</span><br><span class="line">	<span class="keyword">a</span> <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">b</span> float64</span><br><span class="line">	<span class="keyword">c</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line">t := &amp;T&#123;<span class="number">7</span>, -<span class="number">2.35</span>, <span class="string">&quot;abc\tdef&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, t)</span><br><span class="line">// &amp;&#123;<span class="number">7</span> -<span class="number">2.35</span> <span class="keyword">abc</span>	def&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, t)</span><br><span class="line">// &amp;&#123;<span class="variable">a:7</span> <span class="variable">b:</span>-<span class="number">2.35</span> <span class="keyword">c</span>:<span class="keyword">abc</span>	def&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, t)</span><br><span class="line">// &amp;main.T&#123;<span class="variable">a:7</span>, <span class="variable">b:</span>-<span class="number">2.35</span>, <span class="keyword">c</span>:<span class="string">&quot;abc\tdef&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, timeZone)</span><br><span class="line">// <span class="keyword">map</span>[<span class="built_in">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;PST&quot;</span>:-<span class="number">28800</span>, <span class="string">&quot;UTC&quot;</span>:<span class="number">0</span>, <span class="string">&quot;EST&quot;</span>:-<span class="number">18000</span>, <span class="string">&quot;CST&quot;</span>:-<span class="number">21600</span>, <span class="string">&quot;MST&quot;</span>:-<span class="number">25200</span>&#125;</span><br></pre></td></tr></table></figure> * 带引号的字符串格式也可以通过对类型为<code>string</code>或者<code>[]byte</code>的值使用<code>%q</code>获得。<code>%#q</code>则在有可能的情况下使用反引号。（<code>%q</code>格式也可以应用到整形和<code>rune</code>，生成一个单引号<code>rune</code>常量）。另外，<code>%x</code>也对字符串、byte数组、byte切片以及整形有效，生成一个长长地十六进制字符串。而<code>% x</code>则会在字节之间放置空格。 <figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%q, %#q; %q, %#q\n&quot;</span>, <span class="string">&quot;ele&quot;</span>, <span class="string">&quot;ele&quot;</span>, <span class="number">123</span>, <span class="number">123</span>)</span><br><span class="line">// <span class="string">&quot;ele&quot;</span>, <span class="string">`ele`</span>; <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x, % x; %x, % x\n&quot;</span>, <span class="string">&quot;ele&quot;</span>, <span class="string">&quot;ele&quot;</span>, <span class="number">123</span>, <span class="number">123</span>)</span><br><span class="line">// <span class="number">656</span>c65, <span class="number">65</span> <span class="number">6</span>c <span class="number">65</span>; <span class="number">7</span>b,  <span class="number">7</span>b</span><br></pre></td></tr></table></figure> * <code>%T</code>：打印一个值的类型 <figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, timeZone)</span><br><span class="line">// <span class="keyword">map</span>[string]<span class="keyword">int</span></span><br></pre></td></tr></table></figure> * 如果想控制一个自定义类型的默认格式，那么只需要给此类型定义一个带有<code>String() string</code>函数签名的方法。例如： <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">func (t *T) <span class="keyword">String</span>() <span class="keyword">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d/%g/%q&quot;</span>, t.a, t.b, t.c)</span><br><span class="line">    /* 这里可以调用Sprintf是因为print程序是完全重入的，可以这样封装。但是，关于此方法有一个要理解的重要细节：构造<span class="keyword">String</span>时，千万不要让Sprintf方法再次调用你的<span class="keyword">String</span>。这样会让你的<span class="keyword">String</span>方法陷入无限递归。就像这样：</span><br><span class="line"></span><br><span class="line">    type MyString <span class="keyword">string</span></span><br><span class="line">    func (m MyString) <span class="keyword">String</span>() <span class="keyword">string</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;MyString=%s&quot;</span>, m)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	上面的无限递归很容易更正：将参数转换成一个基本的<span class="keyword">string</span>类型</span><br><span class="line"></span><br><span class="line">	func (m MyString) <span class="keyword">String</span>() <span class="keyword">string</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;MyString=%s&quot;</span>, <span class="keyword">string</span>(m))</span><br><span class="line">	&#125;</span><br><span class="line">    *／</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, t)</span><br><span class="line">// <span class="number">7</span>/-<span class="number">2.35</span>/<span class="string">&quot;abc\tdef&quot;</span></span><br></pre></td></tr></table></figure> &gt; 如果你需要打印<code>T</code>的值以及指向它的指针，那么<code>String()</code>的接受者就必须是值类型（例如，使用<code>func (t T) String() string</code>）。上面这个例子用了指针是因为，对于结构类型，这样更有效更理想。</p>
<pre><code>&gt; 另外，`Sprintf`只会在它需要一个字符串的时候才会调用`String`方法。</code></pre>
<ul>
<li>另一个打印技术是，直接将一个print程序的参数传递给另一个这样的程序。<code>Printf</code>的签名使用类型<code>...interface&#123;&#125;</code>作为其最后一个参数，来指定在格式后面可以出现任意数量（任意类型）的参数： <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> <span class="keyword">func</span> Printf(format string, v ...interface&#123;&#125;)(n int, err error)</span><br><span class="line"><span class="regexp">//</span> 其中，v就像一个类型为[]interface&#123;&#125;的变量，但是，如果它被传递给另外一个可变参数函数时，它就像一个普通的参数列表。</span><br><span class="line"><span class="keyword">func</span> Println(v ...interface&#123;&#125;) &#123;</span><br><span class="line">    std.Output(<span class="number">2</span>, fmt.Sprintln(v...))  </span><br><span class="line">    <span class="regexp">//</span> Output接受参数 (int, string)</span><br><span class="line">    <span class="regexp">//</span> 我们在v后面写上...是为了告诉编译器将v当成一个参数列表，否则，会将v作为单个切片变量进行传递</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 一个<code>...</code>参数可以是一个指定的类型，例如，<code>...int</code></li>
</ul>
<h4 id="func-appendslice-t-elements-...t-t"><code>func append(slice []T, elements ...T) []T</code></h4>
<p>现在，该是说说内置函数<code>append</code>的时候了。在其函数定义中，T是用于任意给定类型的占位符。在Go中，你实际上是无法编写一个类型T由调用者决定的函数的，这就是为什么<code>append</code>是内置函数：它需要来自编译器的支持。</p>
<p><code>append</code>函数会将元素<code>elements</code>附加到切片尾部，然后返回结果。需要返回结果是因为，底层的数组可能会发生改变。 <figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x</span> := []int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="symbol">x</span> = append(<span class="symbol">x</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">fmt.Println(<span class="symbol">x</span>)</span><br><span class="line"><span class="comment">// 输出：[1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure> 如果我们想要将一个切片附加到另一个切片后，可以在调用的时候使用... <figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x</span> := []int&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="symbol">y</span> := []int&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="symbol">x</span> = append(<span class="symbol">x</span>, <span class="symbol">y</span>...)</span><br><span class="line">fmt.Println(<span class="symbol">x</span>)</span><br><span class="line"><span class="comment">// 输出：[1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure> &gt; 在上面的例子中，如果我们不使用<code>...</code>的话，会发生编译错误，因为类型不对。</p>
<h3 id="初始化">初始化</h3>
<h4 id="常量">常量</h4>
<p>在编译期间创建（即使它们是定义在函数中的局部常量），只可以是数值、字符（rune），字符串或者布尔类型。由于编译时限制，定义敞亮的表达式也必须时常量表达式，可以由编译器计算得出。例如，<code>1 &lt;&lt; 3</code>是常量表达式，而<code>math.Sin(math.Pi/4)</code>不是，因为对<code>math.Sin</code>的函数调用是需要在运行时才发生的。</p>
<p>在Go中，枚举常量是通过<code>iota</code>枚举符来创建的。由于<code>iota</code>可以是表达式的一部分，而表达式是可以被隐式重复的，因此，很容易构造值的复杂集： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteSize <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _           = <span class="literal">iota</span> <span class="comment">// 通过赋给一个空白标识符来忽略第一个值</span></span><br><span class="line">    KB ByteSize = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">// 这里，iota得到的值是1</span></span><br><span class="line">    MB <span class="comment">// 这里，iota得到的值是2，也就是说，MB的值是通过1 &lt;&lt; (10 * iota) = 1 &lt;&lt; (10 * 2)计算得到的。下面以此类推。</span></span><br><span class="line">    GB</span><br><span class="line">    TB</span><br><span class="line">    PB</span><br><span class="line">    EB</span><br><span class="line">    ZB</span><br><span class="line">    YB</span><br><span class="line">)</span><br></pre></td></tr></table></figure> #### 变量 可以就像常量那样初始化变量，但是，初始化程序可以是一个在运行时计算的一般表达式。</p>
<h4 id="init函数"><code>init</code>函数</h4>
<p>每一个源代码文件都可以定义它自己的<code>init</code>函数来设置所需的状态（实际上，每个文件都可以有多个<code>init</code>函数）。</p>
<p>在包中所有的变量声明都已经计算出它们的初始值后，才会调用<code>init</code>函数，而变量声明的初始值计算则发生在所有导入的包完成初始化之后。示意图如下： <img src="http://img.blog.csdn.net/20150416173122272" /></p>
<p><code>init</code>函数除了用于初始化那些不能通过声明来表达的东西外，一个常用的用途是，在真正的执行开始之前，验证/修复程序状态的正确性。 <figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 验证</span></span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">log</span>.Fatal(<span class="string">&quot;$USER not set&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修复参数值</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">home</span> == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">home</span> = <span class="string">&quot;/home/&quot;</span> + user</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gopath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        gopath = <span class="built_in">home</span> + <span class="string">&quot;/go&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// gopath可能会被命令行的--gopath标记所覆盖。</span></span><br><span class="line">    flag.StringVar(&amp;gopath, <span class="string">&quot;gopath&quot;</span>, gopath, <span class="string">&quot;override default GOPATH&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 参考 - <a href="https://golang.org/doc/effective_go.html">Effective Go</a> - <a href="http://studygolang.com/articles/6464">go语言的初始化顺序，包，变量，init</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>HelloWorld</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>pythonchallenge.com | Python Challenge 第2关 题解</title>
    <url>/2014/04/07/%5Bpythonchallenge.com%5DPython%20Challenge%20%E7%AC%AC2%E5%85%B3%20%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>昨天第一关过了之后只是扫了下第二关的题目。</p>
<h1 id="内容">内容</h1>
<p><img src="/img/1396872642247.png" /></p>
<h1 id="题解">题解</h1>
<p>图上神马都米有，果断看提示！</p>
<p>MAYBE那么大个，好吧，右键，查看源代码，乱七八糟的字符，真真是Mess！懒了，洗洗睡，今天才好好研究了下。也不知道它要干嘛，anyway，先写个字符统计的东东看下有什么结果。</p>
<p>上代码~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;ocr.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">index = <span class="string">&#x27;&#x27;</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> line:</span><br><span class="line">        <span class="keyword">if</span> ch <span class="keyword">in</span> d:</span><br><span class="line">            d[ch] = d[ch]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d[ch] = <span class="number">1</span></span><br><span class="line">            index = index + <span class="string">&quot; &quot;</span> + ch</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span> a + <span class="string">&#x27; : &#x27;</span> + <span class="built_in">str</span>(d[a])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> index</span><br></pre></td></tr></table></figure>
<p>哎哟喂，结果真的有几个个数为一的字符。</p>
<p>直接改了url，结果来了个404！</p>
<p>好吧，貌似dict这个结构打印出来会自动排序的。额~手动查找吧。</p>
<p>按出现的顺序重新组成了一个串。咦，居然是个单词。靠谱！</p>
<p>改了Url，enter，oh, yeah~</p>
<p>所以这个代码有待改进……</p>
<p>后来加了个Index，每来一个新的字符就把它粘到后面。于是，就可以看到各个字符出现的顺序啦。妈妈再也不怕我第一次就404了！</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pythonchallenge</tag>
      </tags>
  </entry>
  <entry>
    <title>外面的世界很精彩|使用shadowsocks+tsocks设置全局代理</title>
    <url>/2015/10/07/%5B%E5%A4%96%E9%9D%A2%E7%9A%84%E4%B8%96%E7%95%8C%E5%BE%88%E7%B2%BE%E5%BD%A9%5D%E4%BD%BF%E7%94%A8shadowsocks+tsocks%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>之前在windows上使用shadowsocks-windows还是玩的挺好的，从此珍爱生命，我上谷歌。 然而，最近开始写点小脚本，需要访问google的一些东东。因此，得在我家派上实现全局代理。</p>
<h1 id="shadowsocks">shadowsocks</h1>
<p>网上的教程大多数是教你如何搭shadowsocks服务端做代理，然后再用个gui配置代理信息。这个跟我的需求不符。因为首先shadowsocks的服务端我已经购买了现成的，因此只需要在派上搭个客户端配置代理信息就行了。而且我家派一直都是用SSH访问的，从来没有用过GUI，Orz...</p>
<ol type="1">
<li>安装shadowsocks <figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#apt-get install python-pip</span></span><br><span class="line"><span class="meta">#pip install shadowsocks</span></span><br></pre></td></tr></table></figure></li>
<li>编辑/etc/shadowsocks.json <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;server&quot;</span>:<span class="string">&quot;服务器IP&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span>:服务器端口,</span><br><span class="line">    <span class="attr">&quot;local_address&quot;</span>: <span class="string">&quot;派的地址&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">&quot;password&quot;</span>:<span class="string">&quot;密码&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">&quot;method&quot;</span>:<span class="string">&quot;加密方式，一般为aes-256-cfb&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;fast_open&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;workers&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>启动Shadowsocks本地代理服务 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#sslocal</span> <span class="selector-tag">-c</span> /<span class="selector-tag">etc</span>/<span class="selector-tag">shadowsocks</span><span class="selector-class">.json</span></span><br></pre></td></tr></table></figure></li>
<li>设置开机自启动 <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">nano <span class="regexp">/etc/</span>rc.local</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>sslocal -c <span class="regexp">/etc/</span>shadowsocks.json &amp;</span><br></pre></td></tr></table></figure></li>
<li>重启 <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">reboot</span></span><br></pre></td></tr></table></figure> # tsocks 为什么选择tsocks呢？ 因为试过了cow，试过proxychains都不管用……</li>
<li>安装 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install tsocks</span><br></pre></td></tr></table></figure></li>
<li>编辑<code>/etc/tsocks.conf</code>，修改为： <figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">local</span> = <span class="number">192.168</span>.<span class="number">1.0</span>/<span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line"><span class="attr">local</span> = <span class="number">127.0</span>.<span class="number">0.0</span>/<span class="number">255.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">server</span> = <span class="number">127.0</span>.<span class="number">0.1</span>  <span class="comment">#与上面local_address一致</span></span><br><span class="line"><span class="comment"># Server type defaults to 4 so we need to specify it as 5 for this one</span></span><br><span class="line"><span class="attr">server_type</span> = <span class="number">5</span></span><br><span class="line"><span class="comment"># The port defaults to 1080 but I&#x27;ve stated it here for clarity </span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">1080</span>  <span class="comment">#与上面local_port一致</span></span><br></pre></td></tr></table></figure></li>
<li>测试一下 <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">tsocks wget https:<span class="regexp">//g</span>data-python-client.googlecode.com<span class="regexp">/files/g</span>data-<span class="number">2.0</span>.<span class="number">17</span>.tar.gz</span><br></pre></td></tr></table></figure> # 参考资料</li>
</ol>
<ul>
<li><a href="http://blog.xinshangshangxin.com/2015/06/21/linux%E7%BB%88%E7%AB%AF%E7%BF%BB%E5%A2%99/">linux终端翻墙</a></li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>香蕉派</tag>
        <tag>GFW</tag>
      </tags>
  </entry>
  <entry>
    <title>译|TED：神奇的斐波那契数列</title>
    <url>/2014/01/25/%5B%E8%AF%91%5DTED%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>看了介个TED，才发现自己从来没认真认识过斐波那契数列~~~~(&gt;_&lt;)~~~~</p>
<p>Mathematics is not just solving for X, it's also figuring out WHY.</p>
<p>Always keep it in mind!</p>
<embed src="http://player.youku.com/player.php/sid/XNjY2MDQ0OTIw/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash">
</embed>
<p>(个人翻译作品，如有错误，欢迎指正O(∩_∩)O~)</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>没事翻着玩</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB初识之增删改</title>
    <url>/2015/11/11/MongoDB%E5%88%9D%E8%AF%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/</url>
    <content><![CDATA[<h1 id="插入">插入</h1>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"># <span class="built_in">insert</span>操作会给文档增加一个“_id”键，然后将其保存到MongoDB中</span><br><span class="line">&gt; db.foo.<span class="built_in">insert</span>(&#123;<span class="string">&quot;bar&quot;</span>:<span class="string">&quot;baz&quot;</span>&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.foo.<span class="built_in">find</span>()</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5643e996b477ef42bea500b1&quot;</span>), <span class="string">&quot;bar&quot;</span> : <span class="string">&quot;baz&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>批量插入：当要插入多个文档时，使用批量插入会提高插入的速度。批量插入也可以用于导入数据。使用批量插入的时候，传递一个由文档构成的数组给数据库即可。</li>
<li>插入原理：插入时，驱动程序会将数据转换成BSON形式再送到数据库。数据库解析BSON，检验是否包含“_id键并且文档不超过4MB后直接将文档原样存入数据库。</li>
</ol>
<ul>
<li>坏处：不检查数据，因此允许插入无效的数据</li>
<li>好处：更加安全，因为不执行代码，因此远离注入式攻击</li>
</ul>
<h1 id="删除">删除</h1>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除foo中所有文档,但不会删除集合本身，原有的索引也会保留</span></span><br><span class="line">&gt; db.foo.<span class="builtin-name">remove</span>(&#123;&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nRemoved&quot;</span> : 1 &#125;)</span><br><span class="line"><span class="comment"># 提供一个查询文档，则只有符合条件的文档才被删除</span></span><br><span class="line">&gt; db.mailing.list.<span class="builtin-name">remove</span>(&#123;<span class="string">&quot;opt-out&quot;</span>:true&#125;)</span><br></pre></td></tr></table></figure>
<pre><code>注意：当想删除集合中所有文档时，不传递参数会得到一个` Error: remove needs a query`的错误。可以参考[remove needs a query at src/mongo/shell/collection.js](http://stackoverflow.com/questions/25104095/remove-needs-a-query-at-src-mongo-shell-collection-js)</code></pre>
<ol type="1">
<li>删除是永久的，不能撤销，不能恢复</li>
<li>如果要清除整个集合，直接删除集合（然后重建索引）会更快。因为<code>remove()</code>操作会挨个删除文档并且更新索引，而<code>drop()</code>操作会直接删除集合的所有文档和索引。但也要注意，不能使用任何限制条件，而且因为整个集合都被删除了，所有的索引都会不见的。</li>
</ol>
<h1 id="更新">更新</h1>
<p>使用update方法： <code>update( query , obj , upsert , multi )</code> 第一个参数是查询文档，用来找出要更新的文档；第二个参数是修改器文档，描述对找到的文档做哪些修改。第三个参数表示是否为upsert。第四个参数表示是否修改所有匹配到的项。 更新操作是原子的：若两个更新同时发生，先到服务器的先执行，接着执行另外一个。</p>
<h2 id="文档替换">文档替换</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 完全用一个新文档替代匹配的文档。适用于模式结构发生了较大变化的时候。</span><br><span class="line">&gt; var joe &#x3D; db.users.findOne(&#123;&quot;name&quot;:&quot;joe&quot;&#125;)</span><br><span class="line">&gt; joe.relationships &#x3D; &#123;&quot;friends&quot;:joe.friends,&quot;enemies&quot;:joe.enemies&#125;;</span><br><span class="line">&#123; &quot;friends&quot; : 32, &quot;enemies&quot; : 2 &#125;</span><br><span class="line">&gt; joe.username &#x3D; joe.name</span><br><span class="line">joe</span><br><span class="line">&gt; delete joe.friends</span><br><span class="line">true</span><br><span class="line">&gt; delete joe.enemies</span><br><span class="line">true</span><br><span class="line">&gt; delete joe.name</span><br><span class="line">true</span><br><span class="line">&gt; db.users.update(&#123;&quot;name&quot;:&quot;joe&quot;&#125;,joe)</span><br><span class="line">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>常见错误是查询条件匹配了多个文档，然后更新的时候由于第二个参数的存在就产生重复的"_id"值。数据库会报错，不做任何修改。因此，最好确保更新总是指定唯一文档。</li>
<li><strong>当文档只有一部分要更新时，使用原子弹更新修改器可以使得更新更为有效。</strong></li>
</ul>
<h2 id="使用修改器">使用修改器</h2>
<p>更新修改器是特殊的键，用来指定复杂的更新操作，例如调整、增加或者删除键，还可能是操作数组或者内嵌文档。 使用修改器时，"_id"的值不能改变。其他键值，包括其他唯一索引的键，都是可以更改的。 ### "<span class="math inline">\(set&quot;修改器 用来指定一个键的值，若这个键不存在，则创建它。可以用于更新模式或者增加用户定义键。 <figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"># <span class="string">&quot;$set&quot;</span>：不存在则创建</span><br><span class="line">&gt; <span class="keyword">db</span>.users.<span class="keyword">update</span>(&#123;<span class="string">&quot;_id&quot;</span>:ObjectId(<span class="string">&quot;5643f109b477ef42bea500b2&quot;</span>)&#125;,</span><br><span class="line">... &#123;<span class="string">&quot;$set&quot;</span>:&#123;<span class="string">&quot;favorite book&quot;</span>:<span class="string">&quot;war and peace&quot;</span>&#125;&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : 1, <span class="string">&quot;nUpserted&quot;</span> : 0, <span class="string">&quot;nModified&quot;</span> : 1 &#125;)</span><br><span class="line">&gt; <span class="keyword">db</span>.users.findOne()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5643f109b477ef42bea500b2&quot;</span>),</span><br><span class="line">        <span class="string">&quot;relationships&quot;</span> : &#123;</span><br><span class="line">                <span class="string">&quot;friends&quot;</span> : 32,</span><br><span class="line">                <span class="string">&quot;enemies&quot;</span> : 2</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;username&quot;</span> : <span class="string">&quot;joe&quot;</span>,</span><br><span class="line">        <span class="string">&quot;favorite book&quot;</span> : <span class="string">&quot;war and peace&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"># <span class="string">&quot;$set&quot;</span>：存在则修改</span><br><span class="line">&gt; <span class="keyword">db</span>.users.<span class="keyword">update</span>(&#123;<span class="string">&quot;_id&quot;</span>:ObjectId(<span class="string">&quot;5643f109b477ef42bea500b2&quot;</span>)&#125;, &#123;<span class="string">&quot;$set&quot;</span>:&#123;<span class="string">&quot;favorite book&quot;</span>:<span class="string">&quot;green eggs and ham&quot;</span>&#125;&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : 1, <span class="string">&quot;nUpserted&quot;</span> : 0, <span class="string">&quot;nModified&quot;</span> : 1 &#125;)</span><br><span class="line">&gt; <span class="keyword">db</span>.users.findOne()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5643f109b477ef42bea500b2&quot;</span>),</span><br><span class="line">        <span class="string">&quot;relationships&quot;</span> : &#123;</span><br><span class="line">                <span class="string">&quot;friends&quot;</span> : 32,</span><br><span class="line">                <span class="string">&quot;enemies&quot;</span> : 2</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;username&quot;</span> : <span class="string">&quot;joe&quot;</span>,</span><br><span class="line">        <span class="string">&quot;favorite book&quot;</span> : <span class="string">&quot;green eggs and ham&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"># <span class="string">&quot;$set&quot;</span>：修改键的数据类型</span><br><span class="line">&gt; <span class="keyword">db</span>.users.<span class="keyword">update</span>(&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;joe&quot;</span>&#125;, &#123;<span class="string">&quot;$set&quot;</span>:&#123;<span class="string">&quot;favorite book&quot;</span>:[<span class="string">&quot;cat&#x27;s cradle&quot;</span>,<span class="string">&quot;foundation trilogy&quot;</span>,<span class="string">&quot;ender&#x27;s game&quot;</span>]&#125;&#125;)</span><br><span class="line"># <span class="string">&quot;$unset&quot;</span>：完全删除键</span><br><span class="line">&gt; <span class="keyword">db</span>.users.<span class="keyword">update</span>(&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;joe&quot;</span>&#125;,</span><br><span class="line">... &#123;<span class="string">&quot;$unset&quot;</span>:&#123;<span class="string">&quot;favorite book&quot;</span>:1&#125;&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : 1, <span class="string">&quot;nUpserted&quot;</span> : 0, <span class="string">&quot;nModified&quot;</span> : 1 &#125;)</span><br></pre></td></tr></table></figure> * 增加、修改或者删除键的时候，应该适用\)</span>修改器。</p>
<h3 id="增加和减少">增加和减少</h3>
<p>"$inc"修改器用来增加已有键的值，或在键不存在时创建一个键。 * 只能用于整数、长整数或双精度浮点数。 * <span class="math inline">\(inc键的值必须为数字，不能使用字符串、数组或其他非数字的值。 <figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">db</span>.games.insert(&#123;<span class="string">&quot;game&quot;</span>:<span class="string">&quot;pinball&quot;</span>,<span class="string">&quot;user&quot;</span>:<span class="string">&quot;joe&quot;</span>&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nInserted&quot;</span> : 1 &#125;)</span><br><span class="line"># <span class="string">&quot;$inc&quot;</span>：不存在则创建</span><br><span class="line">&gt; <span class="keyword">db</span>.games.<span class="keyword">update</span>(&#123;<span class="string">&quot;game&quot;</span>:<span class="string">&quot;pinball&quot;</span>,<span class="string">&quot;user&quot;</span>:<span class="string">&quot;joe&quot;</span>&#125;,</span><br><span class="line">... &#123;<span class="string">&quot;$inc&quot;</span>:&#123;<span class="string">&quot;score&quot;</span>:50&#125;&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : 1, <span class="string">&quot;nUpserted&quot;</span> : 0, <span class="string">&quot;nModified&quot;</span> : 1 &#125;)</span><br><span class="line">&gt; <span class="keyword">db</span>.games.find(&#123;<span class="string">&quot;user&quot;</span>:<span class="string">&quot;joe&quot;</span>&#125;)</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5643fb09b477ef42bea500b4&quot;</span>), <span class="string">&quot;game&quot;</span> : <span class="string">&quot;pinball&quot;</span>, <span class="string">&quot;user&quot;</span> : <span class="string">&quot;joe&quot;</span>, <span class="string">&quot;score&quot;</span> : 50 &#125;</span><br><span class="line"># <span class="string">&quot;$inc&quot;</span>：存在则增加</span><br><span class="line">&gt; <span class="keyword">db</span>.games.<span class="keyword">update</span>(&#123;<span class="string">&quot;game&quot;</span>:<span class="string">&quot;pinball&quot;</span>,<span class="string">&quot;user&quot;</span>:<span class="string">&quot;joe&quot;</span>&#125;, &#123;<span class="string">&quot;$inc&quot;</span>:&#123;<span class="string">&quot;score&quot;</span>:10000&#125;&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : 1, <span class="string">&quot;nUpserted&quot;</span> : 0, <span class="string">&quot;nModified&quot;</span> : 1 &#125;)</span><br><span class="line">&gt; <span class="keyword">db</span>.games.find(&#123;<span class="string">&quot;user&quot;</span>:<span class="string">&quot;joe&quot;</span>&#125;)</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5643fb09b477ef42bea500b4&quot;</span>), <span class="string">&quot;game&quot;</span> : <span class="string">&quot;pinball&quot;</span>, <span class="string">&quot;user&quot;</span> : <span class="string">&quot;joe&quot;</span>, <span class="string">&quot;score&quot;</span> : 10050 &#125;</span><br></pre></td></tr></table></figure> ### 数组修改器 只能用在值为数组的键上。 <figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&gt; db.blog.posts.find()</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5643fd1ab477ef42bea500b5&quot;</span>), <span class="string">&quot;title&quot;</span> : <span class="string">&quot;A blog post&quot;</span>, <span class="string">&quot;content&quot;</span> : <span class="string">&quot;this is a test&quot;</span> &#125;</span><br><span class="line"># <span class="string">&quot;<span class="subst">$push</span>&quot;</span>：若指定的键已存在，会向已有的属组末尾加入一个元素，要是没有则创建一个新数组</span><br><span class="line">&gt; db.blog.posts.update(&#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;A blog post&quot;</span>&#125;,&#123;$push:&#123;<span class="string">&quot;comments&quot;</span>:</span><br><span class="line">... &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;joe&quot;</span>,<span class="string">&quot;email&quot;</span>:<span class="string">&quot;joe@exmple.com&quot;</span>,<span class="string">&quot;content&quot;</span>:<span class="string">&quot;nice post.&quot;</span>&#125;&#125;&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : <span class="number">1</span>, <span class="string">&quot;nUpserted&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nModified&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.blog.posts.find()</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5643fd1ab477ef42bea500b5&quot;</span>), <span class="string">&quot;title&quot;</span> : <span class="string">&quot;A blog post&quot;</span>, <span class="string">&quot;content&quot;</span> : <span class="string">&quot;this is a test&quot;</span>, <span class="string">&quot;comments&quot;</span> : [ &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;joe&quot;</span>, <span class="string">&quot;email&quot;</span> : <span class="string">&quot;joe@exmple.com&quot;</span>, <span class="string">&quot;content&quot;</span> : <span class="string">&quot;nice post.&quot;</span> &#125; ] &#125;</span><br><span class="line"># <span class="string">&quot;<span class="subst">$ne</span>&quot;</span></span><br><span class="line">&gt; db.papers.update(&#123;<span class="string">&quot;authors cited&quot;</span>:&#123;<span class="string">&quot;<span class="subst">$ne</span>&quot;</span>:<span class="string">&quot;Richie&quot;</span>&#125;&#125;,</span><br><span class="line">... &#123;$push:&#123;<span class="string">&quot;authors cited&quot;</span>:<span class="string">&quot;Richie&quot;</span>&#125;&#125;)</span><br><span class="line"># <span class="string">&quot;<span class="subst">$addToSet</span>&quot;</span>：避免重复</span><br><span class="line">&gt; db.users.update(&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;joe&quot;</span>&#125;,</span><br><span class="line">... &#123;<span class="string">&quot;<span class="subst">$addToSet</span>&quot;</span>:&#123;<span class="string">&quot;emails&quot;</span>:<span class="string">&quot;joe@gmail.com&quot;</span>&#125;&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : <span class="number">1</span>, <span class="string">&quot;nUpserted&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nModified&quot;</span> : <span class="number">0</span> &#125;)</span><br><span class="line"># <span class="string">&quot;<span class="subst">$addToSet</span>&quot;</span>和<span class="string">&quot;<span class="subst">$each</span>&quot;</span>组合起来，可以添加多个不同的值</span><br><span class="line">&gt; db.users.update(&#123;<span class="string">&quot;_id&quot;</span>:ObjectId(<span class="string">&quot;5643f109b477ef42bea500b2&quot;</span>)&#125;, &#123;<span class="string">&quot;<span class="subst">$addToSet</span>&quot;</span>: &#123;<span class="string">&quot;emails&quot;</span>:&#123;<span class="string">&quot;<span class="subst">$each</span>&quot;</span>:[<span class="string">&quot;joe@php.net&quot;</span>,<span class="string">&quot;joe@example.com&quot;</span>,<span class="string">&quot;joe@python.org&quot;</span>]&#125;&#125;&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">&quot;nMatched&quot;</span> : <span class="number">1</span>, <span class="string">&quot;nUpserted&quot;</span> : <span class="number">0</span>, <span class="string">&quot;nModified&quot;</span> : <span class="number">1</span> &#125;)</span><br><span class="line"># <span class="string">&quot;<span class="subst">$pop</span>&quot;</span>：从数组任何一端删除元素。&#123;<span class="string">&quot;<span class="subst">$pop</span>&quot;</span>:&#123;<span class="string">&quot;key&quot;</span>:<span class="number">1</span>&#125;&#125;从数组末尾删除一个元素；&#123;<span class="string">&quot;<span class="subst">$pop</span>&quot;</span>:&#123;<span class="string">&quot;key&quot;</span>:<span class="number">-1</span>&#125;&#125;从数组头部删除一个元素</span><br><span class="line">&gt; db.blog.posts.update(&#123;<span class="string">&quot;_id&quot;</span>: ObjectId(<span class="string">&quot;5643fd1ab477ef42bea500b5&quot;</span>)&#125;, &#123;<span class="string">&quot;<span class="subst">$pop</span>&quot;</span>:&#123;<span class="string">&quot;comments&quot;</span>:<span class="number">-1</span>&#125;&#125;)</span><br><span class="line"># <span class="string">&quot;<span class="subst">$pull</span>&quot;</span>：基于特定条件删除元素</span><br></pre></td></tr></table></figure> ### 数组的定位修改器 有两种方法可以操作数组中的值： * 通过位置：可以将下标（以0开始）直接作为键来选择元素 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.blog.posts.update(&#123;&quot;_id&quot;: ObjectId(&quot;5643fd1ab477ef42bea500b5&quot;)&#125;, &#123;&quot;$inc&quot;:&#123;&quot;comments.0.votes&quot;:1&#125;&#125;)</span><br></pre></td></tr></table></figure> * 使用定位操作符&quot;\)</span>" <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定位查询文档已经匹配的元素，并进行更新。</span></span><br><span class="line"><span class="comment"># 注意，定位符只更新第一个匹配的元素。</span></span><br><span class="line">&gt; db.blog.posts.update(&#123;<span class="string">&quot;comments.author&quot;</span>:<span class="string">&quot;John&quot;</span>&#125;,&#123;<span class="string">&quot;<span class="variable">$set</span>&quot;</span>:&#123;<span class="string">&quot;comments.<span class="variable">$</span>.author&quot;</span>:<span class="string">&quot;Jim&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure> ### 修改器速度 不同的修改器根据它们的作用而速度不一。</p>
<h2 id="upsert">upsert</h2>
<p>一种特殊的更新。若没有文档符合更新条件，则以这个条件和更新文档为基础创建一个新的文档。若找到了匹配的文档，则正常更新。 <figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"># update的第<span class="number">3</span>个参数表示这是个upsert</span><br><span class="line">&gt; db.analytics.update(&#123;<span class="string">&quot;url&quot;</span>:<span class="string">&quot;/blog&quot;</span>&#125;,&#123;<span class="string">&quot;$inc&quot;</span>:&#123;<span class="string">&quot;visits&quot;</span>:<span class="number">1</span>&#125;&#125;,<span class="literal">true</span>)</span><br><span class="line">WriteResult(&#123;</span><br><span class="line">        <span class="string">&quot;nMatched&quot;</span> : 0,</span><br><span class="line">        <span class="string">&quot;nUpserted&quot;</span> : 1,</span><br><span class="line">        <span class="string">&quot;nModified&quot;</span> : 0,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : <span class="type">ObjectId</span>(<span class="string">&quot;56442f86d00ed0231039a956&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"># 创建新文档会将条件文档作为基础，然后将修改器文档应用于其上。</span><br><span class="line">&gt; db.math.remove(&#123;&#125;)</span><br><span class="line">&gt; db.math.update(&#123;<span class="string">&quot;count&quot;</span>:<span class="number">25</span>&#125;,&#123;<span class="string">&quot;$inc&quot;</span>:&#123;<span class="string">&quot;count&quot;</span>:<span class="number">3</span>&#125;&#125;,<span class="literal">true</span>)</span><br><span class="line">&gt; db.math.findOne()</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="type">ObjectId</span>(<span class="string">&quot;56443012d00ed0231039a957&quot;</span>), <span class="string">&quot;count&quot;</span> : 28 &#125;</span><br></pre></td></tr></table></figure> <code>save</code>是一个shell函数，可以在文档不存在时插入，存在时更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var x &#x3D; db.foo.findOne()</span><br><span class="line">&gt; x.num &#x3D; 42</span><br><span class="line"># save只有一个参数：文档</span><br><span class="line">&gt; db.foo.save(x)</span><br></pre></td></tr></table></figure>
<h2 id="更新多个文档">更新多个文档</h2>
<p><code>update</code>默认只更新符合匹配条件的第一个文档。要使所有匹配到的文档都得到更新，可以设置<code>update</code>的第4个参数为true。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.users.update(&#123;birthday:&quot;10&#x2F;13&#x2F;1978&quot;&#125;, &#123;&quot;$set&quot;:&#123;&quot;gift&quot;:&quot;Happy Birthday!&quot;&#125;&#125;, false, true)</span><br></pre></td></tr></table></figure> ## 返回已更新的文档 可以使用getLastError获得更新文档的数目：<code>&gt; db.runCommand(&#123;getLastError:1&#125;)</code> 可以使用findAndModify返回已更新的文档。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.runCommand(&#123;&quot;findAndModify&quot;: &quot;processes&quot;, # 字符串，集合名。</span><br><span class="line">... &quot;query&quot;: &#123;&quot;status&quot;:&quot;READY&quot;&#125;, # 查询文档，用来检索文档的条件</span><br><span class="line">... &quot;sort&quot;: &#123;&quot;priority&quot;:-1&#125;, # 排序结果的条件</span><br><span class="line">... #&quot;update&quot;: &#123;&quot;status&quot;: &quot;RUNNING&quot;&#125;, # 修改器文档，对所找到的文档执行的更新</span><br><span class="line">... &quot;remove&quot;: true, # 布尔类型，表示是否删除文档</span><br><span class="line">... &quot;new&quot;: true # 布尔类型，表示返回的是更新前的文档还是更新后的文档。默认是更新前的文档</span><br><span class="line">... )</span><br></pre></td></tr></table></figure> * "update"和"remove"必须有一个，也只能有一个 * 若匹配不到，则返回一个错误 * 一次只能处理一个文档，且只能更新已有文档 * 速度相对普通更新慢一点</p>
<h1 id="瞬间完成">瞬间完成</h1>
<p>上面提到的三个操作（插入、删除和更新）都是瞬间完成的，即不需要等待数据库响应（不是异步操作）。 ## 安全操作 上面三种操作都有“安全”版本，执行时检查到了错误还可以重来。安全的版本在执行完了操作后立即运行getLastError命令。驱动程序也会等待数据库响应。一般呢，会抛出一个可以被捕获的异常。 1. 如果不考虑安全，就只用默认的瞬间完成 2. 若需要活得稍长一点，就把重要的用户数据用安全的方式操作，其余的数据采用瞬间完成。 3. 用来捕获“常规”错误，是一种调试数据库“奇怪”行为的好方法。</p>
<h1 id="请求和连接">请求和连接</h1>
<p>数据库会为每一个MongoDB数据库连接创建一个队列，用于存放这个连接的请求。队列采用先来先处理的方式。 使用Ruby, Python和Java驱动程序时要特别注意，因为它们的驱动程序都使用了连接池。</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>pythonchallenge.com | Python Challenge 第0关 题解</title>
    <url>/2014/04/06/%5Bpythonchallenge.com%5DPython%20Challenge%20%E7%AC%AC0%E5%85%B3%20%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>从某博客上看到的，<a href="http://www.pythonchallenge.com/">pythonchallenge</a> 权当拿来练练手~ （也不知道能走到几关。。。）</p>
<h1 id="内容">内容</h1>
<p><img src="/img/1396795367982.png" /></p>
<h1 id="题解">题解</h1>
<p>根据hint, 于是我笨笨的将URL改成：http://www.pythonchallenge.com/pc/def/238.html</p>
<p>结果，网站君给了我一句：No... the 38 is a little bit above the 2...</p>
<p>好吧，被委婉的鄙视了~</p>
<p>再接再厉。。。</p>
<p>已经显而易见了，http://www.pythonchallenge.com/pc/def/？.html</p>
<p>这个？由下面的计算结果给出：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">pow</span>(<span class="dv">2</span>,<span class="dv">38</span>)</span></code></pre></div>
<p>Bingo, 让我们进入下一关。。。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pythonchallenge</tag>
      </tags>
  </entry>
  <entry>
    <title>Go, go|小白的go小抄：空白符和嵌入</title>
    <url>/2017/08/08/Go-go-%E5%B0%8F%E7%99%BD%E7%9A%84go%E5%B0%8F%E6%8A%84%EF%BC%9A%E7%A9%BA%E7%99%BD%E7%AC%A6%E5%92%8C%E5%B5%8C%E5%85%A5/</url>
    <content><![CDATA[<h3 id="空白符blank-identifier">空白符（blank identifier）</h3>
<p>在Go中，空白符可以被赋予/声明为任何类型的任何值，其值可以被无害丢弃。就像python中的空白符一样，它表示一个只写值，在那些需要变量，但是变量的真实值无关紧要的地方被用作占位符。</p>
<h4 id="多重赋值中的空白符">多重赋值中的空白符</h4>
<p>如果某赋值的左边要求有多个值，但是其中一个值不会被程序所使用到，那么，在该赋值的左边放一个空白符，可以避免创建一个哑变量，并且可以更清晰地表明该值将被丢弃。例如： <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">// 下面调用中，只有err是重要的，因此使用空白符来丢弃无需用到的值</span><br><span class="line"><span class="keyword">if</span> _, err := <span class="built_in">os</span>.Stat(<span class="built_in">path</span>); <span class="built_in">os</span>.IsNotExist(err) &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s does not exist\n&quot;</span>, <span class="built_in">path</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 有时候，你也会在代码中看到error被丢弃，从而忽略该错误。这是一种很糟糕的做法。好孩子要经常检查返回的error哦。error的存在总是有其原因的。(*^__^*)</p>
<h4 id="未使用的导入和变量">未使用的导入和变量</h4>
<p>导入一个包或者声明一个变量，但是并不使用它们，在Go中，这是一种错误。但是，在代码频繁修改测试的情况下，常常会有未使用的导入和变量，而仅仅为了编译就把它们删掉是一件烦得不要不要的事情（而且可能稍后你还会用到它们）。</p>
<p>这个时候，空白符就闪亮登场了。</p>
<p>打个比方： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fd, err := os.Open(<span class="string">&quot;test.go&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> use fd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在这个例子中，有两个未使用的导入<code>fmt</code>和<code>io</code>，一个未使用的变量<code>fd</code>。要让编译器对这些未使用的东西保持沉默，我们可以使用一个空白符指向导入包的一个符号。类似地，将未使用变量赋给空白符也会使得编译器对未使用变量错误保持沉默。修改后的版本如下： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = fmt.Printf <span class="comment">// 仅为调试：完成后删除</span></span><br><span class="line"><span class="keyword">var</span> _ io.Reader <span class="comment">// 仅为调试：完成后删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fd, err := os.Open(<span class="string">&quot;test.go&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> use fd</span></span><br><span class="line">    _ = fd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 通常来讲，用以让导入错误沉默的全局声明应该紧挨在导入后面，并且附上注释。这会让它们易于被发现，并且作为稍后清理的提醒。</p>
<h4 id="为了副作用的导入">为了副作用的导入</h4>
<p>有时候，仅仅是为了某个包的副作用（无显式使用），而将这个包导入是很有用的（比如：导入一个包会运行这个包的<code>init</code>函数）。这个时候，我们可以这样做： <figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="literal">_</span> <span class="string">&quot;net/http/pprof&quot;</span></span><br></pre></td></tr></table></figure> #### 接口检查 在前面的文章中，我们可以看到，一个类型无需显式声明它实现了某个接口。只要这个类型实现了那个接口的方法，那么，我们就可以说，这个类实现了那个接口。实际上，大多数的接口转换是静态的，因此，会在编译时检查。</p>
<p>但是，有时，有些接口检查确实是发生在运行时的。例如，<code>encoding/json</code>包中的<code>Marshaler</code>接口。当JSON编码器接收到一个实现了该接口的值时，编码器调用该值的marshaling方法来将其转换成JSON，而不是进行标准的转换。该编码器在运行时，使用诸如<code>m, ok := val.(json.Marshaler)</code>这样的类型断言来检查。</p>
<p>如果只是为了检查某个类型是否实现了某个接口，而不是为了实际上使用这个接口本身，也有可能是作为错误检查的一部分，我们可以使用空白符来忽略类型断言得到的值： <figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := <span class="keyword">val</span>.(json.Marshaler); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;value %v of type %T implements json.Marshaler\n&quot;</span>, <span class="keyword">val</span>, <span class="keyword">val</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 另外一种场景是，必须保证在包里实现了确确实实满足某个接口的类型。比方说，类型<code>json.RawMessage</code>需要一个自定义的JSON表示，那么它应该实现<code>json.Marshaler</code>。但是，并没有任何会触发编译器自动验证这种特征的静态转换。倘若该类型不小心没法满足这个接口的要求，那么JSON编码器仍然会工作，但是并不会使用自定义的实现。为了保证该实现是正确的，可以在包中使用一个使用了空白符的全局声明： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ json.Marshaler = (*RawMessage)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure> 这种写法暗示，声明的存在只是为了进行类型检查，而不是要创建一个变量。注意，不要拿着锤子看啥都是钉子。一般来说，这样子的声明只用在代码中没有任何静态转换的情况下。</p>
<h3 id="嵌入">嵌入</h3>
<p>Go并没有典型的类型驱动的子类概念，但是，通过在一个结构或者接口里嵌入类型，它提供了从某个实现“借点”东东的能力。</p>
<p>接口嵌入非常简单。例如： <figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">Reader</span> interface &#123;</span><br><span class="line">    <span class="type">Read</span>(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="type">Writer</span> interface &#123;</span><br><span class="line">    <span class="type">Write</span>(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line">// 一个将<span class="type">Reader</span>和<span class="type">Writer</span>接口组合在一起的接口</span><br><span class="line">// 这样，这个接口就可以做接口<span class="type">Reader</span>和接口<span class="type">Writer</span>可以做的事情啦</span><br><span class="line"><span class="keyword">type</span> <span class="type">ReadWriter</span> interface &#123;</span><br><span class="line">    <span class="type">Reader</span></span><br><span class="line">    <span class="type">Writer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 只有接口可以被嵌入到接口中。</p>
<p>相同的想法也可以应用到结构上。例如，<code>bufio</code>包有两个结构类型：<code>bufio.Reader</code>和<code>bufio.Writer</code>（当然，这两个接口实现了包<code>io</code>中类似的方法）。它还实现了一个reader/writer，这是通过使用嵌入，将一个<code>Reader</code>和一个<code>Writer</code>组合到一个结构中实现的：<strong>在结构中列出类型，但不为它们提供字段名</strong> <figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">// 存储指向<span class="type">Reader</span>和<span class="type">Writer</span>的指针</span><br><span class="line">// 实现了io.<span class="type">ReadWriter</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">ReadWriter</span> struct &#123;</span><br><span class="line">    *<span class="type">Reader</span> // *bufio.<span class="type">Reader</span></span><br><span class="line">    *<span class="type">Writer</span> // *bufio.<span class="type">Writer</span></span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">也可以写成：</span><br><span class="line"><span class="keyword">type</span> <span class="type">ReadWriter</span> struct &#123;</span><br><span class="line">    reader *<span class="type">Reader</span></span><br><span class="line">    writer *<span class="type">Writer</span></span><br><span class="line">&#125;</span><br><span class="line">但是，要使用字段的方法并满足io接口，我们还需要额外提供一个像这样的方法：</span><br><span class="line"><span class="title">func</span> (rw *<span class="type">ReadWriter</span>) <span class="type">Read</span>(p []byte) (n int, err error) &#123;</span><br><span class="line">    return rw.reader.<span class="type">Read</span>(p)</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure> 通过直接嵌入结构，我们就可以直接使用嵌入类型的方法了。这意味着，在上面的例子中，<code>bufio.ReadWriter</code>不仅仅拥有<code>bufio.Reader</code>和<code>bufio.Writer</code>的方法，它还满足所有三个接口：<code>io.Reader</code>, <code>io.Writer</code>和<code>io.ReadWriter</code>。</p>
<p>但是，嵌入和子类有一个非常重要的区别。当我们嵌入一个类型时，那个类型的方法就变成了外部类型的方法了。但当方法被调用的时候，方法的接收者是内部类型，而不是外部类型。以上面的例子为例，当<code>bufio.ReadWriter</code>的<code>Read</code>方法被调用的时候，就像上面第二种实现一样，方法的接收者是<code>ReadWriter</code>的<code>reader</code>字段，而不是<code>ReadWriter</code>自身。</p>
<p>如果我们想直接引用嵌入字段，那么，字段的类型名（忽略包限定符）作为字段名。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">type Job <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Command <span class="built_in">string</span></span><br><span class="line">    *<span class="built_in">log</span>.Logger</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里，如果我们想要访问Job的一个实例job的*log.Logger，我们可以写成job.Logger</span></span><br></pre></td></tr></table></figure> 嵌入类型会引进命名冲突问题，但是解决这个问题的规则也很简单。 1. 字段/方法<code>X</code>将该类型更深的嵌套部分中的其他<code>X</code>字段隐藏起来。以上面<code>Job</code>的定义为例，如果<code>log.Logger</code>包含了一个名为<code>Command</code>的字段或者方法，那么，<code>Job</code>的<code>Command</code>字段将会占优势 2. 如果在同个嵌套级别上有相同的名字，那么，这通常是一个错误。如果<code>Job</code>结构包含其他也叫作<code>Logger</code>的字段或者方法，那么，嵌入<code>log.Logger</code>则是一种错误。但是，如果在类型定义之外，程序里绝不提及这重复的名字，那么没问题。（这样的话，即使被嵌套的类型定义修改从而导致了这种错误，那么也不会有什么问题，只要不使用即可）</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>HelloWorld</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>译|学习Python最佳方法</title>
    <url>/2015/11/16/%5B%E8%AF%91%5D%E5%AD%A6%E4%B9%A0Python%E6%9C%80%E4%BD%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>原文：<a href="http://code.tutsplus.com/tutorials/the-best-way-to-learn-python--net-26288">The Best Way to Learn Python</a></p>
<p>Python变得比以往任何时候都受欢迎。从后端Web服务器，到前端游戏开发，Python被广泛应用于其间各方各面。Python是一门真正的通用语言，并迅速成为任何一个自重的程序员兵器谱上的一个必备工具。</p>
<p>但是，Python并不是因为流行而受欢迎的。而是因为它易学，如伪代码般易读及极度敏捷。然而，学习任何一个新语言都有可能成为一项艰巨的任务，而找到正确的方法以及向正确的人学习则可以事半功倍。这就是本指南能够做到的。这是是滴Python容易，有趣及值得学习的蓝图。</p>
<h1 id="任务1从基础开始">任务1：从基础开始</h1>
<p>在写这篇文章的时候，有两个主流的Python版本：Python 2.7和Python 3.2.选择哪个版本来学习并不重要，因为它们之间的区别是很小的 - 尤其是对初学者而言。但是应该知道，Python 2拥有远远超过Python 3的第三方支持，而Python 3是设计语言的开发者的主要关注点。选择取决于你自己，但是如果你的代码与任何特定的教程都不同，请确保和教程中使用的Python版本相同。</p>
<h2 id="维基百科的python非程序员教程"><a href="http://en.wikibooks.org/wiki/Non-Programmer%27s_Tutorial_for_Python_2.6">维基百科的Python非程序员教程</a></h2>
<p>维基百科总是学习新东西的一个重要来源，Python也不例外。 在这里，你可以找到一系列扎实而中肯的指导。它不会过于技术化，而你可以投入某些有用的变成并且立即得到回报。因此，我推荐这个网站，作为开始你的Python之旅的最好地方。</p>
<h2 id="官方python教程"><a href="http://docs.python.org/tutorial/">官方Python教程</a></h2>
<p>你不会找到比官方python.org文档最好的信息来源了。然而，如果你想即刻投入，我相信大部分的你们都会想，这可能不是开始的最好地方。</p>
<pre><code>它的内容会比维基百科更技术化，在后续你深入语言时将会很有帮助。但是，对于初学者而言，它将妨碍你学习这么一门超级简单且美的语言。</code></pre>
<p>对于初学者，Python 2和Python 3最大的区别最有可能是Python 2可以打印而不需要使用括号。Python 3需要括号，但也仅此而已。</p>
<h1 id="任务2教程和视频教程">任务2：教程和视频教程</h1>
<h2 id="thenewboston的python编程教程"><a href="http://www.youtube.com/playlist?list=PLEA1FEF17E1E5C0DA&amp;feature=plcp">TheNewBoston的Python编程教程</a></h2>
<p>TheNewBoston的播放列表总是很棒的，你可以学到一大堆的语言。"Bucky"是一个超好的讲师，因为他很好的处理了有趣和容易听讲之间的关系。我强烈推荐他的任何播放列表 - 特别是他的Python播放列表。他假设学习的人编程零基础，并且会讲给你可以牢固掌握的语言。</p>
<h2 id="nettuts的从头开始学python"><a href="http://net.tutsplus.com/sessions/python-from-scratch/">Nettuts+的从头开始学Python</a></h2>
<p>另一个是Giles Lavelle的Python简介。正如TheNewBoston系列，Lavelle也假设学习的人编程零基础。</p>
<pre><code>如果你想要你的应用如何体现在一些实际应用中，或者目标在于使用Python进行web开发，这个系列可能就是你想要的那个。</code></pre>
<p>这个视频教程让你使用Django这个Python web框架从无到创建一个动态网站。</p>
<h2 id="showmedo的python教程"><a href="http://showmedo.com/videotutorials/python">ShowMeDo的Python教程</a></h2>
<pre><code>StackOverflow不只是充满了&quot;新手&quot;错误和问题。</code></pre>
<p>ShowMeDo拥有Python相关视频的庞大目录。然而它可能没有最好的用户体验。这些视频的级别从完全新手到最高级的Python技术。很值得一试。</p>
<h2 id="构建一个可以玩网络游戏的python机器人"><a href="http://active.tutsplus.com/tutorials/workflow/how-to-build-a-python-bot-that-can-play-web-games/">构建一个可以玩网络游戏的Python机器人</a></h2>
<p>这个教程在关于你将学到什么是非常明确的。所以对于一个完全初学者来说，并不推荐。不过，我觉得，它值得一提。在这个指导中，Chris Kiehl会向你展示如何构建一个非常有意思的Python机器人，这个机器人将为你玩一个简单的游戏。这个教程真真正正展示了Python的能力。它可以用于完成你可能在你电脑上完成的每一天重复的工作。</p>
<h1 id="任务3免费的电子书">任务3：免费的电子书</h1>
<p><img src="https://cdn.tutsplus.com/net/uploads/legacy/2099_python/books.png" /> 当你努力学习一些新的东西的时候，找到一个本好书是相当困难的。Python拥有强大的社区和大量免费的高质量的电子书以供选择。下面是一些最好的图书的快速列表。你可以下载它们的免费电子书版本，或者，也可以选择购买实体书（或者捐赠）来支持作者，我肯定，他们将不胜感激。</p>
<h2 id="learn-python-the-hard-way"><a href="http://learnpythonthehardway.org/">Learn Python the Hard Way</a></h2>
<p>请忽略它的名字，Learn Python the Hard Way让Python学习难以置信的简单 - 正如它所意味的一样！在这本书中，Zed A. Shaw从头开始提供你一些Python的细节和全面而详尽的指南，而不会阻碍你实际的编码。Shaw这本书是非正式的，但是相当详细，这让阅读这本书变得容易而且值得一读。</p>
<h2 id="think-python-how-to-think-like-a-computer-scientist"><a href="http://www.greenteapress.com/thinkpython/thinkpython.html">Think Python: How to Think Like a Computer Scientist</a></h2>
<p>正如子标题所暗示的，"如何像一个计算机科学家一样思考"，Think Python更偏于理论知识。这对于初学者来说可能会有点挫败，但是在有关算法理论和高级概念方面，这本书是非常值得一读的。</p>
<h2 id="invent-with-python"><a href="http://inventwithpython.com/chapters/">Invent With Python</a></h2>
<p>如果你习惯于"边做边学"，那么构建你自己的游戏将会是一个很有价值的体验！在这本书中，Al Sweigart假设读者没有任何Python基础，并且带你一路构造自己的游戏。由于这本书是面向游戏开发的，对于完全新手来说会有点快。这篇文章的后面将提到他的一本类似的书，这本书假设读者已经有了一些Python知识。如果你觉得你已经很好地掌握了这门语言，那么他其他的书将会更适合你。</p>
<h2 id="the-django-book"><a href="http://www.djangobook.com/">The Django Book</a></h2>
<p>如果你想学习Python的WEB开发，那么你可能会使用Django框架。这本书假设你已经可以顺利使用Python了，但如果你是这个框架的初学者，它还会教你Django。The Django Book几乎如它们自身一样好，对于任何萌芽中的web开发者也是无价之宝。</p>
<h2 id="python-books"><a href="http://wiki.python.org/moin/PythonBooks">Python Books</a></h2>
<p>如果这还不够，或者想要一本关于特定主题的书，那么你可以试试这个链接。<a href="http://python.org/">python.org</a>上的人们已经汇集了广泛的书籍列表，这些列表根据难度和主题分类。</p>
<h1 id="任务4熟悉stackoverflow">任务4：熟悉StackOverflow</h1>
<p>成千上万的程序员都经历过你必然要面对的每一个问题。<a href="http://stackoverflow.com/">StackOverflow</a>是一个超棒的资源，在那里，开发者可以找到他们问题的答案。当你偶然碰到了一个你不确定如何解决的问题时，搜索StackOverflow。你将极有可能找到问题的答案以及其他人如何解决他们的问题。</p>
<p>但是，StackOverflow不仅仅是充满了"新手"错误和问题。也有一些真正聪明和乐于助人的人使用这个网站 - 向他们学习吧！</p>
<pre><code>例如，看一看[Python的隐藏特性](http://stackoverflow.com/questions/101268/hidden-features-of-python)</code></pre>
<p>你可能在这里看到的许多其他正式教程不会提供的提示和小窍门，但它们对于高级Python用户来说将会非常有用。</p>
<h1 id="任务5欧拉计划">任务5：欧拉计划</h1>
<p><img src="https://cdn.tutsplus.com/net/uploads/legacy/2099_python/euler.png" /> <a href="http://projecteuler.net/">欧拉计划</a>是我最喜欢的网站。在创建一个账号后，你可以完成网站上~400的问题。每一个问题大概包括50%的数学和50%的编程。在我看来，最有成就感的是可以学到更多关于每个主题的东西。</p>
<p>一开始的时候，问题会比较简单，以测试你关于语言的知识。但难度将会逐渐增长，以挑战即使是最有经验的程序员。最后，问题的难度将会促使你去寻找最有效的算法 - 如果你不想等待数小时来计算答案。</p>
<pre><code>没有什么比促使你找到欧拉计划中的问题最快最有效的方法更能将你变成一个变成能手了。</code></pre>
<p>当你破解了一个新的问题，你将获得进入论坛中关于这个问题的线程的机会。在那里，有很多人在讨论关于他们的方法和想法。在这个线程中的后面几页，你可能可以找到用Python实现的一些方法。这才是提高你的编程技巧的真正关键的地方。如果有人的方法比你更快，花点时间分析一下你还可以怎么提高你自己的方法。随着时间的推移，你将获得所有的技巧，并且以一种有意义的方式增长你的Python知识。</p>
<p>另外，也有一些关于欧拉计划上的问题解决方案（使用Python）的很棒的博客。如果你被困在一个问题中，不要害羞，你可以看看其他开发者的解法，只要你想要从中学习。 下面是两个我喜欢的博客： * <a href="http://blog.dreamshire.com/">Dreamshire</a> * <a href="http://blog.mycila.com/">Mycila</a></p>
<h1 id="任务6构造一个游戏">任务6：构造一个游戏</h1>
<p>没有什么比构造你自己的游戏更令你满意了。它可以是一个陡峭的学习曲线，但非常非常的值得。<a href="http://www.pygame.org/news.html">PyGame</a>是Python最有名的游戏库，你可以找到一些关于它的免费教程。下面是一些好用的PyGame教程。</p>
<h2 id="官方pygame教程"><a href="http://www.pygame.org/docs/">官方PyGame教程</a></h2>
<p>除了原始的Python教程外，PyGame开发者也有属于他们自己的介绍文档。但如果你想要直接学习及开始构建你的游戏，那么这些可能过于技术了。然而，开发者文档将一直会是你最好的信息来源。所以，我仍然推荐你熟悉这个网站。</p>
<h2 id="invent-with-python-with-pygame"><a href="http://inventwithpython.com/pygame/chapters/">Invent With Python (With PyGame)</a></h2>
<p>这个由 Al Sweigart提供的免费电子书贯穿PyGame库，带你从零基础到可以构建一些有些。如果你想要的话，简单的游戏将为你提供完美的平台来开始自己的项目。广泛而详尽的注释贯穿了Sweigart所有的代码以帮助你学习。</p>
<h2 id="thenewboston的计算机游戏开发教程"><a href="http://www.youtube.com/playlist?list=PL8E21BDD0981FDF66">TheNewBoston的计算机游戏开发教程</a></h2>
<p>这是TheNewBoston的另一个播放列表。它可以当做PyGame简介。它基于零基础假设，会让你对PyGame库感觉良好。但不像InventWithPython指南，它更关注于知识点，而不会带你构造自己完整的游戏。</p>
<h1 id="任务7了解一些常用库和工具">任务7：了解一些常用库和工具</h1>
<p>Python是通用语言，它几乎可以做任何一件事。所以，当然的，它拥有看似源源不断的库和工具。下面是一些最受欢迎的。</p>
<h2 id="pypy"><a href="http://pypy.org/">PyPy</a></h2>
<p>如果你正在进行一些CPU密集型工作，然后你发现Python正在成为瓶颈，那么，你可能需要PyPy。PyPy是一个Python的可选编辑器，它可以提高处理速度。</p>
<h2 id="numpy-scipy"><a href="http://numpy.scipy.org/">NumPy + SciPy</a></h2>
<p>这两个通常齐头并进（SciPy依赖于NumPy）。如果你正在进行一些严谨的数字运算或科学研究，那么这两个库将会是你最好的搭档。NumPy和SciPy扩展了Python的数学方法和能力，可以极大的提高某些任务的速度。</p>
<h2 id="beautifulsoup"><a href="http://www.crummy.com/software/BeautifulSoup/">BeautifulSoup</a></h2>
<p>BeautifulSoup确实很美丽。如果你需要抓取一个HTML页面以获得一些信息，你将会明白它将带来多少的沮丧和让你掉多少头发。BeautifulSoup将会为你完成这些使你更长寿。强烈推荐，享受它给你带来的乐趣吧~</p>
<h2 id="python-image-library"><a href="http://www.pythonware.com/products/pil/">Python Image Library</a></h2>
<p>Python Image Library (PIL) 是一个扩展库，对于图片处理极为有用。如果你需要操作一张图片，没准PIL能帮到你。</p>
<h2 id="django"><a href="https://www.djangoproject.com/">Django</a></h2>
<p>文章前面也提到了，如果你的目标是web开发，你将可能用到Django框架。它是Python最常用的web框架，也是拥有最多学习资源的框架。</p>
<h1 id="任务8参与开源项目">任务8：参与开源项目</h1>
<p>在你对这门语言有了一个深入的了解后，能够阅读和理解其他人的代码将是一个很重要的技能 - 更不用说这也是一个学习的好方法。 因此，开源项目是很不错的。这里，首选Github或者Bitbucket。不要担心人们会对你对代码评头论足，也不需要立刻贡献什么。你可以随时fork一个项目，自己修改一下来看看如何工作。如果碰巧看到一些你觉得可以改进的地方，真棒！放手去做吧，然后提交你对改进。这就是开源的意义。</p>
<ul>
<li><a href="https://bitbucket.org/">BitBucket</a></li>
<li><a href="https://github.com/">Github</a></li>
<li><a href="https://tutsplus.com/course/git-essentials/">Git Essentials (Screencast Course)</a></li>
</ul>
<h1 id="总结">总结</h1>
<p>我希望我可以为你提供一个牢固的Python知识基础。如果你觉得还有其他好玩的地方应该包括在这个课程表中，请在下面评论以便共享。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>没事翻着玩</tag>
      </tags>
  </entry>
  <entry>
    <title>译|拷贝-浅拷贝与深拷贝</title>
    <url>/2015/12/01/%5B%E8%AF%91%5D%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>原文：<a href="https://docs.python.org/2/library/copy.html">8.17. copy — Shallow and deep copy operations</a> Python中的赋值语句并不拷贝对象，而是创建目标和对象之间的绑定关系。对于那些可变的或包含可变对象的集合来说，有时候需要进行拷贝，以使得一个对象的改变并不会改变另一个对象。这个模块提供常规的浅拷贝操作和深拷贝操作（解释如下）。</p>
<p>接口概述：</p>
<p><code>copy.copy(x)</code> 返回x的一个浅拷贝 <code>copy.deepcopy(x)</code> 返回x的一个深拷贝 <code>exception copy.error</code> 模块的特定错误</p>
<p>浅拷贝和深拷贝之间的不同仅在于复合对象（即包含其他对象的对象，例如列表或者类实例）： * 一个浅拷贝创建一个新的复合对象，然后（尽可能地）插入原始对象中的对象的 <em>引用</em>。 * 一个深拷贝创建一个新的复合对象，然后迭代地插入原始对象中的对象的 <em>拷贝</em>。</p>
<p>两个在深拷贝操作中常见的问题（浅拷贝不存在这两个问题）： * 递归对象（直接或间接包含自身的一个引用的复合对象）可能导致递归循环 * 由于深拷贝拷贝 <em>一切</em>，因此它可能会过多拷贝。例如，即使在副本之间，管理数据结构也应该被共享。</p>
<p><code>deepcopy()</code>函数通过以下方式来避免这些问题： * 维护一个当前已拷贝对象的"备忘录"字典 * 允许用户定义的类重写拷贝操作或一组组件拷贝。</p>
<p>这个模块不会拷贝下述类型：模块，方法，堆栈跟踪，堆栈帧，文件，socket，窗口，数组或任何类似类型。 它通过返回不变的原始对象来“拷贝”函数和类（浅拷贝，深拷贝）。这与<a href="https://docs.python.org/2/library/pickle.html#module-pickle">pickle</a>模块的处理方式兼容。</p>
<p>字典的浅拷贝可以使用<code>dict.copy()</code>，而列表的浅拷贝可以通过将整个列表的切片赋值给它，例如：<code>copied_list = original_list[:]</code></p>
<p>2.5版本修改：新增拷贝函数。</p>
<p>类可以使用与控制pickling相同的接口来控制拷贝。查看模块<a href="https://docs.python.org/2/library/pickle.html#module-pickle">pickle</a>的描述以获得关于这些方法的信息。<a href="https://docs.python.org/2/library/copy.html#module-copy">copy</a>模块并不使用<a href="https://docs.python.org/2/library/copy_reg.html#module-copy_reg">copy_reg</a>注册模块。</p>
<p>若想为一个类定义它自己的拷贝实现方式，可以定义特殊的方法 <strong><strong>copy()</strong></strong> 和 <strong><strong>deepcopy</strong>()</strong>。前者被调用来实现浅拷贝操作；不需要传递额外的参数。后者被调用来实现深拷贝操作；需要传递一个参数，“备忘录”字典。如果 <strong><strong>deepcopy</strong>()</strong>实现需要创建一个组件的深拷贝，它应该调用<a href="https://docs.python.org/2/library/copy.html#copy.deepcopy">deepcopy</a>函数，并把这个组件作为第一个参数，“备忘录”字典作为第二个参数传递。</p>
<h2 id="碎碎念">碎碎念</h2>
<p>先举个例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="built_in">range</span>(<span class="number">7</span>,<span class="number">9</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = copy.copy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = copy.deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">777</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">5</span>].append(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">7</span>, <span class="number">8</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">777</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">7</span>, <span class="number">8</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">777</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">7</span>, <span class="number">8</span>, <span class="string">&#x27;c&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">3066904664L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">3066904664L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(c)</span><br><span class="line"><span class="number">3066908544L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(d)</span><br><span class="line"><span class="number">3066904624L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a[<span class="number">5</span>])</span><br><span class="line"><span class="number">3066821928L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b[<span class="number">5</span>])</span><br><span class="line"><span class="number">3066821928L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(c[<span class="number">5</span>])</span><br><span class="line"><span class="number">3066821928L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(d[<span class="number">5</span>])</span><br><span class="line"><span class="number">3066905824L</span></span><br></pre></td></tr></table></figure> 总结一下： 1. python普通的拷贝只是创建原始对象的一个引用。因此，当对a做了任何改动都会直接影响到b。从id也可以看到，a和b指向的是完全一样的对象。 2. python的浅拷贝会创建一个新的与原始对象类型一样的一个对象，然后对对象中每一个元素创建一个引用。因此，对a中不可变对象做的改动，并不会影响到c；而对a中可变对象做的改动，则会影响到c。从id也可以看到，a和c的指向的是不一样的对象，但是a和c中的元素指向的是完全一样的对象。 3. python的深拷贝是完全复制。它不仅会创建一个新的与原始对象类型一样的一个对象，还会对对象中的每一个元素迭代的创建与之类型一致的元素。因此，对a中的任何元素（可变或不可变）做的改动，都不会影响到d。从id也可以看出，a和d指向的是完全不一样的对象。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>没事翻着玩</tag>
      </tags>
  </entry>
  <entry>
    <title>apk之笨笨去广告</title>
    <url>/2013/11/02/apk%E4%B9%8B%E7%AC%A8%E7%AC%A8%E5%8E%BB%E5%B9%BF%E5%91%8A/</url>
    <content><![CDATA[<p>最近在用懒人听书，听听小说神马的。</p>
<p>然后app下面的广告晃呀晃，看着忒么的心烦呀心烦。</p>
<p>于是开始研究下肿么去广告。</p>
<p>网上搜一搜，发现一大堆都是要用apktool之类的东西改apk。</p>
<p>懒呀懒，瞄到一个思路，改Hosts文件！！</p>
<p>丫的android源自于Linux有木有！</p>
<p>可惜我的小MX2没有root呀~~~~(&gt;_&lt;)~~~~</p>
<p>然后我又懒得去root呀！</p>
<p>于是，突然猥琐的我想到了一个相当猥琐的方法。</p>
<p>故事是这样的，之前下了个QPython（话说这确实是个好东西，小伙伴们可以玩一玩，练练python），进终端，输入exit()，Bingo, ele就这样看到了可爱的linux命令行，哇咔咔~</p>
<p>好了，说了这么多废话，其实笨笨去广告很简单的。</p>
<p>原理就是修改Hosts，把apk请求广告的域名映射到错误的IP或本地IP地址，这样，apk们就无法访问到它们的广告地址了。就是这么简单！</p>
<p>hosts文件在/system/etc/下。</p>
<p>改完记得保存哦亲，然后重启哦亲~</p>
<p>附录： <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> localhost</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> api.admob.com</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> mm.admob.com</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> r.admob.com</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> ade.wooboo.com.cn</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line">　　<span class="attribute">static</span>.wooboo.com.cn</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> gw.youmi.net</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> static.youmi.net</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> aos.gw.youmi.net</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> stat.gw.youmi.net</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> wap.casee.cn</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> pic.casee.cn</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> d.wiyun.com</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> www.adview.cn</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> www.gstatic.com</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> r.domob.cn</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> s.domob.cn</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> cfg.adsmogo.com</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> req.adsmogo.com</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> imp.adsmogo.com</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line">　　<span class="attribute">appsrv1</span>.madserving.cn</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> hermes.airad.com</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> ad.airad.com</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line">　　<span class="attribute">cn</span>.ad.adon.vpon.com</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line">　　<span class="attribute">cn</span>.img.adon.vpon.com</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> ads.lmmob.com</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> r<span class="number">2</span>.adwo.com</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> static.adwo.com</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> ads.waps.cn</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> ads.wapx.cn</span><br><span class="line"></span><br><span class="line">　　<span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> api.airpush.com</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>hack</category>
      </categories>
      <tags>
        <tag>hack</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Go | channel 类型</title>
    <url>/2020/04/04/dive-into-go-channel-type/</url>
    <content><![CDATA[<p>channel 是 go 语言实现 CSP 并发模型的一个非常重要的要素。</p>
<blockquote>
<p>以下基于 Go 1.14</p>
</blockquote>
<h2 id="数据结构-runtime.hchan">数据结构 <code>runtime.hchan</code></h2>
<p><img src="/img/divego_channel_struct.svg" /></p>
<h2 id="channel-操作">channel 操作</h2>
<p>预警！！！！一大批示意图即将来临！！！！！！</p>
<h3 id="创建-channel">创建 channel</h3>
<p><img src="/img/divego_makechan.svg" /></p>
<h3 id="发送数据">发送数据</h3>
<p><img src="/img/divego_chansend.svg" /></p>
<h3 id="接收数据">接收数据</h3>
<p><img src="/img/divego_chanrecv.svg" /></p>
<h3 id="关闭-channel">关闭 channel</h3>
<p><img src="/img/divego_closechan.svg" /></p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Go | defer</title>
    <url>/2020/03/25/dive-into-go-defer/</url>
    <content><![CDATA[<blockquote>
<p>以下基于 Go 1.14</p>
</blockquote>
<p>Go 语言中的 <code>defer</code> 常用来进行资源释放。它有以下几个特点： * 向 <code>defer</code> 传入的函数会在当前函数或者方法返回之前运行。 * 函数中调用的多个 <code>defer</code> 会以先调用后执行的方式进行 * 在调用 <code>defer</code> 时，就会对函数传入的参数进行计算。</p>
<h2 id="defer-类型"><code>defer</code> 类型</h2>
<p>有三种类型的 <code>defer</code></p>
<p>编译器的 ssa 过程中会确认当前 <code>defer</code> 的类型： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compile.internal.gc.state.stmt</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">stmt</span><span class="params">(n *Node)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> ODEFER:</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">if</span> s.hasOpenDefers &#123;</span><br><span class="line">			s.openDeferRecord(n.Left)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			d := callDefer</span><br><span class="line">			<span class="keyword">if</span> n.Esc == EscNever &#123;</span><br><span class="line">				d = callDeferStack</span><br><span class="line">			&#125;</span><br><span class="line">			s.call(n.Left, d)</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 可以使用 <code>$ go tool compile -d defer hello.go</code> 来检查 <code>defer</code> 类型。</p>
<h3 id="open-coded">open-coded</h3>
<p>Go 1.14 引入，目的是优化 defer 的运行时间。编译器在 ssa 过程中，会将被延迟的方法直接插入到函数的尾部（inline），从而避免运行时的 <code>deferproc</code> 和 <code>deferprocStack</code> 操作，以及多次调用 <code>deferreturn</code>。</p>
<ul>
<li>以下情况不使用这种类型来处理 <code>defer</code>：
<ul>
<li>函数中对 <code>defer</code> 的调用次数超过 8（这是为了最小化代码大小，只使用 1 个 byte 来辅助标识）（例如下面的 <code>f0</code> 和 <code>f1</code>）</li>
<li>函数中存在出现在循环中的 <code>defer</code>（例如下面的 <code>f2</code>、<code>f3</code>、<code>f4</code> 和 <code>f5</code>）
<ul>
<li>包括使用 <code>for</code> 构造的和使用 label+<code>goto</code> 构造的</li>
</ul></li>
<li>函数中出现过多（返回语句次数 * defer 个数 &gt; 15）的返回语句
<ul>
<li>因为会在每个返回点前插入被 defer 的函数调用</li>
</ul></li>
<li><code>gcflags</code> 无 N</li>
</ul></li>
</ul>
<p>举例说明： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 8 次 defer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f0</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer0&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defe1&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer2&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defe3&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer4&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defe5&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer6&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer7&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">&quot;f0&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123; <span class="comment">// 9 次 defer</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer0&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defe1&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer2&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defe3&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer4&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defe5&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer6&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer7&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer8&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">&quot;f1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> &#123; <span class="comment">// defer 没有出现在循环中(for)</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer0&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1</span>; i += <span class="number">1</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;f2&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span></span> &#123;	<span class="comment">// defer 出现在循环中(for)</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1</span>; i += <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// heap-allocated defer</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;defer0&quot;</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;f3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f4</span><span class="params">()</span></span> &#123; <span class="comment">// defer 没有出现在循环中(label+goto)</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer0&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">label:</span><br><span class="line">	fmt.Println(<span class="string">&quot;f4&quot;</span>)</span><br><span class="line">	<span class="keyword">goto</span> label</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f5</span><span class="params">()</span></span> &#123;	<span class="comment">// defer 出现在循环中(label+goto)</span></span><br><span class="line">label:</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// heap-allocated defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer0&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">&quot;f5&quot;</span>)</span><br><span class="line">	<span class="keyword">goto</span> label</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### stack-allocated Go 1.13 引入，用于优化性能，表示在栈上分配 <code>defer</code> 相关的结构体</p>
<p>那么，什么时候会在栈上分配呢？答案在下面这部分代码： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/gc/escape.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Escape)</span> <span class="title">augmentParamHole</span><span class="params">(k EscHole, call, where *Node)</span> <span class="title">EscHole</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// Top level defers arguments don&#x27;t escape to heap, but they</span></span><br><span class="line">	<span class="comment">// do need to last until end of function. Tee with a</span></span><br><span class="line">	<span class="comment">// non-transient location to avoid arguments from being</span></span><br><span class="line">	<span class="comment">// transiently allocated.</span></span><br><span class="line">	<span class="keyword">if</span> where.Op == ODEFER &amp;&amp; e.loopDepth == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="comment">// force stack allocation of defer record, unless open-coded</span></span><br><span class="line">		<span class="comment">// defers are used (see ssa.go)</span></span><br><span class="line">		where.Esc = EscNever</span><br><span class="line">		<span class="keyword">return</span> e.later(k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 举例说明： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f6</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer2&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// heap-allocated defer</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;defer1&quot;</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### heap-allocated 表示在堆上分配 <code>defer</code> 相关的结构体，最原始的方式。</p>
<h2 id="实现原理">实现原理</h2>
<h3 id="一个数据结构">一个数据结构</h3>
<p>在 Go 中，<code>defer</code> 关键字对应的数据结构为 <code>runtime._defer</code>。这是一个用链表实现的栈。</p>
<h3 id="编译时">编译时</h3>
<ul>
<li>处理 <code>defer</code> 关键字
<ul>
<li>如果是 <code>open-coded</code> 类型的 defer，则调用 <code>cmd/compile/internal/gc.state.openDeferRecord</code> 方法，</li>
<li>如果是 <code>stack-allocated</code> 类型，则转换成 <code>runtime.deferprocStack</code></li>
<li>如果是 <code>heap-allocated</code> 类型，则转换成 <code>runtime.deferproc</code></li>
</ul></li>
<li>在调用 <code>defer</code> 的函数返回之前插入 <code>runtime.deferreturn</code> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compile.internal.gc.state</span></span><br><span class="line"><span class="comment">// 处理任何需要在返回前生成的代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">exit</span><span class="params">()</span> *<span class="title">ssa</span>.<span class="title">Block</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.hasdefer &#123; <span class="comment">// 函数中存在 defer 调用</span></span><br><span class="line">		<span class="keyword">if</span> s.hasOpenDefers &#123; <span class="comment">// 如果有 open-coded 类型的 defer</span></span><br><span class="line">			<span class="keyword">if</span> shareDeferExits &amp;&amp; s.lastDeferExit != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(s.openDefers) == s.lastDeferCount &#123;</span><br><span class="line">				<span class="keyword">if</span> s.curBlock.Kind != ssa.BlockPlain &#123;</span><br><span class="line">					<span class="built_in">panic</span>(<span class="string">&quot;Block for an exit should be BlockPlain&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				s.curBlock.AddEdgeTo(s.lastDeferExit)</span><br><span class="line">				s.endBlock()</span><br><span class="line">				<span class="keyword">return</span> s.lastDeferFinalBlock</span><br><span class="line">			&#125;</span><br><span class="line">			s.openDeferExit()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 对于其他类型的 defer，调用 </span></span><br><span class="line">			s.rtcall(Deferreturn, <span class="literal">true</span>, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// openDeferExit 生成 SSA，从而在退出的时候处理所有的 open-coded 类型的 defer。</span></span><br><span class="line"><span class="comment">// 这个过程会加载 deferBits 字段，然后检查这个字段的每个位，检查是否执行了对应的 defer 语句。</span></span><br><span class="line"><span class="comment">// 对于每一个打开的位，会进行相关的 defer 调用。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">openDeferExit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 运行时</li>
<li>如果调用了 <code>runtime.deferprocStack</code> 或者 <code>runtime.deferproc</code>，那么它们都会将一个新的 <code>runtime._defer</code> 结构体（此时就会对函数参数进行计算）追加到当前 Goroutine 的 <code>_defer</code> 链表的头部</li>
<li><code>runtime.deferreturn</code> 会从 Goroutine 的 <code>_defer</code> 链表中取出 <code>runtime._defer</code> 结构并执行
<ul>
<li>如果是 <code>open-coded</code> 类型的延迟调用，则会调用 <code>runtime.runOpenDeferFrame</code> 函数来运行该 <code>_defer</code> 结构中所有有效的延迟调用。</li>
<li>否则，它会调用 <code>runtime·jmpdefer</code> 函数。这个函数会跳到对应被延迟调用的函数并执行</li>
<li>会多次调用 <code>runtime.deferreturn</code>，直到所有的延迟调用都执行完毕。</li>
</ul></li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://github.com/golang/proposal/blob/master/design/34481-opencoded-defers.md">Proposal: Low-cost defers through inline code, and extra funcdata to manage the panic case</a></li>
<li><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#532-">draveness: defer</a></li>
</ul>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Go | for ... range</title>
    <url>/2020/04/01/dive-into-go-for-range/</url>
    <content><![CDATA[<p>golang 语法糖 <code>for ... = range</code> 是如何实现的呢？话不多说，直接上图：</p>
<p><img src="/img/divego_for_range.svg" /></p>
<blockquote>
<p>基于 Go 1.14</p>
</blockquote>
<p>参考： * <a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-for-range/">draveness: for 和 range</a></p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Go | 函数调用</title>
    <url>/2020/03/24/dive-into-go-func-call/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>对于函数调用，Go 语言使用调用者预先分配的栈来传递参数和返回值，使得多值返回成为可能。</p>
<blockquote>
<p>以下基于 Go1.14</p>
</blockquote>
<p>考虑以下代码： <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b, a == b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	do(<span class="number">33</span>, <span class="number">66</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 然后运行以下命令查看对应的汇编指令： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ go tool compile -S -N -l hello.go</span><br><span class="line">....</span><br><span class="line"><span class="string">&quot;&quot;</span>.main STEXT size=68 args=0x0 locals=0x28</span><br><span class="line">	0x0000 00000 (hello.go:7)	TEXT	<span class="string">&quot;&quot;</span>.main(SB), ABIInternal, <span class="variable">$40</span>-0</span><br><span class="line">	0x0000 00000 (hello.go:7)	MOVQ	(TLS), CX</span><br><span class="line">	0x0009 00009 (hello.go:7)	CMPQ	SP, 16(CX)</span><br><span class="line">	0x000d 00013 (hello.go:7)	PCDATA	<span class="variable">$0</span>, $-2</span><br><span class="line">	0x000d 00013 (hello.go:7)	JLS	61</span><br><span class="line">	0x000f 00015 (hello.go:7)	PCDATA	<span class="variable">$0</span>, $-1</span><br><span class="line">	0x000f 00015 (hello.go:7)	SUBQ	<span class="variable">$40</span>, SP <span class="comment"># 分配 40 字节的栈空间</span></span><br><span class="line">	0x0013 00019 (hello.go:7)	MOVQ	BP, 32(SP) <span class="comment"># 保存基址指针 BP 到栈上</span></span><br><span class="line">	0x0018 00024 (hello.go:7)	LEAQ	32(SP), BP <span class="comment"># 修改基址指针</span></span><br><span class="line">	0x001d 00029 (hello.go:7)	PCDATA	<span class="variable">$0</span>, $-2</span><br><span class="line">	0x001d 00029 (hello.go:7)	PCDATA	<span class="variable">$1</span>, $-2</span><br><span class="line">	0x001d 00029 (hello.go:7)	FUNCDATA	<span class="variable">$0</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x001d 00029 (hello.go:7)	FUNCDATA	<span class="variable">$1</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x001d 00029 (hello.go:7)	FUNCDATA	<span class="variable">$2</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x001d 00029 (hello.go:8)	PCDATA	<span class="variable">$0</span>, <span class="variable">$0</span></span><br><span class="line">	0x001d 00029 (hello.go:8)	PCDATA	<span class="variable">$1</span>, <span class="variable">$0</span></span><br><span class="line">	0x001d 00029 (hello.go:8)	MOVQ	<span class="variable">$33</span>, (SP) <span class="comment"># 第一个参数</span></span><br><span class="line">	0x0025 00037 (hello.go:8)	MOVQ	<span class="variable">$66</span>, 8(SP) <span class="comment"># 第二个参数</span></span><br><span class="line">	0x002e 00046 (hello.go:8)	CALL	<span class="string">&quot;&quot;</span>.<span class="keyword">do</span>(SB) <span class="comment"># 将当前的 IP 压入栈中，然后调用函数 do</span></span><br><span class="line">	0x0033 00051 (hello.go:9)	MOVQ	32(SP), BP <span class="comment"># 恢复基址指针</span></span><br><span class="line">	0x0038 00056 (hello.go:9)	ADDQ	<span class="variable">$40</span>, SP <span class="comment"># 回收分配的栈空间</span></span><br><span class="line">	0x003c 00060 (hello.go:9)	RET</span><br><span class="line">......</span><br></pre></td></tr></table></figure> 从上面可以看出，在进行函数调用前，会为调用的函数分配栈空间（用于入参和返回值）、保存基址指针并修改其指向，然后将入参压入栈中（第一个参数在栈顶，以此类推）。</p>
<p>接着通过 <code>CALL</code> 指令，将 <code>main</code> 的返回地址压入栈中，然后进行函数调用。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.<span class="keyword">do</span> STEXT nosplit size=45 args=0x20 locals=0x0</span><br><span class="line">    ......</span><br><span class="line">	0x0000 00000 (hello.go:3)	MOVQ	<span class="variable">$0</span>, <span class="string">&quot;&quot;</span>.~r2+24(SP) <span class="comment"># 初始化第一个返回值</span></span><br><span class="line">	0x0009 00009 (hello.go:3)	MOVB	<span class="variable">$0</span>, <span class="string">&quot;&quot;</span>.~r3+32(SP) <span class="comment"># 初始化第二个返回值</span></span><br><span class="line">	0x000e 00014 (hello.go:4)	MOVQ	<span class="string">&quot;&quot;</span>.a+8(SP), AX <span class="comment"># 获取第一个参数，AX = 33</span></span><br><span class="line">	0x0013 00019 (hello.go:4)	ADDQ	<span class="string">&quot;&quot;</span>.b+16(SP), AX <span class="comment"># 做加法，AX = AX + 66 = 99</span></span><br><span class="line">	0x0018 00024 (hello.go:4)	MOVQ	AX, <span class="string">&quot;&quot;</span>.~r2+24(SP) <span class="comment"># 把计算结果保存在第一个返回值中，24(SP) = AX = 99</span></span><br><span class="line">	0x001d 00029 (hello.go:4)	MOVQ	<span class="string">&quot;&quot;</span>.b+16(SP), AX <span class="comment"># AX = 66</span></span><br><span class="line">	0x0022 00034 (hello.go:4)	CMPQ	<span class="string">&quot;&quot;</span>.a+8(SP), AX <span class="comment"># 8(SP) 和 AX 进行比较，即 AX - 8(SP) = 66 - 33 = 33</span></span><br><span class="line">	0x0027 00039 (hello.go:4)	SETEQ	<span class="string">&quot;&quot;</span>.~r3+32(SP) <span class="comment"># 判断上一步的计算结果是否为 0，保存在第二个返回值中，32(SP) = 0</span></span><br><span class="line">	0x002c 00044 (hello.go:4)	RET <span class="comment"># 修改 IP，返回调用点</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure> 被调用的函数在执行的时候，会将调用栈里面保存返回值的位置初始化为 0，然后进行一系列的操作后，将返回值保存在栈中，最后返回该函数的调用点。</p>
<p><img src="/img/20200324212922.jpg" /></p>
<h2 id="参数传递">参数传递</h2>
<h3 id="变长参数">变长参数</h3>
<p>将 <code>do</code> 函数修改为支持变长参数，如下所示： <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(nums ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T %v\n&quot;</span>, nums, nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	do() <span class="comment">// output: []int []</span></span><br><span class="line">	do(<span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>) <span class="comment">// output: []int [33 44 55]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 可以看到，变长参数其实是一个语法糖，golang 会为这些变长参数隐式创建一个 slice，然后再把这个 slice 作为参数传入到调用的函数中。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.main STEXT size=196 args=0x0 locals=0x40</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment"># do(33, 44, 55)</span></span><br><span class="line">    <span class="comment"># 创建一个大小为 3，容量为 3 的 slice，值为[33, 44, 55]</span></span><br><span class="line">	0x0036 00054 (hello.go:11)	LEAQ	<span class="built_in">type</span>.[3]int(SB), AX </span><br><span class="line">	0x003d 00061 (hello.go:11)	PCDATA	<span class="variable">$0</span>, <span class="variable">$0</span></span><br><span class="line">	0x003d 00061 (hello.go:11)	MOVQ	AX, (SP)</span><br><span class="line">	0x0041 00065 (hello.go:11)	CALL	runtime.newobject(SB)</span><br><span class="line">	0x0046 00070 (hello.go:11)	PCDATA	<span class="variable">$0</span>, <span class="variable">$1</span></span><br><span class="line">	0x0046 00070 (hello.go:11)	MOVQ	8(SP), AX</span><br><span class="line">	0x004b 00075 (hello.go:11)	PCDATA	<span class="variable">$1</span>, <span class="variable">$1</span></span><br><span class="line">	0x004b 00075 (hello.go:11)	MOVQ	AX, <span class="string">&quot;&quot;</span>..autotmp_1+24(SP)</span><br><span class="line">	0x0050 00080 (hello.go:11)	PCDATA	<span class="variable">$0</span>, <span class="variable">$0</span></span><br><span class="line">	0x0050 00080 (hello.go:11)	MOVQ	<span class="variable">$33</span>, (AX)</span><br><span class="line">	0x0057 00087 (hello.go:11)	PCDATA	<span class="variable">$0</span>, <span class="variable">$1</span></span><br><span class="line">	0x0057 00087 (hello.go:11)	MOVQ	<span class="string">&quot;&quot;</span>..autotmp_1+24(SP), AX</span><br><span class="line">	0x005c 00092 (hello.go:11)	TESTB	AL, (AX)</span><br><span class="line">	0x005e 00094 (hello.go:11)	PCDATA	<span class="variable">$0</span>, <span class="variable">$0</span></span><br><span class="line">	0x005e 00094 (hello.go:11)	MOVQ	<span class="variable">$44</span>, 8(AX)</span><br><span class="line">	0x0066 00102 (hello.go:11)	PCDATA	<span class="variable">$0</span>, <span class="variable">$1</span></span><br><span class="line">	0x0066 00102 (hello.go:11)	MOVQ	<span class="string">&quot;&quot;</span>..autotmp_1+24(SP), AX</span><br><span class="line">	0x006b 00107 (hello.go:11)	TESTB	AL, (AX)</span><br><span class="line">	0x006d 00109 (hello.go:11)	PCDATA	<span class="variable">$0</span>, <span class="variable">$0</span></span><br><span class="line">	0x006d 00109 (hello.go:11)	MOVQ	<span class="variable">$55</span>, 16(AX)</span><br><span class="line">	0x0075 00117 (hello.go:11)	PCDATA	<span class="variable">$0</span>, <span class="variable">$1</span></span><br><span class="line">	0x0075 00117 (hello.go:11)	PCDATA	<span class="variable">$1</span>, <span class="variable">$0</span></span><br><span class="line">	0x0075 00117 (hello.go:11)	MOVQ	<span class="string">&quot;&quot;</span>..autotmp_1+24(SP), AX</span><br><span class="line">	0x007a 00122 (hello.go:11)	TESTB	AL, (AX)</span><br><span class="line">	0x007c 00124 (hello.go:11)	JMP	126</span><br><span class="line">	0x007e 00126 (hello.go:11)	MOVQ	AX, <span class="string">&quot;&quot;</span>..autotmp_0+32(SP)</span><br><span class="line">	0x0083 00131 (hello.go:11)	MOVQ	<span class="variable">$3</span>, <span class="string">&quot;&quot;</span>..autotmp_0+40(SP)</span><br><span class="line">	0x008c 00140 (hello.go:11)	MOVQ	<span class="variable">$3</span>, <span class="string">&quot;&quot;</span>..autotmp_0+48(SP)</span><br><span class="line">	0x0095 00149 (hello.go:11)	PCDATA	<span class="variable">$0</span>, <span class="variable">$0</span></span><br><span class="line">	0x0095 00149 (hello.go:11)	MOVQ	AX, (SP)</span><br><span class="line">	0x0099 00153 (hello.go:11)	MOVQ	<span class="variable">$3</span>, 8(SP)</span><br><span class="line">	0x00a2 00162 (hello.go:11)	MOVQ	<span class="variable">$3</span>, 16(SP)</span><br><span class="line">    <span class="comment"># 调用 do 函数</span></span><br><span class="line">	0x00ab 00171 (hello.go:11)	CALL	<span class="string">&quot;&quot;</span>.<span class="keyword">do</span>(SB)</span><br><span class="line">	0x00b0 00176 (hello.go:12)	MOVQ	56(SP), BP</span><br><span class="line">	0x00b5 00181 (hello.go:12)	ADDQ	<span class="variable">$64</span>, SP</span><br><span class="line">	0x00b9 00185 (hello.go:12)	RET</span><br></pre></td></tr></table></figure> ## 返回值 ### 命名返回值 我们将代码稍微修改下，命名函数 <code>do</code> 的返回值： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>, equal <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b, a == b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 然后查看汇编，可以发现，<code>main</code> 在进行函数调用的时候基本没有改动，但是被调用函数在执行的时候多了几项操作。<strong>在执行前，会申请额外的栈空间来存放临时返回值。</strong>然后，初始化命名返回值，进行一系列操作后，把返回结果保存在临时返回值中。最后，再使用临时返回值一一设置命名返回值。接着释放存放临时返回值的栈空间，返回到函数调用点。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.<span class="keyword">do</span> STEXT nosplit size=87 args=0x20 locals=0x18</span><br><span class="line">	0x0000 00000 (hello.go:3)	TEXT	<span class="string">&quot;&quot;</span>.<span class="keyword">do</span>(SB), NOSPLIT|ABIInternal, <span class="variable">$24</span>-32</span><br><span class="line">	0x0000 00000 (hello.go:3)	SUBQ	<span class="variable">$24</span>, SP // 申请空间存放临时返回值</span><br><span class="line">	0x0004 00004 (hello.go:3)	MOVQ	BP, 16(SP)</span><br><span class="line">	0x0009 00009 (hello.go:3)	LEAQ	16(SP), BP</span><br><span class="line">	0x000e 00014 (hello.go:3)	PCDATA	<span class="variable">$0</span>, $-2</span><br><span class="line">	0x000e 00014 (hello.go:3)	PCDATA	<span class="variable">$1</span>, $-2</span><br><span class="line">	0x000e 00014 (hello.go:3)	FUNCDATA	<span class="variable">$0</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x000e 00014 (hello.go:3)	FUNCDATA	<span class="variable">$1</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x000e 00014 (hello.go:3)	FUNCDATA	<span class="variable">$2</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x000e 00014 (hello.go:3)	PCDATA	<span class="variable">$0</span>, <span class="variable">$0</span></span><br><span class="line">	0x000e 00014 (hello.go:3)	PCDATA	<span class="variable">$1</span>, <span class="variable">$0</span></span><br><span class="line">	0x000e 00014 (hello.go:3)	MOVQ	<span class="variable">$0</span>, <span class="string">&quot;&quot;</span>.res+48(SP) // 初始化第一个返回值，res = 0</span><br><span class="line">	0x0017 00023 (hello.go:3)	MOVB	<span class="variable">$0</span>, <span class="string">&quot;&quot;</span>.equal+56(SP) // 初始化第二个返回值，equal = 0</span><br><span class="line">	0x001c 00028 (hello.go:4)	MOVQ	<span class="string">&quot;&quot;</span>.a+32(SP), AX // AX = a = 33</span><br><span class="line">	0x0021 00033 (hello.go:4)	ADDQ	<span class="string">&quot;&quot;</span>.b+40(SP), AX // AX = AX + b = 33 + 66 = 99</span><br><span class="line">	0x0026 00038 (hello.go:4)	MOVQ	AX, <span class="string">&quot;&quot;</span>..autotmp_4+8(SP) // 计算结果保存在临时变量中</span><br><span class="line">	0x002b 00043 (hello.go:4)	MOVQ	<span class="string">&quot;&quot;</span>.b+40(SP), AX</span><br><span class="line">	0x0030 00048 (hello.go:4)	CMPQ	<span class="string">&quot;&quot;</span>.a+32(SP), AX</span><br><span class="line">	0x0035 00053 (hello.go:4)	SETEQ	<span class="string">&quot;&quot;</span>..autotmp_5+7(SP) // 计算结果保存在临时变量中</span><br><span class="line">	0x003a 00058 (hello.go:4)	MOVQ	<span class="string">&quot;&quot;</span>..autotmp_4+8(SP), AX</span><br><span class="line">	0x003f 00063 (hello.go:4)	MOVQ	AX, <span class="string">&quot;&quot;</span>.res+48(SP) // 用临时变量设置命名返回值</span><br><span class="line">	0x0044 00068 (hello.go:4)	MOVBLZX	<span class="string">&quot;&quot;</span>..autotmp_5+7(SP), AX // 用临时变量设置命名返回值</span><br><span class="line">	0x0049 00073 (hello.go:4)	MOVB	AL, <span class="string">&quot;&quot;</span>.equal+56(SP)</span><br><span class="line">	0x004d 00077 (hello.go:4)	MOVQ	16(SP), BP</span><br><span class="line">	0x0052 00082 (hello.go:4)	ADDQ	<span class="variable">$24</span>, SP</span><br><span class="line">	0x0056 00086 (hello.go:4)	RET</span><br></pre></td></tr></table></figure> 也就是说，如果对于非命名返回值，执行逻辑为： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    r1, r2 := a+b, a == b</span><br><span class="line">    <span class="keyword">return</span> r1, r2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 那么命名返回值的执行逻辑为： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>, equal <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    tmp1, tmp2 := a+b, a == b</span><br><span class="line">    res = tmp1</span><br><span class="line">    equal = tmp2</span><br><span class="line">    <span class="keyword">return</span> res, equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 总结 golang 的函数调用具有以下特征： * 参数完全通过栈传递，从参数列表右至左压栈（第一个参数在栈顶） * 返回值通过栈传递 * 调用者负责清理栈空间</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/">函数调用（）</a></li>
<li><a href="https://mojotv.cn/2019/07/21/golang-stack-function">Go 函数调用 ━ 栈和寄存器视角</a></li>
</ul>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Go | make vs. new</title>
    <url>/2020/03/23/dive-into-go-make-new/</url>
    <content><![CDATA[<blockquote>
<p>以下基于 go 1.14</p>
</blockquote>
<h2 id="基本使用">基本使用</h2>
<p>在 golang 中，内置函数 <code>make</code> 和 <code>new</code> 都是用来分配内存的。<code>src/builtin/builtin.go</code> 中对 <code>make</code> 和 <code>new</code> 的声明如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The make built-in function allocates and initializes an object of type</span></span><br><span class="line"><span class="comment">// slice, map, or chan (only). Like new, the first argument is a type, not a</span></span><br><span class="line"><span class="comment">// value. Unlike new, make&#x27;s return type is the same as the type of its</span></span><br><span class="line"><span class="comment">// argument, not a pointer to it. The specification of the result depends on</span></span><br><span class="line"><span class="comment">// the type:</span></span><br><span class="line"><span class="comment">//	Slice: The size specifies the length. The capacity of the slice is</span></span><br><span class="line"><span class="comment">//	equal to its length. A second integer argument may be provided to</span></span><br><span class="line"><span class="comment">//	specify a different capacity; it must be no smaller than the</span></span><br><span class="line"><span class="comment">//	length. For example, make([]int, 0, 10) allocates an underlying array</span></span><br><span class="line"><span class="comment">//	of size 10 and returns a slice of length 0 and capacity 10 that is</span></span><br><span class="line"><span class="comment">//	backed by this underlying array.</span></span><br><span class="line"><span class="comment">//	Map: An empty map is allocated with enough space to hold the</span></span><br><span class="line"><span class="comment">//	specified number of elements. The size may be omitted, in which case</span></span><br><span class="line"><span class="comment">//	a small starting size is allocated.</span></span><br><span class="line"><span class="comment">//	Channel: The channel&#x27;s buffer is initialized with the specified</span></span><br><span class="line"><span class="comment">//	buffer capacity. If zero, or the size is omitted, the channel is</span></span><br><span class="line"><span class="comment">//	unbuffered.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The new built-in function allocates memory. The first argument is a type,</span></span><br><span class="line"><span class="comment">// not a value, and the value returned is a pointer to a newly</span></span><br><span class="line"><span class="comment">// allocated zero value of that type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure>
<h3 id="func-maket-type-size-...integertype-type"><code>func make(t Type, size ...IntegerType) Type</code></h3>
<p><code>make</code> 函数用来分配和初始化指定类型的对象。使用过程中，有几点是需要注意的： * 第一个参数指定了要创建的对象的<strong>类型</strong>。这里的类型只允许：切片、map 和 channel * 返回值是指定类型的对象</p>
<h4 id="如果指定类型为切片">如果指定类型为切片</h4>
<p><strong>第二个参数 <code>size</code> 一定要指定，否则会编译错误。</strong> <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>) <span class="comment">// compile error:  missing len argument to make([]int)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\t%d\n&quot;</span>, a, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br></pre></td></tr></table></figure> 如果第二个参数只提供了一个整数值，那么表示该切片的长度。此时，该切片的容量和长度一致。 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\t%d\n&quot;</span>, b, b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line"><span class="comment">// []int   [0 0 0 0]       4       4</span></span><br></pre></td></tr></table></figure> 如果提供了第二个整数值，则该值指定切片的容量。<strong>这个值不能比第一个整数值小</strong>，否则会出现编译错误。 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\t%d\n&quot;</span>, c, c, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c))</span><br><span class="line"><span class="comment">// []int   [0 0 0 0 0]     5       6</span></span><br><span class="line">d := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// compile error: len larger than cap in make([]int)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\t%d\n&quot;</span>, d, d, <span class="built_in">len</span>(d), <span class="built_in">cap</span>(d))</span><br></pre></td></tr></table></figure> #### 如果指定类型为 map 如果类型为 map，则可以省略第二个参数。 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\n&quot;</span>, a, a, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="comment">// map[string]bool map[]   0</span></span><br><span class="line">b := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>, <span class="number">4</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\n&quot;</span>, b, b, <span class="built_in">len</span>(b))</span><br><span class="line"><span class="comment">// map[string]bool map[]   0</span></span><br></pre></td></tr></table></figure> 如果出现第二个整数值，会出现编译错误： <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// compile error: too many arguments to make(map[string]bool)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\n&quot;</span>, c, c, <span class="built_in">len</span>(c))</span><br></pre></td></tr></table></figure> 值得一提的是，map 在使用前一定要进行初始化，否则会出现错误。而初始化可以使用 <code>make</code> 来实现。 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">a[<span class="string">&quot;bb&quot;</span>] = <span class="literal">false</span> <span class="comment">// panic: assignment to entry in nil map</span></span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>, <span class="number">5</span>)</span><br><span class="line">b[<span class="string">&quot;aa&quot;</span>] = <span class="literal">true</span></span><br><span class="line">fmt.Println(b, <span class="built_in">len</span>(b)) <span class="comment">// map[aa:true] 1</span></span><br></pre></td></tr></table></figure> #### 如果指定类型为 channel 如果不指定第二个参数，则创建一个无缓冲的 channel。 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\t%d\n&quot;</span>, a, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line"><span class="comment">// chan bool       0xc00008c060    0       0</span></span><br></pre></td></tr></table></figure> 如果指定第二个参数，并且该参数的值不为 0，则创建一个带缓冲的 channel，缓冲大小由该参数指定。 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">b := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">4</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\t%d\n&quot;</span>, b, b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line"><span class="comment">// chan bool       0xc0000b6000    0       4</span></span><br></pre></td></tr></table></figure> 不能指定第二个整数值，否则会报错。 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// compile error: too many arguments to make(chan bool)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\t%d\n&quot;</span>, c, c, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c))</span><br></pre></td></tr></table></figure> ### <code>func new(Type) *Type</code> <code>new</code> 函数也是用来分配内存的。但是，相对 <code>make</code> 而言，<code>new</code> 函数简单多了： * 只接受一个参数，指明类型。类型无限制。 * 分配指定类型的内存，并设置为该类型的零值。 * 返回指向这块新分配内存的<strong>指针</strong>。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%v\n&quot;</span>, a, a, *a)</span><br><span class="line"><span class="comment">// *int    0xc0000b2008    0</span></span><br><span class="line">b := <span class="built_in">new</span>(<span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%v\n&quot;</span>, b, b, *b)</span><br><span class="line"><span class="comment">// *bool   0xc0000b2018    false</span></span><br><span class="line">c := <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%v\t%d\n&quot;</span>, c, c, *c, <span class="built_in">len</span>(*c))</span><br><span class="line"><span class="comment">// *map[string]bool        &amp;map[]  map[]   0</span></span><br><span class="line">d := <span class="built_in">new</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%v\t%d\n&quot;</span>, d, d, *d, <span class="built_in">cap</span>(*d))</span><br><span class="line"><span class="comment">// *chan bool      0xc0000ac028    &lt;nil&gt;   0</span></span><br></pre></td></tr></table></figure>
<h2 id="实现原理">实现原理</h2>
<h3 id="make"><code>make</code></h3>
<p>编译时，编译器会对类型进行类型检查。在这个阶段，会根据 <code>make</code> 的第一个参数，将 <code>make</code> 在语法树上对应的 <code>OMAKE</code> 节点转换成 <code>OMAKESLICE</code>（切片）、<code>OMAKEMAP</code>（map）、<code>OMAKECHAN</code>（channel），并对 <code>make</code> 函数的剩余参数进行合法性校验。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数在 src/cmd/compile/internal/gc/typecheck.go 中定义</span></span><br><span class="line"><span class="comment">// 用来检查常量、类型、函数声明以及变量赋值语句的类型</span></span><br><span class="line"><span class="comment">// 这里一个 Node 指的是语法树上的一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="keyword">int</span>)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">// op 在 src/cmd/compile/internal/gc/syntax.go 中定义</span></span><br><span class="line">    <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">    <span class="keyword">case</span> OMAKE:</span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line">        <span class="comment">// 获取 make 函数的参数列表</span></span><br><span class="line">		args := n.List.Slice()</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">			yyerror(<span class="string">&quot;missing argument to make&quot;</span>)</span><br><span class="line">			n.Type = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span> n</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 获取第一个参数</span></span><br><span class="line">		n.List.Set(<span class="literal">nil</span>)</span><br><span class="line">		l := args[<span class="number">0</span>]</span><br><span class="line">		l = typecheck(l, ctxType)</span><br><span class="line">		t := l.Type</span><br><span class="line">		<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">			n.Type = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span> n</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		i := <span class="number">1</span></span><br><span class="line">		<span class="keyword">switch</span> t.Etype &#123;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TSLICE: <span class="comment">// 切片类型</span></span><br><span class="line">            <span class="comment">// 进行参数校验</span></span><br><span class="line">            <span class="comment">// 参数数量校验：至少要有两个参数，最多三个参数</span></span><br><span class="line">			<span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(args) &#123;</span><br><span class="line">				yyerror(<span class="string">&quot;missing len argument to make(%v)&quot;</span>, t)</span><br><span class="line">				n.Type = <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 这里的 l 就是长度，r 是容量（如果指定的话）</span></span><br><span class="line">            <span class="comment">// 参数合法性校验</span></span><br><span class="line">			l = args[i]</span><br><span class="line">			i++</span><br><span class="line">			l = typecheck(l, ctxExpr)</span><br><span class="line">			<span class="keyword">var</span> r *Node</span><br><span class="line">			<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(args) &#123;</span><br><span class="line">				r = args[i]</span><br><span class="line">				i++</span><br><span class="line">				r = typecheck(r, ctxExpr)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> l.Type == <span class="literal">nil</span> || (r != <span class="literal">nil</span> &amp;&amp; r.Type == <span class="literal">nil</span>) &#123;</span><br><span class="line">				n.Type = <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !checkmake(t, <span class="string">&quot;len&quot;</span>, l) || r != <span class="literal">nil</span> &amp;&amp; !checkmake(t, <span class="string">&quot;cap&quot;</span>, r) &#123;</span><br><span class="line">				n.Type = <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果指定了长度和容量，则要求 长度 &lt;= 容量</span></span><br><span class="line">			<span class="keyword">if</span> Isconst(l, CTINT) &amp;&amp; r != <span class="literal">nil</span> &amp;&amp; Isconst(r, CTINT) &amp;&amp; l.Val().U.(*Mpint).Cmp(r.Val().U.(*Mpint)) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				yyerror(<span class="string">&quot;len larger than cap in make(%v)&quot;</span>, t)</span><br><span class="line">				n.Type = <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			n.Left = l</span><br><span class="line">			n.Right = r</span><br><span class="line">			n.Op = OMAKESLICE <span class="comment">// 修改当前节点的操作 op</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TMAP: <span class="comment">// map 类型</span></span><br><span class="line">            <span class="comment">// 参数数量：最少一个，最多两个</span></span><br><span class="line">			<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(args) &#123;</span><br><span class="line">                <span class="comment">// 如果指定了第二个参数，则当成 map 的初始大小。</span></span><br><span class="line">				l = args[i]</span><br><span class="line">				i++</span><br><span class="line">				l = typecheck(l, ctxExpr)</span><br><span class="line">				l = defaultlit(l, types.Types[TINT])</span><br><span class="line">				<span class="keyword">if</span> l.Type == <span class="literal">nil</span> &#123;</span><br><span class="line">					n.Type = <span class="literal">nil</span></span><br><span class="line">					<span class="keyword">return</span> n</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> !checkmake(t, <span class="string">&quot;size&quot;</span>, l) &#123;</span><br><span class="line">					n.Type = <span class="literal">nil</span></span><br><span class="line">					<span class="keyword">return</span> n</span><br><span class="line">				&#125;</span><br><span class="line">				n.Left = l</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果没有指定第二个参数，则默认大小为 0</span></span><br><span class="line">				n.Left = nodintconst(<span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			n.Op = OMAKEMAP <span class="comment">// 修改当前节点的操作 op</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> TCHAN: <span class="comment">// channel 类型</span></span><br><span class="line">            l = <span class="literal">nil</span></span><br><span class="line">            <span class="comment">// 参数数量：最少一个，最多两个</span></span><br><span class="line">			<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(args) &#123;</span><br><span class="line">                <span class="comment">// 如果有第二个参数，则表示该 channel 的缓冲区大小</span></span><br><span class="line">				l = args[i]</span><br><span class="line">				i++</span><br><span class="line">				l = typecheck(l, ctxExpr)</span><br><span class="line">				l = defaultlit(l, types.Types[TINT])</span><br><span class="line">				<span class="keyword">if</span> l.Type == <span class="literal">nil</span> &#123;</span><br><span class="line">					n.Type = <span class="literal">nil</span></span><br><span class="line">					<span class="keyword">return</span> n</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> !checkmake(t, <span class="string">&quot;buffer&quot;</span>, l) &#123;</span><br><span class="line">					n.Type = <span class="literal">nil</span></span><br><span class="line">					<span class="keyword">return</span> n</span><br><span class="line">				&#125;</span><br><span class="line">				n.Left = l</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有第二个参数，则默认 channel 缓冲区大小为 0</span></span><br><span class="line">				n.Left = nodintconst(<span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			n.Op = OMAKECHAN <span class="comment">// 修改当前节点的操作 op</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(args) &#123; <span class="comment">// 如果参数个数不符合类型要求，则报错。</span></span><br><span class="line">			yyerror(<span class="string">&quot;too many arguments to make(%v)&quot;</span>, t)</span><br><span class="line">			n.Op = OMAKE</span><br><span class="line">			n.Type = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span> n</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		n.Type = t</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/20200323183935.jpg" /></p>
<h3 id="new"><code>new</code></h3>
<p>编译时，在生成中间代码之前，需要对语法树中的一些节点进行替换。此时，对于 <code>new</code> 函数调用，也就是对应的 <code>ONEW</code> 节点，会将其转化成 <code>ONEWOBJ</code> 节点。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/gc/walk.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkexpr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">case</span> ONEW:</span><br><span class="line">		<span class="keyword">if</span> n.Esc == EscNone &#123; <span class="comment">// 对于不会逃逸到堆上的。这也说明了 new 方法可能会在栈上分配</span></span><br><span class="line">			<span class="keyword">if</span> n.Type.Elem().Width &gt;= maxImplicitStackVarSize &#123;</span><br><span class="line">				Fatalf(<span class="string">&quot;large ONEW with EscNone: %v&quot;</span>, n)</span><br><span class="line">			&#125;</span><br><span class="line">			r := temp(n.Type.Elem())</span><br><span class="line">			r = nod(OAS, r, <span class="literal">nil</span>) <span class="comment">// zero temp</span></span><br><span class="line">			r = typecheck(r, ctxStmt)</span><br><span class="line">			init.Append(r)</span><br><span class="line">			r = nod(OADDR, r.Left, <span class="literal">nil</span>)</span><br><span class="line">			r = typecheck(r, ctxExpr)</span><br><span class="line">			n = r</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 转换成 ONEWOBJ 节点</span></span><br><span class="line">			n = callnew(n.Type.Elem())</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callnew</span><span class="params">(t *types.Type)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    n := nod(ONEWOBJ, typename(t), <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 指针类型</span></span><br><span class="line">	n.Type = types.NewPtr(t)</span><br><span class="line">	n.SetTypecheck(<span class="number">1</span>)</span><br><span class="line">	n.SetNonNil(<span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在接下来的 SSA 生成阶段，会根据申请空间的大小进行不同的处理： * 如果申请的大小为 0，则会返回一个表示空指针的 <code>zerobase</code> 变量 * 否则，则转换成 <code>runtime.newobject</code> 函数调用 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/gc/ssa.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">expr</span><span class="params">(n *Node)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> ONEWOBJ:</span><br><span class="line">		<span class="keyword">if</span> n.Type.Elem().Size() == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> s.newValue1A(ssa.OpAddr, n.Type, zerobaseSym, s.sb)</span><br><span class="line">		&#125;</span><br><span class="line">		typ := s.expr(n.Left)</span><br><span class="line">		vv := s.rtcall(newobject, <span class="literal">true</span>, []*types.Type&#123;n.Type&#125;, typ)</span><br><span class="line">        <span class="keyword">return</span> vv[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>runtime.newobject</code> 函数在 <code>src/runtime/malloc.go</code> 中定义，它会根据传入类型所占用的空间大小，调用 <code>runtime.mallocgc</code> 函数，在堆上申请内存，然后返回指向这个内存空间的指针。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// implementation of new builtin</span></span><br><span class="line"><span class="comment">// compiler (both frontend and SSA backend) knows the signature</span></span><br><span class="line"><span class="comment">// of this function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/20200323183936.jpg" /></p>
<h2 id="总结">总结</h2>
<ul>
<li><code>make</code> 和 <code>new</code> 的相同点：都是用来申请内存</li>
<li><code>make</code> 和 <code>new</code> 的不同点
<ul>
<li><code>make</code> 只能用来创建类型为 slice / map / chan 的数据结构，返回的是指定类型的对象</li>
<li><code>new</code> 可以接受任意类型，返回的是指向这个类型的一个内存空间的指针</li>
</ul></li>
<li><code>make</code> 的实现过程：在类型检查阶段，根据第一个参数，将 <code>OMAKE</code> 节点转换成<code>OMAKESLICE</code>（切片）、<code>OMAKEMAP</code>（map）、<code>OMAKECHAN</code>（channel）</li>
<li><code>new</code> 的实现过程：在中间代码生成阶段，（当需要在堆上分配时）将 <code>ONEW</code> 节点转换成 <code>ONEWOBJ</code>，然后（当申请的大小不为0时）在运行时调用 <code>newobject</code> 函数，利用 <code>mallocgc</code> 函数来分配内存。</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/">make 和 new</a></li>
</ul>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Go | 内存管理：内存分配</title>
    <url>/2020/04/20/dive-into-go-memory-alloc/</url>
    <content><![CDATA[<blockquote>
<p>基于 Go 1.14 <img src="/img/divego_memory_0.svg" /></p>
</blockquote>
<p>Golang 的内存分配器借鉴了 TCMalloc，在多级缓存的基础上，根据对象大小所属类别，实施不同分配策略。</p>
<h2 id="内存管理">内存管理</h2>
<h3 id="管理组件">管理组件</h3>
<ul>
<li>内存管理单元 <code>runtime.mspan</code>：Go 语言内存管理的基本单元，管理多个页
<ul>
<li>页大小：8KB</li>
</ul></li>
<li>线程缓存 <code>runtime.mcache</code>：与线程上的处理器一一绑定，无需锁</li>
<li>中心缓存 <code>runtime.mcentral</code>：需要锁</li>
<li>页堆 <code>runtime.mheap</code>：一个 Go 语言程序只会存在一个全局的页堆</li>
</ul>
<p><img src="/img/divego_memory_alloc_0.svg" /></p>
<h3 id="管理">管理</h3>
<p>从线程缓存到操作系统内存，遵循一种模式： * 如果在当前内存管理组件获取不到可用内存，则会向下一级组件申请内存并进行扩容 * 如果最后到操作系统都申请不到内存的话，则说明宿主机上内存耗尽，程序会终止。</p>
<p><img src="/img/divego_memory_alloc_2.svg" /></p>
<h2 id="内存分配">内存分配</h2>
<p>堆上所有的对象都会通过 <code>runtime.newobject()</code> 来分配内存。</p>
<p>根据申请对象的大小执行不同的策略： * 微对象 <code>0 &lt; size &lt; 16B</code>：线程缓存中的微对象分配器 ——&gt; 线程缓存 ——&gt; 中心缓存 ——&gt; 页堆 * 小对象 <code>16B &lt;= size &lt;= 32KB</code>：线程缓存 ——&gt; 中心缓存 ——&gt; 页堆 * 大对象 <code>size &gt; 32KB</code>：直接在堆上进行分配</p>
<p><img src="/img/divego_memory_alloc_3.svg" /></p>
<h2 id="附">附</h2>
<h3 id="内存管理组件代码">内存管理组件代码</h3>
<p><img src="/img/divego_memory_alloc_1.svg" /></p>
<h3 id="参考">参考：</h3>
<ul>
<li><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#712-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BB%84%E4%BB%B6">内存分配器 by draveness</a></li>
</ul>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>译|Python的隐藏特性(下)</title>
    <url>/2015/09/28/%5B%E8%AF%91%5DPython%E7%9A%84%E9%9A%90%E8%97%8F%E7%89%B9%E6%80%A7(%E4%B8%8B)/</url>
    <content><![CDATA[<p>知乎上有人问了一个问题：Python有哪些新手不会了解的深入细节。 其中的一个答案引用了stackoverflow上的一个问题解答。 鉴于一直在努力摆脱Python小白，决定好好研究下这几个特性，顺手翻译一下下，扩展一下下~~</p>
<p>原文：<a href="http://stackoverflow.com/questions/101268/hidden-features-of-python">Hidden features of Python</a></p>
<h2 id="list-stepping"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#101840">List stepping</a></h2>
<p>切片操作符中的步长(step)参数。例如： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">2</span>]  <span class="comment"># iterate over the whole list in 2-increments</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure> 特殊例子<code>x[::-1]</code>对'x反转'来说相当有用。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::-<span class="number">1</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure> ### 碎碎念 当然，你可以使用<code>reversed()</code>函数来实现反转。 区别在于，<code>reversed()</code>返回一个迭代器，所以还需要一个额外的步骤来将结果转换成需要的对象类型。 这个特性在判断例如回文的时候灰常有用，一句话搞定 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span> <span class="keyword">if</span> someseq == someseq[::-<span class="number">1</span>] <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure> 今天看到了一个很有意思的东西。拿上面的例子来讲，猜猜<code>a[10::]</code>会输出什么呢？ 如果你猜是<code>IndexError</code>，那就错了。答案是，<code>[]</code>。但是其实当你试图访问一个超过列表索引值的成员，例如<code>a[10]</code>时，确实会导致<code>IndexError</code>。但是，试图访问一个列表的以超出列表成员数作为开始索引的切片时，却会返回一个空列表.</p>
<h2 id="missing-items"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#112286"><strong>missing</strong> items</a></h2>
<p>从2.5开始，字典就有一个特别的方法<code>__missing__</code>，它在访问不存在的item时被引用： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyDict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line"><span class="meta">... </span> <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line"><span class="meta">... </span>  self[key] = rv = []</span><br><span class="line"><span class="meta">... </span>  <span class="keyword">return</span> rv</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = MyDict()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&quot;foo&quot;</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&quot;foo&quot;</span>].append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(m)</span><br><span class="line">&#123;<span class="string">&#x27;foo&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;</span><br></pre></td></tr></table></figure> 还有collections中一个叫做defaultdict的dict子函数跟它灰常像，但这个子类为不存在的item调用了一个无参函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&quot;foo&quot;</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="string">&quot;foo&quot;</span>].append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(m)</span><br><span class="line">&#123;<span class="string">&#x27;foo&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;</span><br></pre></td></tr></table></figure> 推荐在传给一个不接收这样的子类的函数前，先将这样的dict转换为常规的dict。许多代码使用d[a_key]，然后捕捉keyErrors来检查一个item是否存在，不存在则会在dict中新增一个item。</p>
<h3 id="碎碎念">碎碎念</h3>
<p>扩展阅读：<a href="http://kodango.com/defaultdict-in-python">defaultdict 和 dict.__missing__</a></p>
<h2 id="multi-line-regex"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#101537">Multi-line Regex</a></h2>
<p>在Python中，你可以将一个正则表达式拆分成多行，命名你的匹配和插入注释。 详细语法举例（参考<a href="http://diveintopython.net/regular_expressions/index.html">Dive into Python</a>）： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>^                   # beginning of string</span></span><br><span class="line"><span class="string"><span class="meta">... </span>M&#123;0,4&#125;              # thousands - 0 to 4 M&#x27;s</span></span><br><span class="line"><span class="string"><span class="meta">... </span>(CM|CD|D?C&#123;0,3&#125;)    # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 C&#x27;s),</span></span><br><span class="line"><span class="string"><span class="meta">... </span>                    #            or 500-800 (D, followed by 0 to 3 C&#x27;s)</span></span><br><span class="line"><span class="string"><span class="meta">... </span>(XC|XL|L?X&#123;0,3&#125;)    # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 X&#x27;s),</span></span><br><span class="line"><span class="string"><span class="meta">... </span>                    #        or 50-80 (L, followed by 0 to 3 X&#x27;s)</span></span><br><span class="line"><span class="string"><span class="meta">... </span>(IX|IV|V?I&#123;0,3&#125;)    # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 I&#x27;s),</span></span><br><span class="line"><span class="string"><span class="meta">... </span>                    #        or 5-8 (V, followed by 0 to 3 I&#x27;s)</span></span><br><span class="line"><span class="string"><span class="meta">... </span>$                   # end of string</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(pattern, <span class="string">&#x27;M&#x27;</span>, re.VERBOSE)</span><br></pre></td></tr></table></figure> 命名匹配举例（参考<a href="http://www.amk.ca/python/howto/regex/">Regular Expression HOWTO</a>） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(?P&lt;word&gt;\b\w+\b)&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = p.search( <span class="string">&#x27;(((( Lots of punctuation )))&#x27;</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="string">&#x27;word&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Lots&#x27;</span></span><br></pre></td></tr></table></figure> 在字符串连接的帮助下，你还可以详尽编写一个正则表达式而不必使用<code>re.VERBOSE</code>. <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = (</span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;^&quot;</span>                 <span class="comment"># beginning of string</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;M&#123;0,4&#125;&quot;</span>            <span class="comment"># thousands - 0 to 4 M&#x27;s</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;(CM|CD|D?C&#123;0,3&#125;)&quot;</span>  <span class="comment"># hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 C&#x27;s),</span></span><br><span class="line"><span class="meta">... </span>                        <span class="comment">#            or 500-800 (D, followed by 0 to 3 C&#x27;s)</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;(XC|XL|L?X&#123;0,3&#125;)&quot;</span>  <span class="comment"># tens - 90 (XC), 40 (XL), 0-30 (0 to 3 X&#x27;s),</span></span><br><span class="line"><span class="meta">... </span>                        <span class="comment">#        or 50-80 (L, followed by 0 to 3 X&#x27;s)</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;(IX|IV|V?I&#123;0,3&#125;)&quot;</span>  <span class="comment"># ones - 9 (IX), 4 (IV), 0-3 (0 to 3 I&#x27;s),</span></span><br><span class="line"><span class="meta">... </span>                        <span class="comment">#        or 5-8 (V, followed by 0 to 3 I&#x27;s)</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;$&quot;</span>                 <span class="comment"># end of string</span></span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> pattern</span><br><span class="line"><span class="string">&quot;^M&#123;0,4&#125;(CM|CD|D?C&#123;0,3&#125;)(XC|XL|L?X&#123;0,3&#125;)(IX|IV|V?I&#123;0,3&#125;)$&quot;</span></span><br></pre></td></tr></table></figure> ### 碎碎念 可以在正则中加注释是很棒的。至少让其他人很容易就看懂了这个正则是干什么的。</p>
<h2 id="named-string-formatting"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#113164">Named string formatting</a></h2>
<p>%-格式化接收一个字典（也适用于%i%s等） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&quot;The %(foo)s is %(bar)i.&quot;</span> % &#123;<span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;answer&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>:<span class="number">42</span>&#125;</span><br><span class="line">The answer <span class="keyword">is</span> <span class="number">42.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo, bar = <span class="string">&#x27;question&#x27;</span>, <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&quot;The %(foo)s is %(bar)i.&quot;</span> % <span class="built_in">locals</span>()</span><br><span class="line">The question <span class="keyword">is</span> <span class="number">123.</span></span><br></pre></td></tr></table></figure> 而由于<code>locals()</code>也是一个字典，你可以简单的将其当做一个dict来传递，并从本地变量中获得%-字符串替换。虽然它令人难以接受，但是简化了操作。 新的格式化风格 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&quot;The &#123;foo&#125; is &#123;bar&#125;&quot;</span>.<span class="built_in">format</span>(foo=<span class="string">&#x27;answer&#x27;</span>, bar=<span class="number">42</span>))</span><br></pre></td></tr></table></figure> ### 碎碎念 看来<code>format</code>方法还是更被人推崇的，可能就是因为%-格式化方法能做的事它都可以做到，并且比%-格式化方法更漂亮的缘故吧。 但是，就速度来说，%-格式化方法会比<code>str.format</code>方法快。</p>
<h2 id="nested-listgenerator-comprehensions"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#101549">Nested list/generator comprehensions</a></h2>
<p>嵌套列表推导和生成器表达式： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(i,j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i) ]    </span><br><span class="line">((i,j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i) )</span><br></pre></td></tr></table></figure> 这些可以替代大块大块的嵌套循环代码</p>
<h3 id="碎碎念-1">碎碎念</h3>
<p>前面也提到过了，这两个是由空间使用上的区别。另外，它们生成的东东也不一样哦~</p>
<h2 id="new-types-at-runtime"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#108297">New types at runtime</a></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>NewType = <span class="built_in">type</span>(<span class="string">&quot;NewType&quot;</span>, (<span class="built_in">object</span>,), &#123;<span class="string">&quot;x&quot;</span>: <span class="string">&quot;hello&quot;</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = NewType()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n.x</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>它与下面完全一样 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">NewType</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    x = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = NewType()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n.x</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure> 它可能不是最优用的特性，但知道有这么一个东东也是很棒的。</p>
<h3 id="碎碎念-2">碎碎念</h3>
<p>注意，所有的类都是在运行时创建的。因此，你可以在一个条件，或者在一个函数中使用'class'语句。而<code>type</code>的使用，则是给你提供了一个简洁的动态定义一个生成一堆属性的类的方式。 可以定义一个匿名类。例如：<code>type('', (object,), &#123;'x': 'blah'&#125;)</code> 可以在定义类的同时实例化。例如：<code>x = type("X", (object,), &#123;'val':'Hello'&#125;)()</code> 再扩展一下下。<code>type</code>这个东东，还可以用来创建高大上的metaclasses（元类）。</p>
<h2 id="pth-files"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#113833">.pth files</a></h2>
<p>为了添加更多的python模块（特别是第三方模块），大部分人似乎都会使用PYTHONPATH环境变量，或者在他们的site-packages目录中增加符号链接或目录。另一种方法是使用*.pth文件。下面是python官方文档的解释： “修改python搜索路径最方便的方法是将一个路径配置文件添加到已经存在于python搜索路径中的目录下，通常是.../site-packages/目录。路径配置文件有<code>.pth</code>扩展名，并且每一行必须包含一个会添加到sys.pah的单一路径。（因为新的路径将会追加到sys.path中，新增的目录下的模块将不会覆盖掉标准模块。这意味着你不能使用这个机制来安装标准模块的修正版本。）”</p>
<h3 id="碎碎念-3">碎碎念</h3>
<p>引用<a href="http://www.elias.cn/Python/PythonPath?from=Develop.PythonPath">如何方便地给Python环境注册新类库</a>: 原理上， Python 运行环境查找库文件时本质是对 sys.path 列表的遍历，如果我们想给运行环境注册新的类库进来， 要么得用代码给 sys.path 列表增加新路径； 要么得调整 PYTHONPATH 环境变量； 要么就得把库文件复制到已经在 sys.path 设置中的路径中去（比如 site-packages 目录）； 最简单的办法是用 .pth 文件来实现。Python 在遍历已知的库文件目录过程中，如果见到一个 .pth 文件，就会将文件中所记录的路径加入到 sys.path 设置中，于是 .pth 文件说指明的库也就可以被 Python 运行环境找到了。 python模块的绿色安装方法：只要将模块路径写入.pth文件中并把此文件放在正确的sys.path路径下即可。</p>
<h2 id="rot13-encoding"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#1024693">ROT13 Encoding</a></h2>
<p>对源代码来说，当你在代码文件顶部使用正确的编码声明时，ROT13是一种有效的编码。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: rot13 -*-</span></span><br><span class="line"></span><br><span class="line">cevag <span class="string">&quot;Uryyb fgnpxbiresybj!&quot;</span>.rapbqr(<span class="string">&quot;rot13&quot;</span>)</span><br><span class="line">cevag h<span class="string">&quot;Uryyb fgnpxbiresybj!&quot;</span></span><br></pre></td></tr></table></figure> ### 碎碎念 上面例子的运行结果都是：<code>Hello stackoverflow!</code> 这个特性貌似在py3k中被移除了~~ 当然，有小伙伴提出来了邪恶的想法，可以用来对付反病毒工具……</p>
<h2 id="regex-debugging"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#143636">Regex Debugging</a></h2>
<p>正则表达式是python的一个很棒的特性，但是调试它们却是一件痛不欲生的事，然而，我们相当容易犯关于正则的错误Orz…… 幸运的是，通过传递一个未公开的实验性的隐藏标记<code>re.DEBUG</code>(实际上是，128)给<code>re.compile</code>函数，python可以打印正则解析树， <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.<span class="built_in">compile</span>(<span class="string">&quot;^\[font(?:=(?P&lt;size&gt;[-+][0-9]&#123;1,2&#125;))?\](.*?)[/font]&quot;</span>,</span><br><span class="line">    re.DEBUG)</span><br><span class="line">at at_beginning</span><br><span class="line">literal <span class="number">91</span></span><br><span class="line">literal <span class="number">102</span></span><br><span class="line">literal <span class="number">111</span></span><br><span class="line">literal <span class="number">110</span></span><br><span class="line">literal <span class="number">116</span></span><br><span class="line">max_repeat <span class="number">0</span> <span class="number">1</span></span><br><span class="line">  subpattern <span class="literal">None</span></span><br><span class="line">    literal <span class="number">61</span></span><br><span class="line">    subpattern <span class="number">1</span></span><br><span class="line">      <span class="keyword">in</span></span><br><span class="line">        literal <span class="number">45</span></span><br><span class="line">        literal <span class="number">43</span></span><br><span class="line">      max_repeat <span class="number">1</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">in</span></span><br><span class="line">          <span class="built_in">range</span> (<span class="number">48</span>, <span class="number">57</span>)</span><br><span class="line">literal <span class="number">93</span></span><br><span class="line">subpattern <span class="number">2</span></span><br><span class="line">  min_repeat <span class="number">0</span> <span class="number">65535</span></span><br><span class="line">    <span class="built_in">any</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">  literal <span class="number">47</span></span><br><span class="line">  literal <span class="number">102</span></span><br><span class="line">  literal <span class="number">111</span></span><br><span class="line">  literal <span class="number">110</span></span><br><span class="line">  literal <span class="number">116</span></span><br></pre></td></tr></table></figure> 一旦你了解了语法，则可以发现错误。在这里，我们可以看到，错误是忘记在<code>[/font]</code>中去掉<code>[]</code>。 当然，你可以把它和任何你想要的标记组合在一起，例如注释正则： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.<span class="built_in">compile</span>(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">^              # start of a line</span></span><br><span class="line"><span class="string">\[font         # the font tag</span></span><br><span class="line"><span class="string">(?:=(?P&lt;size&gt;  # optional [font=+size]</span></span><br><span class="line"><span class="string">[-+][0-9]&#123;1,2&#125; # size specification</span></span><br><span class="line"><span class="string">))?</span></span><br><span class="line"><span class="string">\]             # end of tag</span></span><br><span class="line"><span class="string">(.*?)          # text between the tags</span></span><br><span class="line"><span class="string">\[/font\]      # end of the tag</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, re.DEBUG|re.VERBOSE|re.DOTALL)</span><br></pre></td></tr></table></figure> ### 碎碎念 虽然你也可以用128代替re.DEBUG，但是，为了可读性，还是推荐使用re.DEBUG。 另外，推荐一个可以解析正则表达式的网站：<a href="https://regex101.com/#python">regular expressions 101</a></p>
<h2 id="sending-to-generators"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#101739">Sending to Generators</a></h2>
<p><a href="http://www.python.org/dev/peps/pep-0342/">发送值到生成器函数</a>。例如下面这个函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mygen</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Yield 5 until something else is passed back via send()&quot;&quot;&quot;</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        f = (<span class="keyword">yield</span> a) <span class="comment">#yield a and possibly get f in return</span></span><br><span class="line">        <span class="keyword">if</span> f <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: </span><br><span class="line">            a = f  <span class="comment">#store the new value</span></span><br></pre></td></tr></table></figure> 你可以： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = mygen()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.<span class="built_in">next</span>()</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.<span class="built_in">next</span>()</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.send(<span class="number">7</span>)  <span class="comment">#we send this back to the generator</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.<span class="built_in">next</span>() <span class="comment">#now it will yield 7 until we send something else</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<h2 id="tab-completion-in-interactive-interpreter"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#168270">Tab Completion in Interactive Interpreter</a></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> readline</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Unable to load readline module.&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">import</span> rlcompleter</span><br><span class="line">    readline.parse_and_bind(<span class="string">&quot;tab: complete&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">myclass</span>:</span></span><br><span class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">function</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>      <span class="built_in">print</span> <span class="string">&quot;my function&quot;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>class_instance = myclass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>class_instance.&lt;TAB&gt;</span><br><span class="line">class_instance.__class__   class_instance.__module__</span><br><span class="line">class_instance.__doc__     class_instance.function</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>class_instance.f&lt;TAB&gt;unction()</span><br></pre></td></tr></table></figure>
<p>当然，你需要设置一个环境变量：PYTHONSTARTUP</p>
<h3 id="碎碎念-4">碎碎念</h3>
<p>噢，暂时还看不懂，~~~~(&gt;_&lt;)~~~~</p>
<h2 id="ternary-expression"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#116480">Ternary Expression</a></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3</span> <span class="keyword">if</span> (y == <span class="number">1</span>) <span class="keyword">else</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>上面这个语句会做这样的事：“将x赋值为3，如果y是1，否则将x赋值为2”。注意，括号不是必须的，但是有它们会使得代码更具可读性。如果你有更复杂的需求，也可以将它们串联起来： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3</span> <span class="keyword">if</span> (y == <span class="number">1</span>) <span class="keyword">else</span> <span class="number">2</span> <span class="keyword">if</span> (y == -<span class="number">1</span>) <span class="keyword">else</span> <span class="number">1</span></span><br></pre></td></tr></table></figure> 虽然在某种意义上，有点过分了。 注意，你可以在任何表达式中使用<code>if ... else</code>。例如： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(func1 <span class="keyword">if</span> y == <span class="number">1</span> <span class="keyword">else</span> func2)(arg1, arg2) </span><br></pre></td></tr></table></figure> 这里，当y为1时，func1将会被调用，否则，func2将会被调用。在这两种情况下，参数arg1和arg2都将会作为被调用的对应的函数的参数。 类似地，下面也是有效的： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = (class1 <span class="keyword">if</span> y == <span class="number">1</span> <span class="keyword">else</span> class2)(arg1, arg2)</span><br></pre></td></tr></table></figure> 这里，class1和class2是两个类。</p>
<h3 id="碎碎念-5">碎碎念</h3>
<p>常用的还有<code>return 3 if (y == 1) else 2</code> 上面第一个例子还有一种容易让人困惑的等价写法：<code>y == 1 and 3 or 2</code>。</p>
<h2 id="tryexceptelse"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#114157">try/except/else</a></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  put_4000000000_volts_through_it(parrot)</span><br><span class="line"><span class="keyword">except</span> Voom:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;&#x27;E&#x27;s pining!&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;This parrot is no more!&quot;</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  end_sketch()</span><br></pre></td></tr></table></figure>
<p>使用else从句比增加额外的代码在try子句中要好得多，因为它避免了无意中捕获到不是由try...except语句所保护的代码抛出的异常。</p>
<h3 id="碎碎念-6">碎碎念</h3>
<p>else语句块只有当try语句正常执行（也就是说，except语句未执行）的时候，才会执行。 python中的try/except/else/finally语句的语法如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">     Normal execution block</span><br><span class="line"><span class="keyword">except</span> A:</span><br><span class="line">     Exception A handle</span><br><span class="line"><span class="keyword">except</span> B:</span><br><span class="line">     Exception B handle</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">     Other exception handle</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">     <span class="keyword">if</span> no exception,get here</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">     this block will be excuted no matter how it goes above</span><br></pre></td></tr></table></figure> 扩展阅读： * <a href="http://www.cnblogs.com/windlazio/archive/2013/01/24/2874417.html">python中的try/except/else/finally语句</a></p>
<h2 id="with-statement"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#109182">with statement</a></h2>
<p><a href="http://www.python.org/dev/peps/pep-0343/">PEP 343</a>中引进的<a href="http://docs.python.org/library/stdtypes.html#context-manager-types">context manager</a>是一个将一套语句作为运行时上下文的对象。由于这个特性使用了一些新的关键字，因此它是被逐步推行的：在Python 2.5中通过<code>__future__</code>可用。Python 2.6及以上（包括Python 3）则默认可用。 会经常使用<a href="http://www.python.org/dev/peps/pep-0343/">with语句</a>，则是因为它是一个非常有用的结构。下面是一个快速演示： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> with_statement</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;foo.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;hello!&#x27;</span>)</span><br></pre></td></tr></table></figure> 在这个场景背后，则是<a href="http://www.python.org/dev/peps/pep-0343/">with语句</a>在file对象上调用特殊的<code>__enter__</code>和<code>__exit__</code>方法。如果在with语句体中发生了异常，异常细节也会传给<code>__exit__</code>，因此允许异常处理。 在这个特殊场景下，它为你所做的事是，保证了当执行到了with语句体之外时，file会被关闭，而忽略语句体正常结构或是否抛出了异常。它基本上是一种抽象出公用异常处理代码的方式。 其他常用场景包括线程锁和数据库事务锁。</p>
<h3 id="碎碎念-7">碎碎念</h3>
<p>支持多个with形式，例如：<code>with open('filea') as filea, open('fileb') as fileb:...</code></p>
<p>扩展阅读： * <a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/">浅谈 Python 的 with 语句</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Go | 内存管理：垃圾收集（GC）</title>
    <url>/2020/04/25/dive-into-go-memory-gc/</url>
    <content><![CDATA[<blockquote>
<p>基于 Go 1.14</p>
</blockquote>
<h2 id="概述">概述</h2>
<p>用户程序（Mutator）通过内存分配器（Allocator）在堆（Heap）上申请内存空间，而垃圾收集器（Collector）则负责回收不再使用的对象和内存空间。 <img src="/img/divego_memory_gc_0.svg" /></p>
<h3 id="标记清除mark-sweep算法">标记清除（Mark-Sweep）算法</h3>
<p>标记清除算法是最常见的垃圾收集算法，分为标记阶段和清除阶段。在整个垃圾收集的过程中，用户程序都是处于暂停（Stop the world, STW）状态。 <img src="/img/divego_memory_gc_1.svg" /></p>
<h3 id="三色标记法">三色标记法</h3>
<p>为了解决原始的标记清除算法带来的长时间 STW 问题，三色标记法应运而生，它能缩短 STW 的时间。</p>
<p><img src="/img/divego_memory_gc_2.svg" /></p>
<h3 id="增量垃圾收集和并发垃圾收集">增量垃圾收集和并发垃圾收集</h3>
<p>为了减少应用程序暂停的最长时间以及垃圾收集的总暂停时间，会使用增量垃圾收集或者并发垃圾收集这两种策略来优化垃圾收集器。</p>
<p><img src="/img/divego_memory_gc_3.svg" /></p>
<h3 id="go-语言垃圾收集器的演进过程">Go 语言垃圾收集器的演进过程</h3>
<p><img src="/img/divego_memory_gc_4.svg" /></p>
<h2 id="go-语言的具体实现">Go 语言的具体实现</h2>
<p><img src="/img/divego_memory_gc_5.svg" /></p>
<h3 id="涉及的一些结构体和全局变量">涉及的一些结构体和全局变量</h3>
<p><img src="/img/divego_memory_gc_6.svg" /></p>
<h3 id="垃圾收集的触发">垃圾收集的触发</h3>
<p><img src="/img/divego_memory_gc_7.svg" /></p>
<h3 id="垃圾收集的启动">垃圾收集的启动</h3>
<p><img src="/img/divego_memory_gc_8.svg" /></p>
<h3 id="标记阶段">标记阶段</h3>
<p><img src="/img/divego_memory_gc_9.svg" /></p>
<h3 id="标记终止">标记终止</h3>
<p><img src="/img/divego_memory_gc_10.svg" /></p>
<h3 id="内存清理">内存清理</h3>
<p><img src="/img/divego_memory_gc_11.svg" /></p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#722-%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B">垃圾收集器 by draveness</a></li>
</ul>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Go | 调度：GMP 模型（第一部分）</title>
    <url>/2020/04/13/dive-into-go-schedule-gpm-part1/</url>
    <content><![CDATA[<blockquote>
<p>以下基于 Go 1.14</p>
</blockquote>
<p><img src="/img/divego_schedule_gmp_0.svg" /></p>
<p>Golang 中的调度是基于 GMP 模型来实现的： * G：表示 Goroutine，一个待执行的任务。 * 它对于 Go 运行时调度可以看做线程对于操作系统调度 * 在 Go 语言中使用 <code>runtime.g</code> 结构表示 * M：表示操作系统线程，由操作系统调度以及管理 * 调度器最多可以创建 10000 个线程，最多只会有 <code>GOMAXPROCS</code> 个活跃活跃线程 * 在 Go 语言中使用 <code>runtime.m</code> 结构表示 * P：表示处理器 * Go 程序的处理器数量一定是 <code>GOMAXPROCS</code> 个，在调度器启动的时候就会创建 * 在 Go 语言中使用 <code>runtime.p</code> 结构表示</p>
<p>一些全局变量说明：</p>
<p><img src="/img/divego_schedule_gmp_globalvar.svg" /></p>
<h2 id="附数据结构">附：数据结构</h2>
<p><img src="/img/divego_schedule_gmp_datastruct.svg" /></p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Go | 调度：GMP 模型（第三部分）</title>
    <url>/2020/04/14/dive-into-go-schedule-gpm-part3/</url>
    <content><![CDATA[<p><img src="/img/divego_schedule_gmp_schedtrig.svg" /></p>
<blockquote>
<p>以下基于 Go 1.14</p>
</blockquote>
<p>Go 程序中，在下面几种情况下都有可能触发调度（即调用 <code>runtime.schedule()</code>）： * 创建一个新的线程时 * goroutine 执行结束的时候 * 主动挂起 * 协作式调度 * 基于函数调用的抢占式调度 * 基于信号的抢占式调度（Go 1.14 新特性） * 系统调用</p>
<p>前面已经提到过前面两种，下面看下其他几种情况的行为方式。</p>
<h3 id="主动挂起">主动挂起</h3>
<p>当有诸如 <code>time.Sleep()</code>、锁、channel 之类的操作时，就会主动挂起 goroutine。而 goroutine 的主动挂起和唤醒分别是通过 <code>runtime.gopark()</code> 和 <code>runtime.goready()</code> 实现的：</p>
<p><img src="/img/divego_schedule_gmp_gopark.svg" /></p>
<h3 id="系统调用">系统调用</h3>
<p>不是所有的系统调用都会触发调度，只有那些需要运行时参与的系统调用（<code>syscall.Syscall()</code>）才有可能触发调度：</p>
<p><img src="/img/divego_schedule_gmp_syscall.svg" /></p>
<h3 id="协作式调度">协作式调度</h3>
<p>协作式调度指的是 goroutine 主动让出处理器，从而允许其他 goroutine 运行：</p>
<p><img src="/img/divego_schedule_gmp_gosched.svg" /></p>
<h3 id="抢占式调度">抢占式调度</h3>
<p>Go 语言的抢占式调度是在分段栈的机制上实现的。编译器会在分段栈上插入函数，这样，所有的 goroutine 在进行函数调用的时候都有机会进入运行时检查是否需要抢占。</p>
<p>但是，这种机制对于诸如轮询计算这种没有函数调用的 goroutine 来说，是无法抢占成功的。因此，Go 1.14 版本引入了基于信号的抢占式调度。</p>
<p><img src="/img/divego_schedule_gmp_gopreempt.svg" /></p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Go | 内存管理：栈</title>
    <url>/2020/04/26/dive-into-go-memory-stack/</url>
    <content><![CDATA[<blockquote>
<p>基于 Go 1.14</p>
</blockquote>
<p>应用程序的内存分为： * 堆区。程序在运行期间可以主动向堆区申请内存，这些内存由内存分配器分配并由垃圾收集器负责回收。 * 栈区。由编译器自动进行分配和释放，存储函数的入参以及局部变量。这些参数会随着函数的创建而创建，函数的返回而消亡。</p>
<p>Go 语言使用 goroutine 作为执行上下文，而 goroutine 的初始栈内存时 2KB，比线程小很多。</p>
<h2 id="分段栈">分段栈</h2>
<p><img src="/img/divego_memory_stack_1.svg" /></p>
<h2 id="连续栈">连续栈</h2>
<p>Go 1.3 开始使用的栈策略，不再将栈分段。 <img src="/img/divego_memory_stack_2.svg" /></p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#%E6%A0%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4">栈内存管理 by draveness</a></li>
</ul>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Go | panic 和 recover</title>
    <url>/2020/04/01/dive-into-go-panic-recover/</url>
    <content><![CDATA[<p>golang 中使用了以下两个内置函数来处理错误和恢复：</p>
<p><code>func panic(v interface&#123;&#125;)</code>： * 一旦调用： * 立刻停止执行函数其他代码 * 执行结束后，在当前 Goroutine 中递归执行调用方的延迟函数调用 defer * 允许在 defer 中嵌套多次调用</p>
<p><code>func recover() interface&#123;&#125;</code>： * 用于中止 panic 造成的程序崩溃 * 只能在 defer 中发挥作用（只有在 panic 之后调用才生效）</p>
<blockquote>
<p>基于 Go 1.14</p>
</blockquote>
<h3 id="数据结构">数据结构</h3>
<p><code>panic</code> 关键字在 golang 中由数据结构 <code>runtime._panic</code> 表示： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A _panic holds information about an active panic.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is marked go:notinheap because _panic values must only ever</span></span><br><span class="line"><span class="comment">// live on the stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The argp and link fields are stack pointers, but don&#x27;t need special</span></span><br><span class="line"><span class="comment">// handling during stack growth: because they are pointer-typed and</span></span><br><span class="line"><span class="comment">// _panic values only live on the stack, regular stack pointer</span></span><br><span class="line"><span class="comment">// adjustment takes care of them.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:notinheap</span></span><br><span class="line"><span class="keyword">type</span> _panic <span class="keyword">struct</span> &#123;</span><br><span class="line">	argp      unsafe.Pointer <span class="comment">// 指向 panic 期间运行的 defer 调用的参数</span></span><br><span class="line">	arg       <span class="keyword">interface</span>&#123;&#125;    <span class="comment">// 调用 panic 时传入的参数</span></span><br><span class="line">	link      *_panic        <span class="comment">// 指向更早调用的 panic</span></span><br><span class="line">	pc        <span class="keyword">uintptr</span>        <span class="comment">// where to return to in runtime if this panic is bypassed</span></span><br><span class="line">	sp        unsafe.Pointer <span class="comment">// where to return to in runtime if this panic is bypassed</span></span><br><span class="line">	recovered <span class="keyword">bool</span>           <span class="comment">// 表示当前这个 panic 是否被 recover 恢复</span></span><br><span class="line">	aborted   <span class="keyword">bool</span>           <span class="comment">// 表示当前这个 panic 是否被强行终止</span></span><br><span class="line">	goexit    <span class="keyword">bool</span>          <span class="comment">// 当调用了 runtime.Goexit()，就会将该值修改为 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 编译时</p>
<p><img src="/img/divego_panic_recover_compile.svg" /></p>
<h3 id="运行时">运行时</h3>
<p><img src="/img/divego_panic_recover_runtime.svg" /></p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>GDA | 有关最小二乘估计的一些事</title>
    <url>/2021/01/26/gda-least-squares-adjustment/</url>
    <content><![CDATA[<h1 id="问题描述">问题描述</h1>
<p>假设我们有一组观测值： <span class="math display">\[
\underline{y_0} = \begin{bmatrix}y_{01}\\...\\y_{0i}\\...\\y_{0m}\end{bmatrix}  \in  \mathbb{R}^m
\]</span> 观测值之间相互独立。</p>
<p>我们想从中估算出一组未知参数： <span class="math display">\[
\underline{x} = \begin{bmatrix}x_1\\...\\x_i\\...\\x_n\end{bmatrix}  \in  \mathbb{R}^n \quad (n \le m \text{ for redundancy})
\]</span></p>
<h1 id="最小二乘估计least-squares-estimation">最小二乘估计（Least Squares Estimation）</h1>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>最小二乘法，又称最小平方法，是一种数学优化建模方法。它通过最小化误差的平方和寻找数据的最佳函数匹配。 利用最小二乘法可以简便的求得未知的数据，并使得求得的数据与实际数据之间误差的平方和为最小。 “最小二乘法”是对线性方程组，即方程个数比未知数更多的方程组，以回归分析求得近似解的标准方法。</p>
<p>—— 维基百科</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<h2 id="数据模型">数据模型</h2>
<p>假设 <span class="math inline">\(\underline{y_0}\)</span> 是 <span class="math inline">\(\underline{y}\)</span> 的一组观测值，而 <span class="math inline">\(\underline{y}\)</span> 和 <span class="math inline">\(\underline{x}\)</span> 之间为线性关系： <span class="math display">\[\begin{aligned}
\underline{y} = A\underline{x}+\underline{b} \\
\text{其中, } A: \text{ design matrix} \quad \underline{b}: \text{ known term}
\end{aligned}\]</span></p>
<p>假设 <span class="math inline">\(\underline{y_0}\)</span> 和 <span class="math inline">\(\underline{y}\)</span> 之间存在误差 <span class="math inline">\(\underline{\varepsilon}\)</span>，即： <span class="math display">\[\begin{aligned}
\underline{y_0} = \underline{y} + \underline{\varepsilon} = A\underline{x}+\underline{b} + \underline{\varepsilon}\\
\text{其中, }\underline{\varepsilon}: \text{ unknown error} \\
\end{aligned}\]</span></p>
<p>根据<a href="https://zh.wikipedia.org/zh-hans/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86">中心极限定理</a>以及<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B">大数定理</a>，假设： <span class="math display">\[\begin{aligned}
\underline{\varepsilon}   \backsim N(0, \sigma_0^2Q) \\
\text{其中, } \sigma_0^2: \text{a prior variance} \quad Q: \text{ cofactor matrix} 
\end{aligned}\]</span></p>
<p>因此，问题转换为，求得 <span class="math inline">\(\hat{\underline{x}}\)</span> 和 <span class="math inline">\(\hat{\underline{y}}\)</span>，使其满足：</p>
<p><span class="math display">\[\begin{aligned}
\left\{\begin{matrix}
\hat{\underline{y}}=A\hat{\underline{x}}+\underline{b}\\ 
\hat{\underline{y}} \textbf{ at minimal distance from } \underline{y_0} \Rightarrow (\hat{\underline{y}}-\underline{y_0})^TQ^{-1}(\hat{\underline{y}}-\underline{y_0}): minimum \quad (\text{stochastic distance})
\end{matrix}\right.
\end{aligned}\]</span></p>
<h3 id="非线性场景">非线性场景</h3>
<p>如果 <span class="math inline">\(\underline{y}\)</span> 和 <span class="math inline">\(\underline{x}\)</span> 之间为非线性关系，即 <span class="math inline">\(y = g(x)\)</span>，则首先，我们要将其线性化：</p>
<ol type="1">
<li>通过求解观测值等式来获取未知参数的近似值 <span class="math inline">\(\underline{\widetilde{x}}\)</span></li>
<li>计算雅可比矩阵(Jacobian Matrix)： <span class="math display">\[
J(\widetilde{x}) = \begin{bmatrix}
\frac{\partial g_1}{\partial x_1} &amp; \frac{\partial g_1}{\partial x_2} &amp; ... &amp; \frac{\partial g_1}{\partial x_n}\\ 
\frac{\partial g_2}{\partial x_1} &amp; \frac{\partial g_2}{\partial x_2} &amp; ... &amp; \frac{\partial g_2}{\partial x_n}\\ 
... &amp; ... &amp; ... &amp; ...\\ 
\frac{\partial g_m}{\partial x_1} &amp; \frac{\partial g_m}{\partial x_2} &amp; ... &amp; \frac{\partial g_m}{\partial x_n}
\end{bmatrix}_{\underline{\widetilde{x}}} \\
\]</span></li>
<li>模型转换成： <span class="math display">\[\begin{aligned}
y_0 = f(\widetilde{x}) + J(\widetilde{x})(x-\widetilde{x}) \\
\text{其中， } A = J, b = f(\widetilde{x})
\end{aligned}\]</span></li>
</ol>
<h2 id="求解">求解</h2>
<blockquote>
<p>说明：求最小值问题可以转换为求一阶导数为 0 的问题。这里省略推导过程，直接给出计算步骤.</p>
</blockquote>
<ol type="1">
<li>计算正规矩阵（Normal Matrix）：<span class="math inline">\(N = A^TQ^{-1}A\)</span></li>
<li>计算正规已知项（Normal Known Term）：<span class="math inline">\(\underline{t} = A^TQ^{-1}(\underline{y}_0 - \underline{b})\)</span></li>
<li>计算未知参数的估算解： <span class="math display">\[N\hat{\underline{x}} = A^TQ^{-1}A\hat{\underline{x}} = A^TQ^{-1}(\underline{y}_0 - \underline{b}) = \underline{t} \quad \Rightarrow \quad \underline{\hat{x}} = N^{-1}\underline{t} = N^{-1}A^TQ^{-1}(\underline{y}_0 - \underline{b}) \qquad (\text{the normal system})\]</span></li>
<li>计算观测值的估算值：<span class="math inline">\(\underline{\hat{y}} = A\underline{\hat{x}} + \underline{b}\)</span></li>
<li>计算误差的估算值：<span class="math inline">\(\underline{\hat{\varepsilon}} = \underline{y}_0 - \underline{\hat{y}}\)</span></li>
</ol>
<blockquote>
<p>注意： 1. <span class="math inline">\(N\)</span> 必须是可逆的，这就要求 <span class="math inline">\(A\)</span> 满秩 ## 精确度估算 ### 方差 上一步中，我们得到了误差的估算值，因此可以计算后验方差（posterior variance）： <span class="math display">\[
\hat{\sigma}^2 = \frac{\underline{\hat{\varepsilon}}^TQ^{-1}\underline{\hat{\varepsilon}}}{m-n}
\]</span></p>
</blockquote>
<h3 id="协方差">协方差</h3>
<p>根据 <a href="https://en.wikipedia.org/wiki/Propagation_of_uncertainty">协方差传播（covariance propagation）</a>：</p>
<p><span class="math display">\[\begin{aligned}
\textbf{在线性的场景下：} y = Ax+b \\
\text{则 }\left\{\begin{matrix}\text{均值 } \mu_y = A\mu_x + b  \\
\text{协方差 } C_{yy} = AC_{xx}A^T
\end{matrix}\right.\\
\quad \\
\textbf{在非线性的场景下：} y = g(x) \\
\text{则 }\left\{\begin{matrix}\text{均值 } \mu_y \cong g(\mu_x) \\
\text{协方差 } C_{yy} = JC_{xx}J^T
\end{matrix}\right.\\
\end{aligned}\]</span></p>
<p>因此观测值的协方差为： <span class="math display">\[\begin{aligned}
C_{y0y0} = IC_{\varepsilon\varepsilon}I^T = C_{\varepsilon\varepsilon} = \sigma_0^2Q
\end{aligned}\]</span></p>
<p>由于前面已经得出一个后验方差，因此，上面又可以写成： <span class="math display">\[\begin{aligned}
C_{y0y0} = \hat{\sigma}^2Q
\end{aligned}\]</span></p>
<h4 id="未知参数的估算解的协方差">未知参数的估算解的协方差</h4>
<p><span class="math display">\[\begin{aligned}
\because \underline{\hat{x}} = N^{-1}A^TQ^{-1}(\underline{y}_0 - \underline{b}) \\
\therefore C_{\hat{x}\hat{x}} = N^{-1}A^TQ^{-1}C_{y_0y_0}(N^{-1}A^TQ^{-1})^T \\
= N^{-1}A^TQ^{-1}\hat{\sigma}^2Q(N^{-1}A^TQ^{-1})^T \\
= \hat{\sigma}^2N^{-1}
\end{aligned}\]</span></p>
<h4 id="观测值的估算值的协方差">观测值的估算值的协方差</h4>
<p><span class="math display">\[\begin{aligned}
\because \underline{\hat{y}} = A\underline{\hat{x}} + \underline{b} \\
\therefore C_{\hat{y}\hat{y}} = AC_{\hat{x}\hat{x}}A^T  \\
= A\hat{\sigma}^2N^{-1}A^T
\end{aligned}\]</span></p>
<h4 id="误差的估算值的协方差">误差的估算值的协方差</h4>
<p><span class="math display">\[\begin{aligned}
\because \underline{\hat{\varepsilon}} = \underline{y}_0 - \underline{\hat{y}} \\
\therefore C_{\hat{\varepsilon}\hat{\varepsilon}} = C_{y0y0} -  C_{\hat{y}\hat{y}} \\
= \hat{\sigma}^2Q - A\hat{\sigma}^2N^{-1}A^T \\
= \hat{\sigma}^2(Q-AN^{-1}A^T)
\end{aligned}\]</span></p>
<h2 id="置信度评估">置信度评估</h2>
<h3 id="全局测试">全局测试</h3>
<ol type="1">
<li>做出假设 <span class="math display">\[H_0: \hat{\sigma}^2=\sigma^2\]</span></li>
<li>计算：<span class="math inline">\(\frac{\hat{\sigma}^2}{\sigma^2}(m-n)\backsim\chi^2_{exp}\)</span></li>
<li>查询卡方分布表：<span class="math inline">\(\chi^2_{lim}=\chi^2_{(m-n)}(\alpha)\)</span></li>
<li>如果 <span class="math inline">\(\chi^2_{exp}\le\chi^2_{lim}\)</span>，则接受假设；如果 <span class="math inline">\(\chi^2_{exp}\gt\chi^2_{lim}\)</span>，则拒绝假设。</li>
</ol>
<h3 id="局部测试">局部测试</h3>
<p>用以识别异常值（outliers）。</p>
<ol type="1">
<li>做出假设 <span class="math display">\[\frac{\hat{\varepsilon_i}}{\sigma_{\varepsilon_i}} = \tau_{exp} \sim \tau_{(m-n)}\]</span></li>
<li>计算 <span class="math inline">\(\tau_{exp}\)</span>，其中 <span class="math inline">\(\sigma_{\varepsilon_i}=\hat{\sigma}\sqrt{C_{\hat{\varepsilon}\hat{\varepsilon}}(i,i)}\)</span></li>
<li>查询 T 分布表：<span class="math inline">\(\tau_{lim}=\tau_{(m-n)}(\frac{\alpha}{2})\)</span></li>
<li>如果 <span class="math inline">\(|\tau_{exp}|\le\tau^2_{lim}\)</span>，则接受假设；如果 <span class="math inline">\(|\tau_{exp}|\gt\tau^2_{lim}\)</span>，则拒绝假设。</li>
<li>不满足假设的观测值即为异常者。将其移除后，重复整个过程。</li>
</ol>
]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GDA</tag>
        <tag>GIS</tag>
      </tags>
  </entry>
  <entry>
    <title>GDA | 随机预测（Stochastic Prediction）</title>
    <url>/2020/12/25/gda-stochastic-prediction/</url>
    <content><![CDATA[<h2 id="数据模拟">数据模拟</h2>
<p>模拟一个信号 \( S(\underline{t}_N, \overline{w})\)，其中，\(\underline{t}_N \) 是一个规律性分布的点的集合，点集大小为 \(N\)。 <span class="math display">\[\begin{equation}
\underline{t}_N = \begin{bmatrix}
0\\ 
1\\ 
...\\ 
N-1
\end{bmatrix}
\end{equation}\]</span> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sample size</span></span><br><span class="line">N = <span class="number">1000</span></span><br><span class="line"><span class="comment"># observation epochs (we assume to sample the signal on a regular basis</span></span><br><span class="line">t = np.arange(<span class="number">0</span>, N, <span class="number">1</span>).reshape((N, <span class="number">1</span>)) <span class="comment"># a column vector</span></span><br></pre></td></tr></table></figure> 假设该信号平稳（stationary），则该信号的协方差函数为（指数模型 ）： <span class="math display">\[\begin{equation}
C_S(|t-t&#39;|) = A_0e^{(-\alpha_0|t-t&#39;|)}
\end{equation}\]</span></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># signal covariance model</span></span><br><span class="line"><span class="comment"># variance of the random signal</span></span><br><span class="line">A0 = <span class="number">9</span></span><br><span class="line"><span class="comment"># decay speed of the covariance model</span></span><br><span class="line">a0 = <span class="number">1</span>/<span class="number">100</span></span><br><span class="line"><span class="comment"># exponential model</span></span><br><span class="line">cf = A0 * np.exp(-a0*t) <span class="comment"># a column vector</span></span><br></pre></td></tr></table></figure>
<p>对应的协方差矩阵为: <span class="math display">\[\begin{equation}
\begin{aligned}
C_{S_{N\times N}} &amp;= \begin{bmatrix}
C_S(0) &amp; C_S(1) &amp; C_S(2) &amp; ... &amp; C_S(N-1) \\ 
C_S(1) &amp; C_S(0) &amp; C_S(1) &amp; ... &amp; C_S(N-2) \\ 
 ... \\
 C_S(N-1) &amp; C_S(N-2) &amp; C_S(N-3) &amp; ... &amp; C_S(0)
\end{bmatrix} \\
&amp;= \begin{bmatrix}
 A_0 &amp; A_0e^{-\alpha_0\times 1} &amp; A_0e^{-\alpha_0\times 2} &amp; ... &amp; A_0e^{-\alpha_0\times (N-1))} \\ 
 A_0e^{-\alpha_0\times 1} &amp; A_0 &amp; A_0e^{-\alpha_0\times 1} &amp; ... &amp; A_0e^{-\alpha_0\times (N-2))} \\ 
 ... \\
 A_0e^{-\alpha_0\times (N-1))} &amp; A_0e^{-\alpha_0\times (N-2))} &amp; A_0e^{-\alpha_0\times (N-2))} &amp; ... &amp; A_0
\end{bmatrix}
\end{aligned}
\end{equation}\]</span></p>
<p>由于数据规律性分布（\(\triangle = 1\)），因此，其协方差矩阵是 T 型矩阵。</p>
<blockquote>
<p>T型矩阵（Toeplitz matrix）：主对角线上的元素相等，平行于主对角线的线上的元素也相等；矩阵中的各元素关于次对角线对称，即T型矩阵为次对称矩阵。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.linalg <span class="keyword">import</span> toeplitz</span><br><span class="line"><span class="comment"># covariance matrix of the given N-dimensional sample variable </span></span><br><span class="line">C = toeplitz(cf)</span><br></pre></td></tr></table></figure>
<p>将协方差矩阵进行 Cholesky 分解：\(C_S = L\times L^+ \)</p>
<blockquote>
<p>Cholesky 分解：把一个对称正定的矩阵表示成一个下三角矩阵 L 和其转置的乘积的分解。它要求矩阵的所有特征值必须大于零，故分解的下三角的对角元也是大于零的。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Cholesky decomposition C=LxL&#x27; (L=lower triangular matrix)</span></span><br><span class="line">L = np.linalg.cholesky(C)</span><br></pre></td></tr></table></figure>
<p>假设 \(\underline{X}_N\) 是一个满足正态分布的随机变量，具有以下性质： <span class="math display">\[\begin{equation}
\begin{aligned}
E\{\underline{X}_N\} &amp;= 0 \\
C_{\underline{X}\underline{X}} &amp;= I
\end{aligned}
\end{equation}\]</span></p>
<p>令随机变量 \( S(\underline{t}_N, w)\) 为 \(\underline{X}_N\) 的一个线性变换： <span class="math display">\[\begin{equation}
S(\underline{t}_N, w) = L\times \underline{X}_N
\end{equation}\]</span> 则其具有以下性质： <span class="math display">\[\begin{equation}
\begin{aligned}
E\{S(\underline{t}_N, w)\} &amp;= L\times E\{\underline{X}_N\} \\
&amp;= \underline{0} \\
C_{SS} &amp;= L\times C_{\underline{X}\underline{X}}\times L^{+} \\
&amp;= L\times L^{+} (\text{满足上面的 Cholesky 分解})
\end{aligned}
\end{equation}\]</span></p>
<p>故而模拟的信号可以由以下等式给出： <span class="math display">\[\begin{equation}
S(\underline{t}_N) = L\times {\underline{x}_N}^{0}
\end{equation}\]</span></p>
<p>其中，\({\underline{x}_N}^{0}\) 是 \(\underline{X}_N\) 的一个样本</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># signal sampling simulation </span></span><br><span class="line">y = L.dot(np.random.randn(N, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>增加随机白噪声（random white-noise）\(\underline{v}\)，其方差为 \(\sigma_v^2\)。 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># noise standard deviation 40% of signal</span></span><br><span class="line">sigma_v = <span class="number">0.4</span> * np.sqrt(cf[<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="comment"># white noise generation (normal white noise)</span></span><br><span class="line">v = sigma_v * np.random.randn(N,<span class="number">1</span>)</span><br></pre></td></tr></table></figure> 该白噪声与信号不相关（Uncorrelated）。</p>
<p>因此，最终模拟的数据为： <span class="math display">\[\begin{equation}
\underline{y}_0 = S(\underline{t}_N) + \underline{v}
\end{equation}\]</span></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># observations (sampled signal + white noise</span></span><br><span class="line">y0 = y + v</span><br></pre></td></tr></table></figure>
<p>绘图查看： <img src="/img/gda_20201225-224446.jpg" /></p>
<h2 id="估测经验协方差函数estimation-of-the-ecf">估测经验协方差函数（ESTIMATION OF THE ECF）</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># observation mean removal</span></span><br><span class="line">y0_m = y0 - np.mean(y0)</span><br><span class="line"><span class="comment"># max length for ecf evaluation</span></span><br><span class="line">N2 = <span class="built_in">int</span>(N/<span class="number">2</span>)</span><br><span class="line"><span class="comment"># ecf: xcorr(y0_m, N2)</span></span><br><span class="line">ecf = np.correlate(y0_m.T[<span class="number">0</span>], y0_m.T[<span class="number">0</span>], mode=<span class="string">&quot;full&quot;</span>)[<span class="built_in">len</span>(y0_m)-<span class="number">1</span>-N2:<span class="built_in">len</span>(y0_m)+N2]</span><br></pre></td></tr></table></figure>
<p><img src="/img/gda_20201229-154342.jpg" /></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ecf = ecf[N2:<span class="number">2</span>*N2+<span class="number">1</span>].reshape((N2+<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># biased, definite postive</span></span><br><span class="line">ecf = ecf / N</span><br></pre></td></tr></table></figure>
<p><img src="/img/gda_20201229-154540.jpg" /></p>
<blockquote>
<p>注意：每次运行得到的协方差系数是不一样的，而我们用于计算的模型基于观测值（样本）和噪音。因此，不同的观测值（样本）得到的模型不同。</p>
</blockquote>
<h2 id="插值法interpolation-of-the-ecf估测协方差函数-hatcf">插值法（INTERPOLATION OF THE ECF）估测协方差函数 \(\hat{CF}\)</h2>
<p>这里，我们使用指数模型： <span class="math display">\[\begin{equation}
CF = A_0e^{(-\alpha_0(|t-t&#39;|))}
\end{equation}\]</span></p>
<p>使用最小二乘法（LS）估测参数 \(\hat{A_0}\) 和 \(\hat{\alpha_0}\)。</p>
<h3 id="确定参数的近似值-widetildea-和-widetildealpha">1. 确定参数的近似值 \(\widetilde{A}\) 和 \(\widetilde{\alpha}\)</h3>
<p>利用第 2 和 第 3 个协方差系数来估算 \(\widetilde{A}\)，利用相关长度（correlation length）估算 \(\widetilde{\alpha}\) <span class="math display">\[\begin{equation}
\begin{aligned}
\widetilde{A} &amp;= 2 \times CF(1) - CF(2) \\
\hat{\sigma _{0}}^{2} &amp;= CF(0) - \widetilde{A} \\
\frac{\widetilde{A}}{2} &amp;= \widetilde{A}*e^{(-\widetilde{\alpha}(|\bar{\tau }|))} \\
ln{\frac{1}{2}} &amp;= -\widetilde{\alpha}(|\bar{\tau }|) \\
-ln{2} &amp;= -\widetilde{\alpha}(|\bar{\tau }|) \\
\widetilde{\alpha} &amp;= \frac{ln2}{|\bar{\tau }|}
\end{aligned}
\end{equation}\]</span></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># approximated values of the parameters for linearization</span></span><br><span class="line"><span class="comment">## intersection with t=0 of the straight line</span></span><br><span class="line"><span class="comment">## exactly interpolating the covariance</span></span><br><span class="line"><span class="comment">## coefficients at step 1 and 2</span></span><br><span class="line">Ast01 = <span class="number">2</span>*ecf[<span class="number">1</span>,<span class="number">0</span>] - ecf[<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">Ast0 = Ast01</span><br><span class="line"><span class="comment"># noise variance estimate</span></span><br><span class="line">sigma2st0_v = ecf[<span class="number">0</span>,<span class="number">0</span>] - Ast0</span><br><span class="line"></span><br><span class="line">ecf_05 = Ast0/<span class="number">2</span></span><br><span class="line">i_lcorr = np.argwhere(ecf-ecf_05&lt;=<span class="number">0</span>).<span class="built_in">min</span>(<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">t_lcorr = t[i_lcorr-<span class="number">1</span>,<span class="number">0</span>] <span class="comment"># correlation length</span></span><br><span class="line"><span class="comment"># assumption: A/ecf(lcorr) = 2</span></span><br><span class="line">ast01 = np.log(<span class="number">2</span>)/t_lcorr</span><br><span class="line"></span><br><span class="line"><span class="comment"># approximated cf model</span></span><br><span class="line">ecm01 = Ast0 * np.exp(-ast01*t)</span><br></pre></td></tr></table></figure>
<p><img src="/img/gda_20201229-165545.jpg" /></p>
<h3 id="迭代估测">2. 迭代估测</h3>
<p>这里，我们仅迭代五次： <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i_up = np.argwhere(ecf[<span class="number">1</span>:]-ecf[:-<span class="number">1</span>]&gt;=<span class="number">0</span>).<span class="built_in">min</span>(<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">t_up = t[i_up,<span class="number">0</span>]</span><br><span class="line"><span class="comment">#print(i_up, t[1:i_up+1])</span></span><br><span class="line"><span class="comment"># point selection for LS interpolation</span></span><br><span class="line">t0 = t[<span class="number">1</span>:i_up+<span class="number">1</span>] <span class="comment"># confusion here!!!</span></span><br><span class="line"><span class="comment"># ecf values to be interpolated</span></span><br><span class="line">ecf0 = ecf[<span class="number">1</span>:i_up+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># first iteration</span></span><br><span class="line">Ast = Ast01</span><br><span class="line">ast = ast01</span><br><span class="line"></span><br><span class="line"><span class="comment"># cf</span></span><br><span class="line">ecm = Ast * np.exp(-ast*t)</span><br><span class="line">plt.plot(t[:M+<span class="number">1</span>], ecm[:M+<span class="number">1</span>], <span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;ecm&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># design matrix (Jacobian)</span></span><br><span class="line">    A = np.hstack([np.exp(-ast*t0),-Ast*t0*np.exp(-ast*t0)])</span><br><span class="line">    <span class="comment"># known terms vector</span></span><br><span class="line">    a = np.asmatrix(Ast * np.exp(-ast*t0))</span><br><span class="line">    <span class="comment">#print(A, A.shape, a.shape, ecf0.shape, t0.shape)</span></span><br><span class="line">    <span class="comment"># estimated parameters</span></span><br><span class="line">    xst = inv(A.T.dot(A)).dot(A.T).dot(ecf0-a)</span><br><span class="line">    <span class="comment">#print(xst, xst.shape)</span></span><br><span class="line">    <span class="comment"># i-th iteration</span></span><br><span class="line">    Ast += xst[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    ast += xst[<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#print(Ast, ast, M)</span></span><br><span class="line">    <span class="comment"># cf</span></span><br><span class="line">    ecm = Ast * np.exp(-ast*t)</span><br><span class="line">    <span class="comment">#print(t.shape, ecm.shape)</span></span><br><span class="line">    plt.plot(t[:M], ecm[:M], <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">sigma2st_v = ecf[<span class="number">0</span>,<span class="number">0</span>] - Ast</span><br></pre></td></tr></table></figure> <img src="/img/gda_20201230-152900.jpg" /></p>
<h2 id="使用观测值和协方差函数-hatcf-预测指定点集的信号值">使用观测值和协方差函数 \(\hat{CF}\) 预测指定点集的信号值</h2>
<ul>
<li>观测值：\( \underline{y}_0 \)</li>
<li>协方差函数： <span class="math display">\[\begin{equation}
\hat{CF} = \hat{A_0}e^{(-\hat{\alpha_0}(|t-t&#39;|))}
\end{equation}\]</span></li>
<li>预测： <span class="math display">\[\begin{equation}
\hat{y} = C_{yy} \times (C_{yy}+k\times(\hat{\sigma _{0}}^{2}\times I_{N\times N}))^{-1} \times y_0
\end{equation}\]</span></li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># number of observations to filter</span></span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Covariance matrix of the sampled signal</span></span><br><span class="line">Cyy = toeplitz(ecm[:n+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Covariance matrix of the sampled signal + noise</span></span><br><span class="line">Cy0y0 = Cyy + np.eye(n+<span class="number">1</span>)*sigma2st_v</span><br><span class="line"></span><br><span class="line"><span class="comment"># filtered signal</span></span><br><span class="line">yst = Cyy.dot(inv(Cy0y0)).dot(y0_m[:n+<span class="number">1</span>])</span><br><span class="line">est = y[:n+<span class="number">1</span>] - yst</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">estimation error:</span></span><br><span class="line"><span class="string">   mean\t\t= &#123;&#125;</span></span><br><span class="line"><span class="string">   std\t\t= &#123;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.<span class="built_in">format</span>(np.mean(est), np.std(est)))</span><br></pre></td></tr></table></figure>
<p><img src="/img/gda_20201230-162015.jpg" /></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Covariance matrix of the sampled signal</span></span><br><span class="line">Cyy = toeplitz(ecm[:n+<span class="number">1</span>])</span><br><span class="line"><span class="comment"># Covariance matrix of the sampled signal + noise</span></span><br><span class="line">Cy0y0 = Cyy + <span class="number">9</span>*np.eye(n+<span class="number">1</span>)*sigma2st_v</span><br><span class="line"></span><br><span class="line"><span class="comment"># filtered signal</span></span><br><span class="line">yst = Cyy.dot(inv(Cy0y0)).dot(y0_m[:n+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">est = y[:n+<span class="number">1</span>] - yst</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">estimation error:</span></span><br><span class="line"><span class="string">   mean\t\t= &#123;&#125;</span></span><br><span class="line"><span class="string">   std\t\t= &#123;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.<span class="built_in">format</span>(np.mean(est), np.std(est)))</span><br></pre></td></tr></table></figure>
<p><img src="/img/gda_20201230-162225.jpg" /></p>
<p>可以看出，<code>k</code> 值越大，noise 的方差越大，估测信号越平滑。</p>
<p>如果我们修改相关长度（correlation length）的大小： <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ecmErr = Ast * np.exp(-<span class="number">0.1</span>*ast*t)</span><br><span class="line">Cyy = toeplitz(ecmErr[:n+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Covariance matrix of the sampled signal + noise</span></span><br><span class="line">Cy0y0 = Cyy + <span class="number">9</span>*np.eye(n+<span class="number">1</span>)*sigma2st_v <span class="comment"># smoother</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># filtered signal</span></span><br><span class="line">yst = Cyy.dot(inv(Cy0y0)).dot(y0_m[:n+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">est = y[:n+<span class="number">1</span>] - yst</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">estimation error:</span></span><br><span class="line"><span class="string">   mean\t\t= &#123;&#125;</span></span><br><span class="line"><span class="string">   std\t\t= &#123;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.<span class="built_in">format</span>(np.mean(est), np.std(est)))</span><br></pre></td></tr></table></figure> <img src="/img/gda_20201230-163538.jpg" /></p>
<p>可以看出，相关长度越大，估测信号越平滑；相关长度越小，用以估测信号的观测值越少，估测信号越接近观测值，过滤能力越弱。</p>
]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GDA</tag>
        <tag>GIS</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Go | select ... case ... default</title>
    <url>/2020/04/02/dive-into-go-select-case/</url>
    <content><![CDATA[<blockquote>
<p>以下基于 Go 1.14</p>
</blockquote>
<h2 id="编译时">编译时</h2>
<p><img src="/img/divego_select_case_compile.svg" /></p>
<h2 id="runtime.selectgo-的行为"><code>runtime.selectgo()</code> 的行为</h2>
<p><img src="/img/divego_select_case_selectgo.svg" /></p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Go | 调度：GMP 模型（第二部分）</title>
    <url>/2020/04/14/dive-into-go-schedule-gpm-part2/</url>
    <content><![CDATA[<h2 id="启动调度器">启动调度器</h2>
<p>Go 程序启动之后，在进入 <code>main()</code> 之前，会调用 <code>runtime.schedinit()</code> 启动调度器：</p>
<p><img src="/img/divego_schedule_gmp_schedinit.svg" /></p>
<h2 id="调度循环">调度循环</h2>
<p>调度器启动后，Go 运行时就会调用 <code>runtime.mstart()</code> 初始化一个新线程，然后调用 <code>runtime.schedule()</code> 进入调度循环（永不返回）。调度循环会查找一个可运行的 goroutine，然后在当前线程上执行这个 goroutine。</p>
<p>可运行 goroutine 的来源有： * 全局可运行队列 * 与处理器 P 绑定的本地可运行队列 * netpoll * 从其他处理器 P 的本地可运行队列中窃取</p>
<p><img src="/img/divego_schedule_gmp_goexit.svg" /></p>
<h2 id="创建-goroutine">创建 goroutine</h2>
<p>在编译阶段，<code>go fn()</code> 会转换成运行时调用 <code>runtime.newproc()</code>。这个函数在从（本地/全局）空闲 goroutine 列表从获取不到一个可用的 goroutine 才会新建一个。并且，会将 fn 调用的参数和 <code>runtime.goexit()</code> 的 PC 保存在 goroutine 的栈中。</p>
<p><img src="/img/divego_schedule_gmp_gofn.svg" />&gt;</p>
<h2 id="goroutine-执行完毕">goroutine 执行完毕</h2>
<p>在调度 goroutine 运行的时候，<code>runtime.goexit()</code> 位于调用栈的顶端，因此，当 goroutine 对应的函数运行完毕后，就会跳转执行 <code>runtime.goexit()</code>：</p>
<p><img src="/img/divego_schedule_gmp_gofn.svg" /></p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>我在极光两三事（一）</title>
    <url>/2019/11/02/experience-in-jg-part-1/</url>
    <content><![CDATA[<p>2016.03.07 ~ 2019.11.01。</p>
<p>这是我在 JG 待的日子。</p>
<p>这是我离开 HW 想当小码农后面的第一家公司。谁曾想，一待就是近四年。</p>
<p>那个时候，我对互联网公司都是咋玩的一点概念都没有。稀稀拉拉地学了一段时间的 python，刷了几道 leetcode，然后稀里糊涂地就进了 JG。后来，面试我的同事打趣道，要求不高，性别女，会写 <code>hello workd</code> 就行了。</p>
<p>在某些时候，幸运女神肯定是站在我身边的。</p>
<p>一入职，狂补知识。</p>
<p>Restful API 是啥？nginx+uwsgi 要咋用呀？RabbitMQ 是什么鬼东西？这个统计用 shell 咋写？Lua 半天从入门到改线上代码了解一下。客户找上门来找不到问题查不出原因怎么破？</p>
<p>当你打开新世界的大门后，走进去，一切的一切对于你而言都是新的。努力搞明白向前走，滚是不可能的。毕竟路是自己选的，跪着也要走下去。</p>
<p>当然，也没那么惨。没什么是不能谷歌的。谷歌不到肯定是你关键字不对。实在找不到关键字，可以请教同事。大多数时候，周围的人都是很愿意帮你的。</p>
<p>于是啃了许多入门书，看了许多文档，慢慢地也能够称职地当个 python 小开发。再慢慢地，能够当场撸线上代码直接发布。不得不说，ansible 救了我无数次。而学习的过程，挺过最开始的苦逼后，就是充实的愉悦了。</p>
<p>美滋滋的日子没过多久，便面临了量上来了，机器不能无限往上堆。怎么办？重构呗。于是面前两条路，要么两眼一闭安于现状，要么转学另一门语言。</p>
<p>To be or not to be, that's a question.</p>
<p>其实也没得选，学呗。</p>
<p>被 python 惯坏的我，学起 golang 那是真的痛苦。当然，痛苦之处不是基本语法，而是并发。幸好学来即用，看了几天语法书，便开始撸了第一版 API golang 版本。重构第一个 API 的时候不熟？没事，还有第二个第三个第四个……，第 N 个。后来回去看自己撸的第一版代码，真丑呀！埋了一片雷，goroutine 泄露，空间随意申请…… 简直愧对后来接手的兄弟。但不得不说，其性能确实吊打 python。此外，当你学会了怎么玩好 goroutine 和 channel，并发编程就成了一件极其简单的事情。</p>
<p>当然，python 仍然是我最喜欢的语言。需要写点无伤大雅的小工具的时候，它依然是我的首选。毕竟不是哪都性能至上的。</p>
<p>于是乎，从 python 开发工程师到 golang 开发工程师，也就是一个 API 重构的事情。</p>
]]></content>
      <categories>
        <category>这就是生活</category>
      </categories>
      <tags>
        <tag>经历</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang/JSON | DisallowUnknownFields 和自定义结构的序列化方法</title>
    <url>/2019/05/15/golang-json-custom-marshal-unmarshal/</url>
    <content><![CDATA[<p>在 Go 中，对于自定义结构的序列化和反序列化存在几个问题。</p>
<h2 id="q1如何保证待反序列化的字符串只包含所定义的结构中的字段">Q1：如何保证待反序列化的字符串只包含所定义的结构中的字段？</h2>
<p>从 <strong>Go 1.10</strong> 起，标准库 <code>encoding/json</code> 提供了方法 <a href="https://golang.org/pkg/encoding/json/#Decoder.DisallowUnknownFields"><code>func (*Decoder) DisallowUnknownFields</code></a>。调用该方法表示，当目标是一个结构，并且输入流中包含任何<em>不匹配</em>该结构的非忽略的导出字段时，<code>Decoder</code> 会返回一个错误。</p>
<p>举个例子： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> jsonStream = <span class="string">`&#123;&quot;Name&quot;: &quot;Ed&quot;, &quot;Text&quot;: &quot;Knock knock.&quot;&#125;`</span></span><br><span class="line">	<span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">		Name <span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">	dec := json.NewDecoder(strings.NewReader(jsonStream))</span><br><span class="line">	dec.DisallowUnknownFields()</span><br><span class="line">	<span class="keyword">var</span> m Message</span><br><span class="line">	err := dec.Decode(&amp;m)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, m.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在上面的例子中，<code>jsonStream</code> 定义了一个结构 <code>Message</code> 不存在的字段 <code>"Text"</code>。接下来，声明一个 <code>Decoder</code>，并且调用 <code>DisallowUnknownFields</code> 方法。</p>
<p><a href="https://play.golang.org/p/lubiUUVHlG1">运行</a>会发现，反序列化失败： <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2009</span>/<span class="number">11</span>/<span class="number">10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> json: unknown field <span class="string">&quot;Text&quot;</span></span><br></pre></td></tr></table></figure> 如果结构 <code>Message</code> 中有一个忽略的导出 <code>Text</code> 字段，又会发生什么呢？稍微改动下上面的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> jsonStream = <span class="string">`&#123;&quot;Name&quot;: &quot;Ed&quot;, &quot;Text&quot;: &quot;Knock knock.&quot;&#125;`</span></span><br><span class="line">	<span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">		Name <span class="keyword">string</span></span><br><span class="line">		Text <span class="keyword">string</span> <span class="string">`json:&quot;-&quot;`</span> <span class="comment">// 增加一个字段定义</span></span><br><span class="line">	&#125;</span><br><span class="line">	dec := json.NewDecoder(strings.NewReader(jsonStream))</span><br><span class="line">	dec.DisallowUnknownFields()</span><br><span class="line">	<span class="keyword">var</span> m Message</span><br><span class="line">	err := dec.Decode(&amp;m)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, m.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/590Y_ajap11">运行</a>，得到同样的错误： <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2009</span>/<span class="number">11</span>/<span class="number">10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> json: unknown field <span class="string">&quot;Text&quot;</span></span><br></pre></td></tr></table></figure> 同理，如果 <code>Text</code> 字段变成未导出字段，也会出现相同的报错： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> jsonStream = <span class="string">`&#123;&quot;Name&quot;: &quot;Ed&quot;, &quot;Text&quot;: &quot;Knock knock.&quot;&#125;`</span></span><br><span class="line">	<span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">		Name <span class="keyword">string</span></span><br><span class="line">		text <span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">	dec := json.NewDecoder(strings.NewReader(jsonStream))</span><br><span class="line">	dec.DisallowUnknownFields()</span><br><span class="line">	<span class="keyword">var</span> m Message</span><br><span class="line">	err := dec.Decode(&amp;m)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, m.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <a href="https://play.golang.org/p/BmT5xEpTyu5">运行</a> 验证一下吧。</p>
<h2 id="q2如何判断某个字段是否存在">Q2：如何判断某个字段是否存在？</h2>
<p>Go 结构的零值导致了我们无法通过判断字段值是否等于某个值来确定 JSON 字符串中是否存在某个字段。</p>
<p>此外，如果将字段类型定义为指针的话，则无法区分该字段的值就是 <code>null</code> 的场景。</p>
<p>当然，我们并非无计可施。<code>encoding/json</code> 允许我们为自定义结构定义序列化和反序列化方法。只要分别实现 <code>MarshalJSON() ([]byte, error)</code> 和 <code>UnmarshalJSON([]byte) error</code> 方法即可。</p>
<p>来看下如何通过 <code>MarshalJSON</code> 方法来判断某个字段是否存在： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Int <span class="keyword">struct</span> &#123;</span><br><span class="line">	Valid <span class="keyword">bool</span> <span class="comment">// 表示是否为有效值</span></span><br><span class="line">	Set   <span class="keyword">bool</span> <span class="comment">// 表示是否设置</span></span><br><span class="line">	Value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义反序列化方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *Int)</span> <span class="title">UnmarshalJSON</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果调用了该方法，说明设置了该值</span></span><br><span class="line">	i.Set = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">string</span>(data) == <span class="string">&quot;null&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// 表明该字段的值为 null</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> temp <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal(data, &amp;temp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	i.Value = temp</span><br><span class="line">	i.Valid = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义序列化方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Int)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> []<span class="keyword">byte</span>(strconv.Itoa(i.Value)), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在上面的例子中，我们定义了一个结构体 <code>Int</code> 来替代基本结构 <code>int</code>。并且定义了两个字段来表示是否设置及是否有效。这样，在序列化之后，我们就可以通过这两个字段来检查了。</p>
<p>此外，因为不希望序列化后出现这两个布尔值，因此还需要自定义序列化方法 <code>MarshalJSON</code>。</p>
<p>下面，简单测试一下： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123; Val Int &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(bytes []<span class="keyword">byte</span>)</span> <span class="params">(A, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">struct</span>&#123; Val Int &#125;</span><br><span class="line">	err := json.Unmarshal(bytes, &amp;a)</span><br><span class="line">	<span class="keyword">return</span> a, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	notSet := []<span class="keyword">byte</span>(<span class="string">`&#123;&#125;`</span>)</span><br><span class="line">	setNull := []<span class="keyword">byte</span>(<span class="string">`&#123;&quot;val&quot;: null&#125;`</span>)</span><br><span class="line">	setValid := []<span class="keyword">byte</span>(<span class="string">`&#123;&quot;val&quot;: 123&#125;`</span>)</span><br><span class="line">	setWrongType := []<span class="keyword">byte</span>(<span class="string">`&#123;&quot;val&quot;: &quot;123&quot;&#125;`</span>)</span><br><span class="line"></span><br><span class="line">	a, err := do(notSet)</span><br><span class="line">	log.Printf(<span class="string">&quot;NotSet|set:%t|valid:%t|err: %v\n&quot;</span>, a.Val.Set, a.Val.Valid, err)</span><br><span class="line"></span><br><span class="line">	a, err = do(setNull)</span><br><span class="line">	log.Printf(<span class="string">&quot;SetNull|set:%t|valid:%t|err: %v\n&quot;</span>, a.Val.Set, a.Val.Valid, err)</span><br><span class="line"></span><br><span class="line">	a, err = do(setValid)</span><br><span class="line">	log.Printf(<span class="string">&quot;SetValid|set:%t|valid:%t|err: %v\n&quot;</span>, a.Val.Set, a.Val.Valid, err)</span><br><span class="line"></span><br><span class="line">	a, err = do(setWrongType)</span><br><span class="line">	log.Printf(<span class="string">&quot;SetWrongType|set:%t|valid:%t|err: %v\n&quot;</span>, a.Val.Set, a.Val.Valid, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 可以<a href="https://play.golang.org/p/ILMMdgIVlAg">运行</a>一下查看结果。</p>
<h2 id="q3如何让-omitempty-选项对自定义结构体生效">Q3：如何让 <code>omitempty</code> 选项对自定义结构体生效？</h2>
<p>如果对字段使用了 <code>omitempty</code> 选项，那么在序列化过程中，如果该字段具有零值（即 false、0、nil 指针、nil 接口值和任何空数组、空 slice、空 map 或者空字符串），那么会忽略该字段。</p>
<p>但是，当前最新的 Go 版本（Go）下，这个选项对于自定义结构是不生效的。</p>
<p>举个例子： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> Text <span class="keyword">struct</span> &#123;</span><br><span class="line">		ID      <span class="keyword">int</span></span><br><span class="line">		Content <span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">		Name    <span class="keyword">string</span></span><br><span class="line">		Content Text	<span class="string">`json:&quot;content,omitempty&quot;`</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> m Message</span><br><span class="line">	m.Name = <span class="string">&quot;test&quot;</span></span><br><span class="line">	bytes, err := json.Marshal(m)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="keyword">string</span>(bytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在上面的例子中，我们定义了一个结构体 <code>Message</code>，它包含一个字段 <code>Content</code>，类型为自定义的 <code>Text</code>，并打上 <code>omitempty</code> 选项。然后，声明一个实例并给 <code>Message</code> 的另一个字段赋值。接着序列化该实例。</p>
<p>期待序列化结果为 <code>&#123;"Name":"test"&#125;</code>。但是<a href="https://play.golang.org/p/PFtRDIH_TAr">运行</a>之后却得到以下结果： <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;Name&quot;</span>:<span class="string">&quot;test&quot;</span>,<span class="attr">&quot;content&quot;</span>:&#123;<span class="attr">&quot;ID&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;Content&quot;</span>:<span class="string">&quot;&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure> 查看 <code>encoding/json</code> 相关代码会发现，该库在字段使用了 <code>omitempty</code> 选项时，对于空值的判断确实仅限于文档中描述的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// encode.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmptyValue</span><span class="params">(v reflect.Value)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Array, reflect.Map, reflect.Slice, reflect.String: <span class="comment">// 空数组、空 Map、空 slice、空字符串</span></span><br><span class="line">		<span class="keyword">return</span> v.Len() == <span class="number">0</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Bool: <span class="comment">// false</span></span><br><span class="line">		<span class="keyword">return</span> !v.Bool()</span><br><span class="line">	<span class="keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: <span class="comment">// 0</span></span><br><span class="line">		<span class="keyword">return</span> v.Int() == <span class="number">0</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr: <span class="comment">// 0</span></span><br><span class="line">		<span class="keyword">return</span> v.Uint() == <span class="number">0</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Float32, reflect.Float64: <span class="comment">// 0</span></span><br><span class="line">		<span class="keyword">return</span> v.Float() == <span class="number">0</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Interface, reflect.Ptr: <span class="comment">// nil 指针、nil interface 值</span></span><br><span class="line">		<span class="keyword">return</span> v.IsNil()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，此判断逻辑不适用于自定义结构（非指针的情况下）。并且，<strong>除了在使用自定义结构的时候使用指针</strong>，没有其他任何方法可以让 <code>omitempty</code> 选项对自定义结构体生效！！</p>
<p><a href="https://github.com/golang/go/issues/11939">Issue 11939</a> 提出并跟踪了这个问题。这个 Issue 从 2015 年 7 月份提出至今仍未有确定的解决时间 (`д´)</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://golang.org/pkg/encoding/json/">encoding/json</a></li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go | fmt：按键序打印 map</title>
    <url>/2018/11/10/go-fmt-print-map-key-sorted/</url>
    <content><![CDATA[<p>go 1.12 版本之前，打印 map 得到的结果是不确定的。也就是说，对于同一个 map，每次打印得到的 key 顺序都有可能不一样。</p>
<p>于是，<strong>go 1.12</strong> 做了一个改动：以 key 的顺序打印 map。也就是说，针对 map，fmt.printValue 会先调用 <code>fmtsort.Sort</code> 方法（位于 <code>src/internal/fmtsort</code>）获取已排序的 key 列表，然后依次打印对应的 value。</p>
<p>下面我们来看看比较规则：</p>
<ul>
<li>在适用情况下，nil 的值最小</li>
<li>对于所有比较，最开始会比较 key 的类型。如果类型不相同，则返回 <code>a &lt; b</code>（假设 <code>a</code> 是比较函数的第一个参数，<code>b</code> 是第二个参数）</li>
<li>整型、浮点数和字符串：由运算符 <code>&lt;</code> 确定</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printIntMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;<span class="number">3</span>: <span class="number">4</span>, <span class="number">1</span>: <span class="number">5</span>, <span class="number">0</span>: <span class="number">6</span>, <span class="number">55</span>: <span class="number">7</span>&#125;</span><br><span class="line">        fmt.Println(m) <span class="comment">// map[0:6 1:5 3:4 55:7]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printFloatMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m := <span class="keyword">map</span>[<span class="keyword">float32</span>]<span class="keyword">int</span>&#123;<span class="number">1.2</span>: <span class="number">3</span>, <span class="number">0.7</span>: <span class="number">4</span>, <span class="number">3.5</span>: <span class="number">5</span>&#125;</span><br><span class="line">        fmt.Println(m) <span class="comment">// map[0.7:4 1.2:3 3.5:5]</span></span><br><span class="line">        <span class="keyword">var</span> z <span class="keyword">float32</span></span><br><span class="line">        m[z/z] = <span class="number">6</span> </span><br><span class="line">        fmt.Println(m) <span class="comment">// map[NaN:6 0.7:4 1.2:3 3.5:5]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStringMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;abc&quot;</span>: <span class="number">0</span>, <span class="string">&quot;cdc&quot;</span>: <span class="number">1</span>, <span class="string">&quot;aab&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">        fmt.Println(m) <span class="comment">// map[aab:2 abc:0 cdc:1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：NaN &lt; 非 NaN 浮点数小</p>
</blockquote>
<ul>
<li>布尔型：true &gt; false</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">bool</span>]<span class="keyword">int</span>&#123;<span class="literal">true</span>: <span class="number">2</span>, <span class="literal">false</span>: <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(m) <span class="comment">// map[false:3 true:2]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>complex：先比较 real 部分，相等则比较 imag 部分</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printComplexMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">        m := <span class="keyword">map</span>[<span class="keyword">complex64</span>]<span class="keyword">int</span>&#123;<span class="built_in">complex</span>(<span class="number">1</span>,<span class="number">2</span>): <span class="number">0</span>, complext(<span class="number">-1</span>, <span class="number">3</span>): <span class="number">1</span>, <span class="built_in">complex</span>(<span class="number">4</span>, <span class="number">1</span>): <span class="number">2</span>&#125;</span><br><span class="line">        fmt.Println(m)</span><br><span class="line">        <span class="comment">// map[(-1+3i):1 (1+2i):0 (4+1i):2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>指针：使用机器地址进行比较 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from src/internal/fmtsort/sort_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pointerMap</span><span class="params">()</span> <span class="title">map</span>[*<span class="title">int</span>]<span class="title">string</span></span> &#123;</span><br><span class="line">        m := <span class="built_in">make</span>(<span class="keyword">map</span>[*<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">        <span class="keyword">var</span> ints  [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">                m[&amp;ints[i]] = fmt.Sprint(i)</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printPointerMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">        m := pointerMap()</span><br><span class="line">        fmt.Println(m)</span><br><span class="line">        <span class="comment">// map[0xc000014180:0 0xc000014188:1 0xc000014190:2]</span></span><br><span class="line">        m[<span class="literal">nil</span>] = <span class="string">&quot;3&quot;</span> </span><br><span class="line">        fmt.Println(m)</span><br><span class="line">        <span class="comment">// map[&lt;nil&gt;:3 0xc000014180:0 0xc000014188:1 0xc000014190:2]</span></span><br><span class="line">        <span class="comment">// 不同机器运行结果不同。但是都是按照指针地址进行排序的，并且 nil 最小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>channel：使用机器地址进行比较 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from src/internal/fmtsort/sort_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanMap</span><span class="params">()</span> <span class="title">map</span>[<span class="title">chan</span> <span class="title">int</span>]<span class="title">string</span></span> &#123;</span><br><span class="line">        m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">chan</span> <span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">        <span class="keyword">var</span> chans = [<span class="number">3</span>]<span class="keyword">chan</span> <span class="keyword">int</span>&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)&#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">                m[chans[i]] = fmt.Sprint(i)</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printChanMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">        m := chanMap()</span><br><span class="line">        fmt.Println(m)</span><br><span class="line">        <span class="comment">// map[0xc000082060:0 0xc0000820c0:1 0xc000082120:2]</span></span><br><span class="line">        m[<span class="literal">nil</span>] = <span class="string">&quot;3&quot;</span> </span><br><span class="line">        fmt.Println(m)</span><br><span class="line">        <span class="comment">// map[&lt;nil&gt;:3 0xc000082060:0 0xc0000820c0:1 0xc000082120:2]</span></span><br><span class="line">        <span class="comment">// 不同机器运行结果不同。但是都是按照指针地址进行排序的，并且 nil 最小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>struct：依次比较每个字段。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from src/internal/fmtsort/sort_test.go</span></span><br><span class="line"><span class="keyword">type</span> toy <span class="keyword">struct</span> &#123;</span><br><span class="line">        a <span class="keyword">int</span>    <span class="comment">// Exported.</span></span><br><span class="line">        C <span class="keyword">string</span> <span class="comment">// Exported</span></span><br><span class="line">        b <span class="keyword">int</span>    <span class="comment">// Unexported.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStructMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">        m := <span class="keyword">map</span>[toy]<span class="keyword">string</span>&#123;</span><br><span class="line">                toy&#123;<span class="number">7</span>, <span class="string">&quot;ab&quot;</span>, <span class="number">2</span>&#125;: <span class="string">&quot;7ab2&quot;</span>,</span><br><span class="line">                toy&#123;<span class="number">7</span>, <span class="string">&quot;bc&quot;</span>, <span class="number">1</span>&#125;: <span class="string">&quot;7bc1&quot;</span>,</span><br><span class="line">                toy&#123;<span class="number">3</span>, <span class="string">&quot;ac&quot;</span>, <span class="number">4</span>&#125;: <span class="string">&quot;3ac4&quot;</span>,</span><br><span class="line">        &#125;   </span><br><span class="line">        fmt.Println(m)</span><br><span class="line">        <span class="comment">// map[&#123;3 ac 4&#125;:3ac4 &#123;7 ab 2&#125;:7ab2 &#123;7 bc 1&#125;:7bc1]</span></span><br><span class="line">        <span class="comment">// 先比较字段 a。不相等则直接返回比较结果</span></span><br><span class="line">        <span class="comment">// 相等则继续比较字段 C。不相等则直接返回比较结果</span></span><br><span class="line">        <span class="comment">// 以此类推</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>array：依次比较每个元素 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArrayMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">        m := <span class="keyword">map</span>[[<span class="number">2</span>]<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">                [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>&#125;: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">                [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">                [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">                [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">0</span>&#125;: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">        &#125;   </span><br><span class="line">        fmt.Println(m)</span><br><span class="line">        <span class="comment">// map[[0 1]:1 [1 1]:0 [1 2]:2 [2 0]:3]</span></span><br><span class="line">        <span class="comment">// 先比较列表中的第一个元素。</span></span><br><span class="line">        <span class="comment">// 如果不相等，则比较第二个元素。</span></span><br><span class="line">        <span class="comment">// 以此类推，直到得出比较结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 说明：由于 slice 不能作为 map 的key。因此不做考虑</p></li>
<li><p>interface：首先比较描述具体类型的 reflect.Type，再比较值 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInterfaceMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> interf <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">        m := <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">string</span>&#123;</span><br><span class="line">                <span class="number">0</span>:      <span class="string">&quot;0&quot;</span>,</span><br><span class="line">                <span class="literal">true</span>:   <span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="number">-1</span>:     <span class="string">&quot;2&quot;</span>,</span><br><span class="line">                interf: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">                <span class="string">&quot;abc&quot;</span>:  <span class="string">&quot;4&quot;</span>,</span><br><span class="line">                <span class="number">1.5</span>:    <span class="string">&quot;5&quot;</span>,</span><br><span class="line">                <span class="string">&quot;aa&quot;</span>:   <span class="string">&quot;6&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Println(m)</span><br><span class="line">        <span class="comment">// map[&lt;nil&gt;:3 true:1 aa:6 1.5:5 abc:4 -1:2 0:0]</span></span><br><span class="line">        <span class="comment">// 输出结果每次运行各不相同。</span></span><br><span class="line">        <span class="comment">// 但是，nil 永远是最小的。</span></span><br><span class="line">        <span class="comment">// 同类型的 key 根据比较规则输出。</span></span><br><span class="line">        <span class="comment">// 不同类型的 key 根据检验顺序随机输出。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; interface 类型的 key 比较是先比较 key 的类型的。在 golang 中，这种情况下 key 的类型总是为 <code>reflect.Ptr</code>，而因为 <code>reflect.Ptr</code> 是个常量，故而对该类型做比较结果总是相等。因此，在类型比较这一步一般是不能得到结果，必须进行 key 的值比较。 &gt; &gt; 在进行 key 的值比较时，因为会先对值类型进行比较。此时，不同类型的 key 根据入参顺序就可以得出比较结果。而同种类型的 key 则按照以上规则得出比较结果。</p></li>
</ul>
<p>对于 map 打印，由于增加了排序操作，因此不可避免地会对性能有一定的冲击。这对于高性能要求的程序而言，是必须进行考虑的。</p>
<h3 id="参考">参考</h3>
<ul>
<li>https://github.com/golang/go/issues/21095</li>
<li>https://go-review.googlesource.com/c/go/+/142737/</li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go|踩坑不完全记录之channel</title>
    <url>/2018/09/03/golang%E7%9A%84%E8%B8%A9%E5%9D%91%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AE%B0%E5%BD%95%E4%B9%8Bchannel/</url>
    <content><![CDATA[<p>channel 是 golang 并发编程的极其重要的组成部分之一。但是关于 channel 的一些特性，如果不熟记于心，那么，可是会陷入莫名其妙的问题中无法自拔。下面，是关于 channel 你可能会踩到的雷……</p>
<h2 id="当-channel-为-nil-时...">当 channel 为 nil 时...</h2>
<p>当你声明一个 channel 并且不进行任何初始化动作的时候，恭喜你，你就获得了一个 nil channel：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在 golang 中，从一个 nil channel 接收数据，以及往一个 nil channel 发送数据都会天荒地老地阻塞。</p>
<p>这看起来并没有什么。但是，地雷暗藏其中。</p>
<p>举个栗子： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> d := <span class="keyword">range</span> c &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;receive a value: &quot;</span>, d)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;sleep for a moment and initialize channel c&quot;</span>)</span><br><span class="line">	c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">	c &lt;- <span class="literal">true</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;send true to channel&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在上面的代码中，我们声明（但是并未初始化）了一个 channel <code>c</code>。然后，创建一个 goroutine 来消费 channel <code>c</code>，并将从中接收到的数据打印出来。等待 3 秒后再对 channel <code>c</code> 进行初始化。接着，往该 channel 发送数据并再度等待 3 秒。</p>
<p>对于上面的代码，我们期望的输出是： <figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">sleep <span class="keyword">for</span> <span class="keyword">a</span> moment <span class="keyword">and</span> initialize channel c</span><br><span class="line"><span class="built_in">send</span> <span class="literal">true</span> <span class="built_in">to</span> channel</span><br><span class="line">receive <span class="keyword">a</span> <span class="built_in">value</span>:  <span class="literal">true</span></span><br><span class="line">Done</span><br></pre></td></tr></table></figure> 但是实际上运行上面代码得到的结果是： <figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sleep</span> <span class="keyword">for</span> a moment <span class="literal">and</span> initialize channel c</span><br><span class="line"><span class="built_in">send</span> <span class="literal">true</span> <span class="keyword">to</span> channel</span><br><span class="line">Done</span><br></pre></td></tr></table></figure> 在 go 的 for...range 循环中，使用值拷贝的方式代替被遍历元素本身。在上面的代码中，channel <code>c</code> 尚未初始化就在创建的 goroutine 中使用了，所以实际上使用 for...range 的对象是个 nil channel，因此对其的读取操作会永远阻塞。</p>
<p>将初始化放在读取之前，就能获得我们期望的结果。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">	c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> d := <span class="keyword">range</span> c &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;receive a value: &quot;</span>, d)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;sleep for a moment and initialize channel c&quot;</span>)</span><br><span class="line">	<span class="comment">//c = make(chan bool, 1)</span></span><br><span class="line">	c &lt;- <span class="literal">true</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;send true to channel&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://www.godesignpatterns.com/2014/05/nil-channels-always-block.html">Nil Channels Always Block</a></li>
<li><a href="https://xiaozhou.net/something-about-range-of-go-2016-04-10.html">聊聊Go中的Range关键字</a></li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang/JSON | 数值的反序列化和空值的序列化</title>
    <url>/2017/11/29/golang-json-number-unmarshal-null-marshal/</url>
    <content><![CDATA[<p><code>encoding/json</code>包在web开发的过程中，占据着相当重要的角色。然而角色有多重，坑就有多大。下面记录的便是在踩json雷中的辛酸泪(&gt;﹏&lt;)</p>
<h2 id="反序列化时的数值处理及float64精度问题">反序列化时的数值处理及float64精度问题</h2>
<p>众所周知（其实是最近才知道），<strong>golang原生的<code>encoding/json</code>在反序列化的时候，默认情况下会把所有数值类型转成float64类型</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_std_json</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(<span class="string">`[100, null, 1.2, &quot;1234&quot;]`</span>), &amp;m); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;type: %T, value: %v\n&quot;</span>,v, v )</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Unmarshal error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用上面的函数会输出： <figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span>: <span class="title">float64</span>, <span class="title">value</span>: 100</span></span><br><span class="line"><span class="class"><span class="keyword">type</span>: &lt;nil&gt;, <span class="title">value</span>: &lt;nil&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">type</span>: <span class="title">float64</span>, <span class="title">value</span>: 1.2</span></span><br><span class="line"><span class="class"><span class="keyword">type</span>: <span class="title">string</span>, <span class="title">value</span>: 1234</span></span><br></pre></td></tr></table></figure> 一般情况下是不会有什么问题的，但是，如果我们传进去的是一个大整型（超过float64定义的范围），那么就粗大事了。举个栗子： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_std_json_large</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(<span class="string">`[100, 1234567890123456789, null, 1.2, &quot;1234&quot;]`</span>), &amp;m); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;type: %T, value: %v\n&quot;</span>,v, v )</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Unmarshal error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 调用上面的函数会输出： <figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span>: <span class="title">float64</span>, <span class="title">value</span>: 100</span></span><br><span class="line"><span class="class"><span class="keyword">type</span>: <span class="title">float64</span>, <span class="title">value</span>: 1.2345678901234568<span class="title">e</span>+18</span></span><br><span class="line"><span class="class"><span class="keyword">type</span>: &lt;nil&gt;, <span class="title">value</span>: &lt;nil&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">type</span>: <span class="title">float64</span>, <span class="title">value</span>: 1.2</span></span><br><span class="line"><span class="class"><span class="keyword">type</span>: <span class="title">string</span>, <span class="title">value</span>: 1234</span></span><br></pre></td></tr></table></figure> 注意到了吗？上面的数字<code>1234567890123456789</code>是一个在int64范围内，但是在float64之外的数值。反序列化之后，这个值变成了<code>123456789012345678</code>！！！试想一下，本来你手头有1234567890个亿，经过<code>json.Unmarshal</code>，就只剩123456789个亿了┭┮﹏┭┮</p>
<p>但是没关系，此事并非不可解。下面我们来看看两种解决方案。</p>
<h3 id="方法一使用标准库的json.decoder">方法一：使用标准库的json.Decoder</h3>
<p>golang的标准json库提供了一种方案：将数值类型直接转成<code>json.Number</code>类型，让用户稍后自己根据需要转成数值。具体的实现是利用json库提供的<code>Decoder</code>： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_std_json_large_withNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> m []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	decoder := json.NewDecoder(strings.NewReader(<span class="string">`[100, 1234567890123456789, null, 1.2, &quot;1234&quot;]`</span>))</span><br><span class="line">        decoder.UseNumber()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := decoder.Decode(&amp;m); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;type: %T, value: %v\n&quot;</span>,v, v )</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Unmarshal error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 调用上面的函数会输出： <figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span>: <span class="title">json</span>.<span class="title">Number</span>, <span class="title">value</span>: 100</span></span><br><span class="line"><span class="class"><span class="keyword">type</span>: <span class="title">json</span>.<span class="title">Number</span>, <span class="title">value</span>: 1234567890123456789</span></span><br><span class="line"><span class="class"><span class="keyword">type</span>: &lt;nil&gt;, <span class="title">value</span>: &lt;nil&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">type</span>: <span class="title">json</span>.<span class="title">Number</span>, <span class="title">value</span>: 1.2</span></span><br><span class="line"><span class="class"><span class="keyword">type</span>: <span class="title">string</span>, <span class="title">value</span>: 1234</span></span><br></pre></td></tr></table></figure> 这样，我们的1234567890个亿还是1234567890个亿。可以把<code>json.Number</code>当成字符串，标准库对于这个类型还提供了一些方便的方法来取出数值。具体可以参考<a href="https://golang.org/pkg/encoding/json/#Number">json.Number</a></p>
<p>以上的代码在：<a href="https://play.golang.org/p/uzgeERW4N0">这里</a></p>
<p>一般来说，这个方法已经很好的解决了float64的精度问题。但是我们还可以找个替代方案。 &gt; 因为<code>type Number string</code>，所以之前以为使用这种方法，在反序列化之后，无法区分数值和数值字符串。在写这篇文章的时候才突然想起来，在golang中，使用关键字<code>type</code>定义的是新的类型。也就是说，在golang看来，<code>Number</code>和<code>string</code>是两种不一样的类型。但是如果使用<code>Number</code>，在取值的时候，必不可免需要进行类型判断。所以才会考虑找个替代库。</p>
<h3 id="方法二换个库吧">方法二：换个库吧</h3>
<p><a href="https://github.com/json-iterator/go">jsoniter</a>是国人写的一个用来替代标准库的json库。这个库允许我们自定义类型解析函数。在其github中的某个issue中提到优先把数值当成int64处理的方法。以下代码注册了一个类型解析函数，这个函数会首先尝试把数值解析成int64，解析失败则将其当成float64处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/json-iterator/go&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    decodeNumberAsInt64IfPossible := <span class="function"><span class="keyword">func</span><span class="params">(ptr unsafe.Pointer, iter *jsoniter.Iterator)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> iter.WhatIsNext() &#123;</span><br><span class="line">        <span class="keyword">case</span> jsoniter.NumberValue:</span><br><span class="line">            <span class="keyword">var</span> number json.Number</span><br><span class="line">            iter.ReadVal(&amp;number)</span><br><span class="line">            i, err := strconv.ParseInt(<span class="keyword">string</span>(number), <span class="number">10</span>, <span class="number">64</span>) </span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                *(*<span class="keyword">interface</span>&#123;&#125;)(ptr) = i </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;   </span><br><span class="line">            f, err := strconv.ParseFloat(<span class="keyword">string</span>(number), <span class="number">64</span>) </span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                *(*<span class="keyword">interface</span>&#123;&#125;)(ptr) = f </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="comment">// Not much we can do here.</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            *(*<span class="keyword">interface</span>&#123;&#125;)(ptr) = iter.Read()</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    jsoniter.RegisterTypeDecoderFunc(<span class="string">&quot;interface &#123;&#125;&quot;</span>, decodeNumberAsInt64IfPossible)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后，我们就可以像使用标准库那样，调用jsoniter的<code>Unmarshal</code>方法进行反序列化了。</p>
<h2 id="当一切成空序列化时该怎么办">当一切成空，序列化时该怎么办</h2>
<p>官方文档有云： <figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">a</span> nil slice encodes <span class="keyword">as</span> <span class="keyword">the</span> <span class="literal">null</span> JSON <span class="built_in">value</span>.</span><br><span class="line">A nil pointer encodes <span class="keyword">as</span> <span class="keyword">the</span> <span class="literal">null</span> JSON <span class="built_in">value</span>.</span><br><span class="line">A nil interface <span class="built_in">value</span> encodes <span class="keyword">as</span> <span class="keyword">the</span> <span class="literal">null</span> JSON <span class="built_in">value</span>.</span><br></pre></td></tr></table></figure> 举个例子： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// map</span></span><br><span class="line">	<span class="keyword">var</span> sm <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	sb, err := json.Marshal(sm)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s, %v, err: %v\n&quot;</span>, <span class="keyword">string</span>(sb), sb, err)</span><br><span class="line">	<span class="comment">// slice</span></span><br><span class="line">	<span class="keyword">var</span> ss []<span class="keyword">string</span></span><br><span class="line">	sb, err = json.Marshal(ss)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s, %v, err: %v\n&quot;</span>, <span class="keyword">string</span>(sb), sb, err)</span><br><span class="line">	<span class="keyword">var</span> sbs []<span class="keyword">byte</span></span><br><span class="line">	sb, err = json.Marshal(sbs)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s, %v, err: %v\n&quot;</span>, <span class="keyword">string</span>(sb), sb, err)</span><br><span class="line">	<span class="comment">// pointer</span></span><br><span class="line">	<span class="keyword">var</span> sp *<span class="keyword">string</span></span><br><span class="line">	sb, err = json.Marshal(sp)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s, %v, err: %v\n&quot;</span>, <span class="keyword">string</span>(sb), sb, err)</span><br><span class="line">	<span class="comment">// interface</span></span><br><span class="line">	<span class="keyword">var</span> si <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	sb, err = json.Marshal(si)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s, %v, err: %v\n&quot;</span>, <span class="keyword">string</span>(sb), sb, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span><span class="string">,</span> [<span class="number">110</span> <span class="number">117</span> <span class="number">108</span> <span class="number">108</span>]<span class="string">,</span> <span class="attr">err:</span> <span class="string">&lt;nil&gt;</span></span><br><span class="line"><span class="literal">null</span><span class="string">,</span> [<span class="number">110</span> <span class="number">117</span> <span class="number">108</span> <span class="number">108</span>]<span class="string">,</span> <span class="attr">err:</span> <span class="string">&lt;nil&gt;</span></span><br><span class="line"><span class="literal">null</span><span class="string">,</span> [<span class="number">110</span> <span class="number">117</span> <span class="number">108</span> <span class="number">108</span>]<span class="string">,</span> <span class="attr">err:</span> <span class="string">&lt;nil&gt;</span></span><br><span class="line"><span class="literal">null</span><span class="string">,</span> [<span class="number">110</span> <span class="number">117</span> <span class="number">108</span> <span class="number">108</span>]<span class="string">,</span> <span class="attr">err:</span> <span class="string">&lt;nil&gt;</span></span><br><span class="line"><span class="literal">null</span><span class="string">,</span> [<span class="number">110</span> <span class="number">117</span> <span class="number">108</span> <span class="number">108</span>]<span class="string">,</span> <span class="attr">err:</span> <span class="string">&lt;nil&gt;</span></span><br></pre></td></tr></table></figure> 注意哦，这里序列化得到的结果并不是大小为0的byte切片，而是字符串<code>null</code>！！！当然，如果不想输出字符串<code>null</code>，那么可以修改为： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// map</span></span><br><span class="line">	sm := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">	sb, err := json.Marshal(sm)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s, %v, err: %v\n&quot;</span>, <span class="keyword">string</span>(sb), sb, err)</span><br><span class="line">	<span class="comment">// slice</span></span><br><span class="line">	ss := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">	sb, err = json.Marshal(ss)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s, %v, err: %v\n&quot;</span>, <span class="keyword">string</span>(sb), sb, err)</span><br><span class="line">	<span class="comment">// bytes</span></span><br><span class="line">	sbs := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>)</span><br><span class="line">	sb, err = json.Marshal(sbs)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s, %v, err: %v\n&quot;</span>, <span class="keyword">string</span>(sb), sb, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;&#125;, <span class="selector-attr">[123 125]</span>, <span class="selector-tag">err</span>: &lt;<span class="selector-tag">nil</span>&gt;</span><br><span class="line"><span class="selector-attr">[]</span>, <span class="selector-attr">[91 93]</span>, <span class="selector-tag">err</span>: &lt;<span class="selector-tag">nil</span>&gt;</span><br><span class="line">&quot;&quot;, <span class="selector-attr">[34 34]</span>, <span class="selector-tag">err</span>: &lt;<span class="selector-tag">nil</span>&gt;</span><br></pre></td></tr></table></figure> 此时，输出分别是对应类型的零值的字符串表示。例如，空 Map 的序列化值为字符串<code>&#123;&#125;</code></p>
<p><strong>所以，如果你只是希望在空的情况下，序列化得出空的结果，那么最好在序列化之前进行一次判空。</strong></p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://golang.org/pkg/encoding/json/#Unmarshal"><code>json.Unmarshal(data []byte, v interface&#123;&#125;) error</code></a></li>
<li><a href="https://golang.org/pkg/encoding/json/#Marshal"><code>json.Marshal(v interface&#123;&#125;) ([]byte, error)</code></a></li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>hello|我的第一个chrome扩展程序</title>
    <url>/2017/07/21/hello-%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAchrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>自从Ele偶然发现我大深圳图书馆的藏书紧跟时代潮流，以及以前不知道的预借功能和邮寄功能之后，amazon的unlimited就被我毫不留情地打入冷宫，然后几年前办理过的深图借书证开始进入宠妃行列。至此，Ele便过上了在豆瓣mark书，然后跑到<a href="http://www.szlib.org.cn/">深圳图书馆</a>找书的日子。</p>
<p>这里要安利深图的预借和邮寄功能。可以预借的书提交预借申请后，图书馆就会帮你找书，然后投递到指定的地方，接下来只需要带着图书证去取书即可。如果你不想多走几步的话，那么对于那些标明可以邮寄的书籍，仅需6软妹币，快递上门不是梦～～</p>
<p>虽然说在图书馆找书这种事已经基本可以交给图书馆了，但是还是要打开深图的页面搜索一下是否有你想要的图书。对于懒癌晚期患者Ele来说，要在豆瓣深图切来切去也是烦得不要不要的，更何况，有时候你根本在深图上搜不到你要的书籍。</p>
<p>不想做无用功，所以Ele把主意打到了chrome扩展程序&lt;(￣︶￣)&gt;。</p>
<p>啰嗦了那么久，下面进入正题。</p>
<h2 id="简个介">简个介</h2>
<p>chrome扩展程序是可以修改/加强chrome浏览器功能的程序，使用前端语言，例如HTML、javas和CSS进行编写。</p>
<p>一个安装好了的chrome扩展程序大概是这个样子的：</p>
<p><img src="https://developer.chrome.com/static/images/index/gmail-small.png" /></p>
<p>你可以在<a href="http://chrome.google.com/webstore">chrome网上应用商店</a>上下载安装别人发布的扩展程序。如果找不到满足你想要功能的，也可以自食其力，自己写一个。</p>
<p>下面，我们就来写我们的第一个chrome扩展程序吧。</p>
<h2 id="第一行代码">第一行代码</h2>
<p>这里要完成的扩展程序将实现这样一个功能：<strong><em>读取当前页面（以豆瓣读书为例）的书籍名，然后在深图搜索相关信息，并将其展示在弹出页面中。</em></strong></p>
<p>首先，我们得新建一个目录放置扩展程序相关的文件。这里，我将其命名为<code>searchSZlib</code>。</p>
<p>接下来，需要在这个目录下创建一个名为<code>manifest.json</code>的manifest文件。这是一个json格式的文件，保存了扩展程序的元数据（扩展名、描述、版本号等）。此外，我们还会用它来告诉chrome，这个扩展程序将要做什么、需要什么权限等等。关于这个文件的详细信息，可以参考<a href="https://developer.chrome.com/extensions/manifest">manifest文件格式文档</a>。</p>
<p>这里，我们的<code>manifest.json</code>长这样：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;manifest_version&quot;</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Search in SZLib&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;This extension search the book shown in the current page in szlib.org.cn&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.1&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;browser_action&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;default_icon&quot;</span>: <span class="string">&quot;icon.png&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;default_popup&quot;</span>: <span class="string">&quot;search.html&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;permissions&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;activeTab&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tabs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://www.szlib.org.cn/*&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;background&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: [<span class="string">&quot;search.js&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里说明一下： * <code>manifest_version</code>，<code>name</code>，<code>version</code>是必填字段，分别表示扩展程序要求的manifest文件格式版本号（整型，对于chrome 18，必须填2），扩展程序的主要标识（最大45个字符，会展示在安装窗口、扩展管理页面和chrome商店上），扩展版本号。 * <code>description</code>：推荐填写字段。扩展的描述信息，必须同时适于展示在浏览器的扩展管理页面和chrome商店上。 * <code>browser_action</code>：可选字段，表示浏览器行为。 - <code>default_icon</code>：可选字段，出现在chrome工具栏上的扩展程序图标。支持旧式语法（即上面代码中的字符串格式）。新式写法如下： <figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;default_icon&quot;</span>: &#123;</span><br><span class="line">	<span class="string">&quot;16&quot;</span>: <span class="string">&quot;images/icon16.png&quot;</span>,</span><br><span class="line">       <span class="string">&quot;24&quot;</span>: <span class="string">&quot;images/icon24.png&quot;</span>,</span><br><span class="line">       <span class="string">&quot;32&quot;</span>: <span class="string">&quot;images/icon32.png&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - <code>default_popup</code>：可选字段，指定用户点击扩展程序图标的时候弹出的HTML页面。 * <code>permissions</code>：可选字段，声明扩展程序所需权限。权限可以是某个已知字符串（例如“geolocation”），或者匹配要访问的一个/多个主机的模式。这里，由于我们需要访问当前标签页，所以声明了<code>activeTab</code>权限。声明<code>tabs</code>权限，以备可以点击搜索结果时在新的标签中展示页面信息(即调用<code>chrome.tabs</code> API)。另外，因为我们还要访问深图，所以还得把深图的域名加上。 * <code>background</code>：可选字段。当你需要扩展程序常驻后台的时候，就需要声明此字段的内容了。通常，后台页面是不需要什么布局的，因此仅使用JavaScript文件就可以了。如果指定了<code>scripts</code>，那么后台页面将会是一个包含该属性中列出的每一个JavaScript文件的页面。</p>
<p>声明完<code>manifest.json</code>之后，我们就要准备<code>manifest.json</code>中提到的两个资源：<code>icon.png</code>和<code>search.html</code>了。这就完完全全是前端的事了。</p>
<p>我们把图标保存到<code>searchSZlib</code>下，并在同个目录下新建<code>search.html</code>文件。因为我们只需要点击扩展程序，然后展示搜索结果，所以这个HTML文件比较简单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Search in SZLib<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="selector-id">#searchresult</span> &#123;</span></span><br><span class="line">			width: 150px;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-3.2.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;search.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;status&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;searchresult&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们只需要两个div，一个表示搜索状态，另一个展示搜索结果。另外，因为JavaScript写起来太麻烦了（其实是因为Ele是个前端渣(ノへ￣、)捂脸），所以还得引入jQuery文件。</p>
<p>接下来准备<code>search.js</code>。<code>search.js</code>需要完成的工作是： 1. 搜索图书。查看深图搜书页面，通过开发者工具可以看到请求的URL是<code>"http://www.szlib.org.cn/Search/searchshow.jsp?v_tablearray=bibliosm,serbibm,apabibibm,mmbibm,&amp;v_index=title&amp;v_value=" + encodeURIComponent(书名) + "&amp;sortfield=score&amp;sorttype=desc"</code> 2. 提取搜索结果列表。审查页面，可以看到搜索结果都放在<code>&lt;ul class="booklist"&gt;&lt;/ul&gt;</code>中。 3. 将搜索结果填充到<code>&lt;div id="searchresult"&gt;&lt;/div&gt;</code>中。这里要注意的是，结果中的链接都是相对路径，因此我们还需要对结果的链接进行进一步的处理，以便点击的时候可以得到真实的页面。 4. 给链接添加<code>click</code>事件，把页面在新的标签页中展示出来。</p>
<p><code>search.js</code>的详细代码见<a href="https://github.com/ictar/Gadgets/blob/master/chrome_extension/searchSZlib/search.js">search.js</a></p>
<p>最后，该目录所有文件如下： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tree </span><br><span class="line">.</span><br><span class="line">└── searchSZlib</span><br><span class="line">    ├── icon.png</span><br><span class="line">    ├── jquery-3.2.1.min.js</span><br><span class="line">    ├── manifest.json</span><br><span class="line">    ├── search.html</span><br><span class="line">    └── search.js</span><br></pre></td></tr></table></figure> 完整的程序可以在<a href="https://github.com/ictar/Gadgets/tree/master/chrome_extension/searchSZlib">git</a>上找到。</p>
<h2 id="安装一下">安装一下</h2>
<p>代码写完了，我们来用实践检验下成果吧。</p>
<p>打开<code>chrome浏览器菜单 -&gt; 更多工具 -&gt; 扩展程序 -&gt; 开发者模式 -&gt; 加载已解压的扩展程序...</code>，选择<code>searchSZlib</code>目录，然后就可以看到工具栏上出现扩展程序的图标了。现在点击一下图标试试： <img src="/img/201707221127.png" /></p>
<p>如果代码有变动，只需要点击<code>扩展程序</code>页面中的<code>重新加载</code>即可。</p>
<p>另外，还可以通过右击扩展程序按钮，选择<code>审查弹出内容</code>来进行调试。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://developer.chrome.com/extensions">Chrome extensions</a></li>
</ul>
]]></content>
      <tags>
        <tag>HelloWorld</tag>
        <tag>Chrome</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Go|踩坑不完全记录之panic</title>
    <url>/2018/05/09/golang%E7%9A%84%E8%B8%A9%E5%9D%91%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AE%B0%E5%BD%95%E4%B9%8Bpanic/</url>
    <content><![CDATA[<p>根据 <a href="https://golang.org/ref/spec#Handling_panics">go spec</a> 中对于处理 panic 的描述： &gt; 当执行一个函数 <code>F</code> 时，显式调用 <code>panic</code> 或者运行时的 panic 都会终止函数 <code>F</code> 的执行。此时，函数 <code>F</code> 中 defer 的函数会照常执行。接下来，执行函数 <code>F</code> 的调用者中 defer 的函数，依此执行至<strong>当前 goroutine</strong> 顶层 defer 的函数。执行完后，退出程序，并报告异常（包括 <code>panic</code> 函数的值）</p>
<p>换句话说，当 panic 出现时，会沿调用堆栈向上执行 defer 函数。这里要特别特别特别注意的是，只会执行<strong>当前 goroutine</strong> 的调用堆栈。也就是说，生成该 goroutine 的那个 goroutine 的 defer 函数是不会执行的！！！！</p>
<p>有点绕口，我们看个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exception</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;exception exits&quot;</span>)</span><br><span class="line">	time.Sleep(time.Second/<span class="number">10</span>)</span><br><span class="line">	<span class="built_in">panic</span>(errors.New(<span class="string">&quot;throw something&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;never executed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;test begins&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;test ends&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> err:=<span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;catch a panic:&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> exception()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码很简单。<code>exception</code> 函数首先 defer 一句退出日志，然后休眠 0.1s 后，抛出一个 panic。在主函数中，我们也 defer 一句退出日志，接着 defer 一个匿名函数，用于捕获 panic。然后，利用 <code>exception</code> 函数创建一个 goroutine，最后休眠 1s 等待 <code>exception</code> 函数执行完成。</p>
<p>上述代码的目的是，在主 goroutine 中能够处理另一个 goroutine 的 panic。然而，运行结果却与之相悖： <figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">test </span>begins</span><br><span class="line">exception exits</span><br><span class="line">panic: throw something</span><br><span class="line"></span><br><span class="line">goroutine 5 [running]:</span><br><span class="line">main.exception()</span><br><span class="line">	/tmp/sandbox343049822/main.go:12 <span class="string">+0</span>x180</span><br><span class="line">created by main.main</span><br><span class="line">	/tmp/sandbox343049822/main.go:23 <span class="string">+0</span>x100</span><br></pre></td></tr></table></figure> 在上面的输出中，函数 <code>exception</code> 执行到 <code>panic</code> 处时，并没有继续执行下去，而是开始执行 defer 的函数。接着，抵达当前 goroutine （id=5）的顶部后，退出程序，并抛出异常信息。此时，main goroutine 中 defer 的函数并没有执行。</p>
<p>一句话总结：<strong>只能在当前 goroutine 处理 panic，不能在当前 goroutine 处理其他 goroutine 产生的 panic！</strong></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>我的年度读书报告生成攻略：第二部分</title>
    <url>/2019/01/14/how_to_generate_annual_read_report_part2/</url>
    <content><![CDATA[<p>上一个部分解释了如何根据目标获取数据源，接下来，可以对已读图书清单进行分析了。</p>
<h2 id="获取指定年度的数据">获取指定年度的数据</h2>
<p>因为我们是对某个年度进行分析，所以需要将特定年度的数据筛选出来。这里，先将数据读进 <code>pandas.DataFrame</code> 中：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame, Series</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;item.json&#x27;</span></span><br><span class="line"><span class="comment"># read</span></span><br><span class="line">records = [json.loads(line.strip().strip(<span class="string">&quot;,&quot;</span>)) <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(path)]</span><br><span class="line">df = DataFrame(records)</span><br><span class="line">print(df.head(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>已读日期保存在 <code>readDate</code> 中，而这个数据的类型是 <code>object</code>，值格式诸如 <code>2018-12-06\n      读过</code>。因此我们需要将其转换成 datetime，以便于提取：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提取有效已读日期</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid_read_date</span>(<span class="params">d</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(d) &gt; <span class="number">0</span>:</span><br><span class="line">        tmp = d.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(tmp) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> tmp[<span class="number">0</span>].strip()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Missing&quot;</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;readDate&#x27;</span>] = df[<span class="string">&#x27;readDate&#x27;</span>].apply(valid_read_date)</span><br><span class="line"><span class="comment">#print(df[&#x27;readDate&#x27;].head())</span></span><br><span class="line">df[<span class="string">&#x27;readDate&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;readDate&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置已读日期为索引</span></span><br><span class="line">df = df.set_index(<span class="string">&#x27;readDate&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>处理后，如果我们想获取的是 2018 的数据，就可以像下面这样直接获得： <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">df_2018 = df[<span class="string">&#x27;2018&#x27;</span>]</span><br></pre></td></tr></table></figure> ## 哪些书籍评分最高，哪些书籍令人大失所望</p>
<p>拿到了指定年份的数据后，我们就可以着手分析了。</p>
<p>每本书的评分信息存储在 <code>rating</code> 字段中。其中，<code>rating5-t</code> 表示五星，<code>rating4-t</code> 表示四星，以此类推。为了方便，我们可以定义一个映射表，又来规整下数据： <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">mapping = &#123;</span><br><span class="line">    <span class="string">&quot;rating5-t&quot;</span>: <span class="string">&quot;5.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rating4-t&quot;</span>: <span class="string">&quot;4.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rating3-t&quot;</span>: <span class="string">&quot;3.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rating2-t&quot;</span>: <span class="string">&quot;2.0&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 然后就可以绘制饼图来看下每个评分占的比例了。 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rating_count</span>(<span class="params">df, path=<span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">    <span class="comment"># 给缺失或未知对评分填上替代值</span></span><br><span class="line">    clean_rating = df[<span class="string">&#x27;rating&#x27;</span>].fillna(<span class="string">&#x27;Missing&#x27;</span>)</span><br><span class="line">    clean_rating[clean_rating == <span class="string">&#x27;date&#x27;</span>] = <span class="string">&#x27;Missing&#x27;</span></span><br><span class="line">    clean_rating[clean_rating == <span class="string">&#x27;&#x27;</span>] = <span class="string">&#x27;Unknown&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> mapping.items():</span><br><span class="line">        clean_rating[clean_rating == k] = v</span><br><span class="line">    rating_counts = clean_rating.value_counts()</span><br><span class="line">    <span class="comment"># 绘图</span></span><br><span class="line">    rc = rating_counts.plot(kind=<span class="string">&#x27;pie&#x27;</span>, autopct=<span class="string">&#x27;%.2f&#x27;</span>, figsize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">    <span class="keyword">if</span> path:</span><br><span class="line">        fig = rc.get_figure()</span><br><span class="line">        fig.savefig(path)</span><br><span class="line"></span><br><span class="line">rating_count(df_2018)</span><br></pre></td></tr></table></figure> 执行后得到：</p>
<p><img src="/img/rating_count_2018.png" /></p>
<p>从绘制出来的图可以看出，2018 年评为四星的书最多，五星的书次之，而最低评级为两星。可以查看具体哪些书强推，那些书令人大失所望：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;rating 5:\n&quot;</span>, df_2018[df_2018[<span class="string">&quot;rating&quot;</span>] == <span class="string">&#x27;rating5-t&#x27;</span>][[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;catagory&#x27;</span>]])</span><br><span class="line">print()</span><br><span class="line">print(<span class="string">&quot;rating 2:\n&quot;</span>, df_2018[df_2018[<span class="string">&quot;rating&quot;</span>] == <span class="string">&#x27;rating2-t&#x27;</span>][[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;catagory&#x27;</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="一年中都看了什么类型的书">一年中都看了什么类型的书？</h2>
<p>为了检查下已阅书籍有没有达到计划中的“博览”，需要检查下类别情况。</p>
<p>从上一篇文章中，我们知道，类别数据可以从 <code>catagory</code> 字段取得。因为该字段的格式有如 <code>文学(1)</code>，因此我们需要对其进行清理，去掉括号，以便统计：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clear_catagory</span>(<span class="params">c</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;(&quot;</span> <span class="keyword">in</span> c:</span><br><span class="line">        <span class="keyword">return</span> c[:c.index(<span class="string">&quot;(&quot;</span>)]</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">df_2018[<span class="string">&quot;catagory&quot;</span>] = df_2018[<span class="string">&quot;catagory&quot;</span>].apply(clear_catagory)</span><br></pre></td></tr></table></figure>
<p>然后就可以像评级信息那样绘制饼图了：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plot</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment"># 引入matplotlib包</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>]<span class="comment"># 设置加载的字体名</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对类别进行计数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">catagory_count</span>(<span class="params">df, path=<span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">    <span class="comment"># 给缺失或未知对类别填上替代值</span></span><br><span class="line">    clean_catagory = df[<span class="string">&#x27;catagory&#x27;</span>].fillna(<span class="string">&#x27;Missing&#x27;</span>)</span><br><span class="line">    clean_catagory[clean_catagory == <span class="string">&#x27;&#x27;</span>] = <span class="string">&#x27;Unknown&#x27;</span></span><br><span class="line">    clean_catagory[clean_catagory == <span class="string">&#x27;not found&#x27;</span>] = <span class="string">u&#x27;文学&#x27;</span></span><br><span class="line">    catagory_counts = clean_catagory.value_counts()</span><br><span class="line">    <span class="comment"># 绘图</span></span><br><span class="line">    cc = catagory_counts.plot(kind=<span class="string">&#x27;pie&#x27;</span>, autopct=<span class="string">&#x27;%.2f&#x27;</span>, figsize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">    <span class="keyword">if</span> path:</span><br><span class="line">        fig = cc.get_figure()</span><br><span class="line">        fig.savefig(path)</span><br><span class="line">    </span><br><span class="line">catagory_count(df_2018)</span><br></pre></td></tr></table></figure>
<p>执行后得到：</p>
<p><img src="/img/catagory_count_2018.png" /></p>
<p>根据上面的图可以得出，2018 涉猎的领域确实有所增加。</p>
<h2 id="查看标签情况">查看标签情况</h2>
<p>类别信息有时过于泛泛，例如上面文学类占了一半有余，但是却无法直观的看出所阅书籍的具体情况。此时标签信息就派上用场了。</p>
<p>照例，因为 <code>tags</code> 字段是像 <code>标签: 绘本 生活 治愈</code> 这样的字符串信息，所以我们需要将无效的<code>“标签: ”</code>部分移除。另外，为了便于统计，我们还需要将其转换为列表：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clear_tag</span>(<span class="params">v</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> v:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    items = v.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> k.startswith(<span class="string">&quot;标签&quot;</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        res.append(k.strip())</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">df_2018[<span class="string">&quot;tags&quot;</span>] = df_2018[<span class="string">&quot;tags&quot;</span>].apply(clear_tag)</span><br></pre></td></tr></table></figure>
<p>这样，我们就可以对标签信息进行统计并生成词云了。这里，词云使用 <code>wordcloud</code> 库来生成：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_count</span>(<span class="params">s</span>):</span></span><br><span class="line">    lc = s.apply(<span class="keyword">lambda</span> x: Series(x).value_counts()).<span class="built_in">sum</span>()</span><br><span class="line">    stat = lc.iteritems()</span><br><span class="line">    <span class="keyword">return</span> &#123;x[<span class="number">0</span>]: x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> stat&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成词云</span></span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">word_cloud_gen</span>(<span class="params">d, save_to=<span class="string">&quot;wordcloud.png&quot;</span></span>):</span></span><br><span class="line">    <span class="comment"># Generate a word cloud image</span></span><br><span class="line">    wordcloud = WordCloud(font_path=<span class="string">&quot;/System/Library/Fonts/STHeiti Medium.ttc&quot;</span>, width=<span class="number">800</span>, height=<span class="number">400</span>).fit_words(d)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Display the generated image:</span></span><br><span class="line">    <span class="comment"># the matplotlib way:</span></span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">    plt.imshow(wordcloud, interpolation=<span class="string">&#x27;bilinear&#x27;</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    <span class="comment"># 保存</span></span><br><span class="line">    <span class="comment">#wordcloud.to_file(save_to)</span></span><br><span class="line"></span><br><span class="line">word_cloud_gen(list_count(df_2018[<span class="string">&quot;tags&quot;</span>]), <span class="string">&quot;wordcloud_2018.png&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>执行后得到：</p>
<p><img src="/img/wordcloud_2018.png" /></p>
<p>好了，2018 看的书有点奇怪 (&gt;﹏&lt;)</p>
<h2 id="总结一下">总结一下</h2>
<p>初尝数据分析，有献丑之嫌。但是通过这一遭，对数据分析这件事倒是增添了几分兴趣。毕竟，分析不了国家大事，可以对小我进行分析呀！</p>
<p>希望 2019 年可以读更多好书，年终可以分析出更多东西，就酱～</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>数据可视化</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>http2 以及 go 实现：第一部分</title>
    <url>/2018/11/06/http2-%E4%BB%A5%E5%8F%8A-go-%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>随着 HTTP 的广泛应用，HTTP/1.0 和 HTTP/1.1 的底层传输模式越来越无法满足对高性能的追求。HTTP/1.0 和 HTTP/1.1 存在以下问题： * 为了实现并发从而减少延迟，HTTP/1.0 和 HTTP/1.1 客户端需要通过多个 TCP 连接发起的多个请求。 * HTTP 头部的重复性和冗余性会引发不必要的网络流量，并引发初始的 TCP 拥塞窗口被快速填满。当多个请求在一个新的 TCP 连接上处理时，上述情况就会导致过多的延迟。</p>
<p>于是，HTTP/2 应运而生。</p>
<p>HTTP/2 支持 HTTP/1.1 的所有核心特性，但是针对 HTTP/1.x 的问题做出了几点改动： * HTTP/2 中的基本协议单元是帧（frame），不同的用途使用不同的帧类型。例如，<strong>HEADERS</strong> 和 <strong>DATA</strong> 帧组成了 HTTP 请求和响应的基础。二进制消息帧的使用也使得消息处理更加高效。 * 请求/响应多路复用。每个 HTTP 请求/响应交互与其自身的流（stream）相关联，流与流之间相互独立。因此，请求或者响应的阻塞并不会阻碍其他流的处理。 * 流控制和优先级控制，以确保高效使用多路复用的流。 * 支持服务端推送（新特性） * 报头压缩，以减少请求大小。</p>
<h2 id="http2-协商">HTTP/2 协商</h2>
<p>HTTP/2 连接是运行在 TCP 连接之上的应用层协议。在创建 HTTP/2 连接之前，需要确定服务端是否支持 HTTP/2。</p>
<h3 id="http2-版本标识">HTTP/2 版本标识</h3>
<ul>
<li><code>h2</code>：基于 TLS（Transport Layer Security）的 HTTP/2 使用此标识</li>
<li><code>h2c</code>：基于使用明文的 TCP 的 HTTP/2。</li>
</ul>
<h3 id="对于-http-uri">对于 “http” URI</h3>
<p>协商过程如下： <img src="/img/http2-starting%20http2.png" alt="h2c 协商" /></p>
<p>有几个需要注意的地方： * 请求 header <strong>必须</strong>有 <code>Upgrade: h2c</code> * 请求 header <strong>必须</strong>包含一个 <code>HTTP2-Settings</code>（内容详见<a href="https://tools.ietf.org/html/rfc7540#section-3.2.1">rfc7540#section-3.2.1</a>） * 不支持 HTTP/2 的服务端直接忽略 <code>Upgrade</code> * 如果 header 包含 <code>Upgrade: h2</code>，服务端直接忽略。 * 服务端发送的第一个 HTTP/2 帧<strong>必须</strong>是一个由 <code>SETTINGS</code> 帧组成的服务端连接序言（preface）。 * 收到 101 响应后，客户端<strong>必须</strong>发送一个包含 <code>SETTINGS</code> 帧的连接序言</p>
<blockquote>
<p><a href="https://tools.ietf.org/html/rfc7540#section-3.5">连接序言</a>作用是作为使用的协议的最终确认，以及用来建立 HTTP/2 连接的初始设置。客户端和服务端的连接序言并不相同。</p>
</blockquote>
<h3 id="对于-https-uri">对于 “https” URI</h3>
<p>另一方面，发起 https 请求的客户则使用 TLS-ALPN（带应用层协议协商扩展的TLS）。</p>
<p>使用 <code>h2</code> 标识。客户端不能发送，并且服务端也不能选择 <code>h2c</code> 标识。</p>
<p>一旦 TLS 协商完成了，客户端和服务端<strong>必须</strong>发送连接序言。</p>
<h2 id="帧frame">帧（frame）</h2>
<p>一旦建立了 HTTP/2 连接，客户端和服务端之间就可以开始交换帧了。</p>
<p>一个帧是由一个固定的 9 个字节的帧头以及后面跟着的不定长度的内容组成。 <img src="/img/http2-frame%20style.png" alt="frame 格式" /></p>
<ul>
<li>Length：frame payload 的大小。值不能超过2^14 (16,384)，除非接收者使用 <code>SETTINGS_MAX_FRAME_SIZE</code> 设置了一个更大的值。该值不能超过 <code>SETTINGS_MAX_FRAME_SIZE</code>。</li>
<li>Type：定义该帧的格式和语义。</li>
<li>Flags：指定特定的帧类型的某些状态信息。</li>
<li>R：保留位</li>
<li>Stream Identifier：流标识符</li>
<li>Frame Payload：帧内容</li>
</ul>
<h2 id="流stream">流（stream）</h2>
<p>流指的是在 HTTP/2 连接中，客户端与服务器之间的独立双向帧交换序列。它有几个重要特性： * 单个 HTTP/2 连接可以包含多个并发打开的流，来自不同流的帧交错传输 * 可以单方建立并使用流，或者由客户端/服务端共享流 * 流可以由任何一端关闭 * 流上发送的帧顺序是很重要的，因为接收者是以它们接收到的帧顺序来处理这些帧的。 * 流标识符是一个整数，由初始化该流的那一端赋值。</p>
<h3 id="流状态">流状态</h3>
<p>一个流的生命周期如下： <img src="/img/http2-stream%20state.png" /></p>
<ul>
<li>idle：空闲状态。所有流的初始状态。</li>
<li>reserved(local)：当发送了 <code>PUSH_PROMISE</code> 帧之后，流便处于该状态。通过将流与由远端初始化的处于打开状态的流相关联，<code>PUSH_PROMISE</code> 帧保留了处于空闲状态的流。位于此状态的流不能发送除了 <code>HEADERS</code> / <code>RST_STREAM</code> / <code>PRIORITY</code> 之外的帧</li>
<li>reserved(remote)：当流处于该状态时，表明该流被远端保留。</li>
<li>open：任意一端都可以使用处于该状态的流来发送<strong>任意类型</strong>的帧。</li>
<li>half-closed(local)：不能使用处于该状态的流来发送除了 <code>WINDOW_UPDATE</code> / <code>PRIORITY</code> / <code>RST_STREAM</code> 之外的帧。</li>
<li>half-closed (remote)：当流处于该状态时，对端就不再会使用它来发送帧了。</li>
<li>closed：流的终止状态。</li>
</ul>
<h3 id="流标识符">流标识符</h3>
<p>流是由一个无符号的 31 位整型所标识的。 * <strong>由客户端初始化的流必须使用奇数流标识符，而由服务端初始化的则必须使用偶数流标识符。</strong> * 而标识符为 0x0 的流则被用于连接控制消息，不能用来建立任何新流。 * 升级为 HTTP/2 的 HTTP/1.1 请求响应时会带流标识符 0x1。升级完成后，对于客户端来说，流 0x1 则处于“half-closed(local)”状态。因此，从 HTTP/1.1 升级上来的客户端不能选择 0x1 作为新的流标识符。 * 新建立的流的标识符数值上必须大于初始端所有已经打开或者保留的流。</p>
<p>流标识符不能被复用。因此，长期存在的连接会导致可用流标识符的耗尽。在这种情况下，如果客户端无法建立一个新的流 ，那么它会创建一个新连接。而当服务端无法建立新的流时，则会发送一个 <code>GOAWAY</code> 帧，以迫使客户端建立新连接。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://tools.ietf.org/html/rfc7540">rfc7540</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/web/wa-http2-under-the-hood/index.html">HTTP/2 幕后原理</a></li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>我的年度读书报告生成攻略：第一部分</title>
    <url>/2018/12/26/how_to_generate_annual_read_report_part1/</url>
    <content><![CDATA[<p>年终惯例是做年度总结，而恰好每年年初都会给自己定一个读书目标。以前总是达标之后心情愉悦便没有然后了，今年突发奇想，想看看过去的一年里，自己都读了什么书，以便有的放矢地安排下一年的读书目标。</p>
<p>需求有了，接下来则是要获取数据了。凑巧我有个习惯，每看一本书会在豆瓣上标记一下。因此，我在豆瓣上的已读清单就是最好的原数据。</p>
<h2 id="创建爬虫">创建爬虫</h2>
<p>对于爬虫工具的选择，以方便为主，所以我选了<a href="https://scrapy.org/">scrapy</a>。</p>
<p>安装好 scrapy 后，创建一个名为 book 的项目： <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">scrapy startproject book</span></span><br></pre></td></tr></table></figure> ## 获取已读图书列表</p>
<p>登陆豆瓣后，找到页面“我读过的书”，就可以看到已阅图书列表了。该页面的 URL 有以下模式： <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>book.douban.com<span class="regexp">/people/</span>&#123;豆瓣id&#125;/collect</span><br></pre></td></tr></table></figure> 首先，我们需要确定下这个页面是否需要登陆才能访问（如果不是的话，还得模拟豆瓣登陆）。确定方法很简单：记录下该页面的 url，退出登陆，然后尝试访问该 url。如果能够正常访问的话，说明某个用户的已读图书列表是公开的。</p>
<p>经过确认，这个页面确实是公开的，这样，我们就不需要进行模拟登陆了。（虽然省去了这一步，但是不知道豆瓣的产品经理是如何考量的，为什么要把用户这个比较私密的属性赤裸裸地暴露在阳光虾呢？）</p>
<p>接下来，借助 chrome 的开发者工具，观察下每一个图书项的组成部分： <img src="/img/20181224-223022.jpg" /></p>
<p>可以发现几点（以下用 xpath 表示法）： * 每一个图书项：<code>//li[@class="subject-item"</code> * 图书名称：<code>div[@class="info"]/h2/a/@title</code> * 图书详情页 url：<code>div[@class="info"]/h2/a/@href</code> * 出版信息：<code>div[@class="info"]/div[@class="pub"]/text()</code> * 评价信息：<code>div[@class="info"]/div[@class="short-note"]/div[1]/span[1]/@class</code> * 读完的日期：<code>div[@class="info"]/div[@class="short-note"]/div[1]/span[@class="date"]/text()</code> * 标签信息：<code>div[@class="info"]/div[@class="short-note"]/div[1]/span[@class="tags"]/text()</code> * 评价信息：<code>div[@class="info"]/div[@class="short-note"]/p[@class="comment"]/text()</code> * 以及下一页：<code>//span[@class="next"]/a/@href</code></p>
<p>因此，我们可以在 <code>book/items.py</code> 中定义我们所需要的属性：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookItem</span>(<span class="params">scrapy.Item</span>):</span></span><br><span class="line">    name = scrapy.Field()</span><br><span class="line">    url = scrapy.Field()</span><br><span class="line">    pub = scrapy.Field()</span><br><span class="line">    rating = scrapy.Field()</span><br><span class="line">    readDate = scrapy.Field()</span><br><span class="line">    tags = scrapy.Field()</span><br><span class="line">    comment = scrapy.Field()</span><br></pre></td></tr></table></figure>
<p>然后在 <code>book/spiders</code> 目录下创建一个爬虫文件 <code>collect_spider.py</code>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&quot;collect&quot;</span> <span class="comment"># 将爬虫命名为 collect</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;douban.com&quot;</span>]</span><br><span class="line">    start_urls = [</span><br><span class="line">        <span class="comment"># 设置起始爬取页面为已阅读书列表首页</span></span><br><span class="line">        <span class="comment"># 这里我把豆瓣 id 信息隐去了，使用时按需替换</span></span><br><span class="line">        <span class="string">&quot;https://book.douban.com/people/******/collect&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="keyword">for</span> subItem <span class="keyword">in</span> response.xpath(<span class="string">&#x27;//li[@class=&quot;subject-item&quot;]&#x27;</span>):</span><br><span class="line">            <span class="comment"># 对于每一个图书项进行操作</span></span><br><span class="line">            item = BookItem()</span><br><span class="line">            item[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;&quot;</span>.join(subItem.xpath(<span class="string">&#x27;div[@class=&quot;info&quot;]/h2/a/@title&#x27;</span>).extract()).strip()</span><br><span class="line">            item[<span class="string">&#x27;url&#x27;</span>] = subItem.xpath(<span class="string">&#x27;div[@class=&quot;info&quot;]/h2/a/@href&#x27;</span>).extract_first(default=<span class="string">&quot;Missing&quot;</span>)</span><br><span class="line">            item[<span class="string">&#x27;pub&#x27;</span>] = <span class="string">&quot;&quot;</span>.join(subItem.xpath(<span class="string">&#x27;div[@class=&quot;info&quot;]/div[@class=&quot;pub&quot;]/text()&#x27;</span>).extract()).strip()</span><br><span class="line">            item[<span class="string">&#x27;rating&#x27;</span>] = subItem.xpath(<span class="string">&#x27;div[@class=&quot;info&quot;]/div[@class=&quot;short-note&quot;]/div[1]/span[1]/@class&#x27;</span>).extract_first(default=<span class="string">&quot;Missing&quot;</span>).strip()</span><br><span class="line">            item[<span class="string">&#x27;readDate&#x27;</span>] = subItem.xpath(<span class="string">&#x27;div[@class=&quot;info&quot;]/div[@class=&quot;short-note&quot;]/div[1]/span[@class=&quot;date&quot;]/text()&#x27;</span>).extract_first(default=<span class="string">&quot;Missing&quot;</span>)</span><br><span class="line">            item[<span class="string">&#x27;tags&#x27;</span>] = <span class="string">&quot;&quot;</span>.join(subItem.xpath(<span class="string">&#x27;div[@class=&quot;info&quot;]/div[@class=&quot;short-note&quot;]/div[1]/span[@class=&quot;tags&quot;]/text()&#x27;</span>).extract())</span><br><span class="line">            item[<span class="string">&#x27;comment&#x27;</span>] = <span class="string">&quot;&quot;</span>.join(subItem.xpath(<span class="string">&#x27;div[@class=&quot;info&quot;]/div[@class=&quot;short-note&quot;]/p[@class=&quot;comment&quot;]/text()&#x27;</span>).extract()).strip()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">        <span class="comment"># 获取下一页地址</span></span><br><span class="line">        next_page = response.xpath(<span class="string">&#x27;//span[@class=&quot;next&quot;]/a/@href&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> next_page: <span class="comment"># 如果存在的话，爬取下一页</span></span><br><span class="line">            url = response.urljoin(next_page[<span class="number">0</span>].extract())</span><br><span class="line">            print(<span class="string">&quot;next: &quot;</span>, url)</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url, callback=self.parse)</span><br></pre></td></tr></table></figure>
<p>之后可以运行下看看爬取结果： <figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>scrapy crawl collect -o items.json</span><br></pre></td></tr></table></figure> &gt; 注意： &gt; 如果爬取过程遇到豆瓣返回 403 的错误，那么需要修改 <code>book/settings.py</code> 中的 USER_AGENT 为配置项 <code>USER_AGENT = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36'</code></p>
<h2 id="获取书籍更多的出版信息">获取书籍更多的出版信息</h2>
<p>为了获得更多的出版信息（如 ISBN），我们需要爬取每个图书的详情页。详情页的 url 我们在上一个步骤就已经可以获得了。</p>
<p>在 <code>book/items.py</code> 中添加详情定义：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookItem</span>(<span class="params">scrapy.Item</span>):</span></span><br><span class="line">    ....</span><br><span class="line">    isbn = scrapy.Field()</span><br><span class="line">    morePub = scrapy.Field()</span><br></pre></td></tr></table></figure>
<p>分析页面代码后修改 <code>collect_spider.py</code>：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">    <span class="keyword">for</span> subItem <span class="keyword">in</span> response.xpath(<span class="string">&#x27;//li[@class=&quot;subject-item&quot;]&#x27;</span>):</span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">if</span> item[<span class="string">&#x27;url&#x27;</span>] <span class="keyword">and</span> item[<span class="string">&#x27;url&#x27;</span>] != <span class="string">&#x27;Missing&#x27;</span>:</span><br><span class="line">            <span class="comment"># 访问详情页，回调函数为 self.parse_item()</span></span><br><span class="line">            request = scrapy.Request(item[<span class="string">&#x27;url&#x27;</span>], callback=self.parse_item)</span><br><span class="line">            request.meta[<span class="string">&#x27;item&#x27;</span>] = item</span><br><span class="line">            <span class="keyword">yield</span> request</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line">    next_page = response.xpath(<span class="string">&#x27;//span[@class=&quot;next&quot;]/a/@href&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> next_page:</span><br><span class="line">        url = response.urljoin(next_page[<span class="number">0</span>].extract())</span><br><span class="line">        print(<span class="string">&quot;next: &quot;</span>, url)</span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(url, callback=self.parse)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self, response</span>):</span> <span class="comment"># 详情页解析方法</span></span><br><span class="line">    item = response.meta[<span class="string">&#x27;item&#x27;</span>]</span><br><span class="line">    item[<span class="string">&#x27;morePub&#x27;</span>] = response.xpath(<span class="string">&#x27;//*[@id=&quot;info&quot;]/text()&#x27;</span>).extract()</span><br><span class="line">    <span class="comment"># 获取 isbn</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(item[<span class="string">&#x27;morePub&#x27;</span>]) &gt;= <span class="number">2</span>:</span><br><span class="line">        isbn = item[<span class="string">&quot;morePub&quot;</span>][-<span class="number">2</span>].strip()</span><br><span class="line">        <span class="keyword">if</span> isbn:</span><br><span class="line">            item[<span class="string">&#x27;isbn&#x27;</span>] = isbn</span><br><span class="line">    <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>
<h2 id="确定书籍所属类别">确定书籍所属类别</h2>
<p>因为想对图书类别进行分析，而豆瓣图书是没有类别信息的，所以得想个办法获取到对应图书的类别信息。</p>
<p>通过 <a href="http://opac.calis.edu.cn/opac/simpleSearch.do">CALIS 联合目录公共检索系统</a> 就可以根据 ISBN 查询到对应到图书类别信息。</p>
<p>接下来就是分析模拟查询请求了。再次借助 chrome 的开发者工具，进行一次图书检索，看看会出现什么样子的请求交互：</p>
<p><img src="/img/20181226-204925.jpg" /></p>
<p>因此，查询方法如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">queryCatagory</span>(<span class="params">isbn</span>):</span></span><br><span class="line">    url = <span class="string">&quot;http://opac.calis.edu.cn/opac/doSimpleQuery.do&quot;</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&quot;actionType&quot;</span>: <span class="string">&quot;doSimpleQuery&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pageno&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;pagingType&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;operation&quot;</span>: <span class="string">&quot;searchRetrieve&quot;</span>,</span><br><span class="line">        <span class="string">&quot;version&quot;</span>: <span class="number">1.1</span>,</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: <span class="string">&#x27;(bath.isbn=&quot;&#123;0&#125;*&quot;)&#x27;</span>.<span class="built_in">format</span>(isbn),</span><br><span class="line">        <span class="string">&quot;sortkey&quot;</span>: <span class="string">&quot;title&quot;</span>,</span><br><span class="line">        <span class="string">&quot;maximumRecords&quot;</span>: <span class="number">50</span>,</span><br><span class="line">        <span class="string">&quot;startRecord&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;dbselect&quot;</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">        <span class="string">&quot;langBase&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">        <span class="string">&quot;conInvalid&quot;</span>: <span class="string">&quot;检索条件不能为空&quot;</span>,</span><br><span class="line">        <span class="string">&quot;indexkey&quot;</span>: <span class="string">&quot;bath.isbn|frt&quot;</span>,</span><br><span class="line">        <span class="string">&quot;condition&quot;</span>: isbn,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    resp = requests.post(url, data)</span><br><span class="line">    <span class="keyword">if</span> resp.status_code != <span class="number">200</span>: <span class="keyword">return</span> <span class="string">&quot;not found&quot;</span></span><br><span class="line">    page = etree.HTML(resp.text)</span><br><span class="line">    <span class="comment"># 这里我们只获取顶级分类</span></span><br><span class="line">    info = page.xpath(<span class="string">&#x27;//*[@id=&quot;browser&quot;]/li/span/a/u&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> info:</span><br><span class="line">        <span class="keyword">return</span> info[<span class="number">0</span>].text</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;not found&quot;</span></span><br></pre></td></tr></table></figure>
<p>先将类别信息添加到 <code>book/items.py</code> 中：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookItem</span>(<span class="params">scrapy.Item</span>):</span></span><br><span class="line">    ....</span><br><span class="line">    catagory = scrapy.Field()</span><br></pre></td></tr></table></figure>
<p>我们把上面的方法添加在 <code>collect_spider.py</code> 中，然后在获取到 isbn 后查询类别信息：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self, response</span>):</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment"># get isbn</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(item[<span class="string">&#x27;morePub&#x27;</span>]) &gt;= <span class="number">2</span>:</span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">if</span> isbn:</span><br><span class="line">            ....</span><br><span class="line">            <span class="comment"># get category</span></span><br><span class="line">            item[<span class="string">&#x27;catagory&#x27;</span>] = queryCatagory(isbn)</span><br><span class="line">    <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>
<p>最后运行下爬虫即可：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>scrapy crawl collect -o items.json</span><br></pre></td></tr></table></figure>
<h2 id="小结一下">小结一下</h2>
<p>数据分析的第一步大抵都是确定分析目标，然后根据目标获取相应数据。</p>
<p>接下来，就是撸起袖子开始分析了～</p>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>译 | 在 Go 1.13 处理错误</title>
    <url>/2019/10/21/trans-go1-13-errors/</url>
    <content><![CDATA[<p>原文：<a href="https://blog.golang.org/go1.13-errors">Working with Errors in Go 1.13</a></p>
<hr />
<h4 id="介绍">介绍</h4>
<p>Go 将<a href="https://blog.golang.org/errors-are-values">错误视为值</a>的这种行为在过去十年为我们服务良好。虽然标准库对错误的支持很少（只有 <code>errors.New</code> 和 <code>fmt.Errorf</code> 函数，它们产生仅包含消息的错误），但是内置的 <code>error</code> 接口允许 Go 程序员添加所需的任何信息。仅需一个实现 <code>Error</code> 方法的类型即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> QueryError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Query <span class="keyword">string</span></span><br><span class="line">    Err   error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *QueryError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.Query + <span class="string">&quot;: &quot;</span> + e.Err.Error() &#125;</span><br></pre></td></tr></table></figure>
<p>像这样的错误类型无处不在，而它们存储的信息差异很大，从时间戳到文件名再到服务器地址。通常，该信息包含另一个较低层次的错误，这个错误提供额外的上下文。</p>
<p>在 Go 代码中，一个错误包含另一个错误的模式非常普遍，以至于经过<a href="https://golang.org/issue/29934">广泛讨论</a>，Go 1.13 为其添加了明确的支持。本文描述了标准库提供的支持：<code>errors</code> 包中的三个新函数，以及用于 <code>fmt.Errorf</code> 的一个新格式化动词。</p>
<p>在详细描述更改之前，让我们回顾一下在 Go 的早期版本中是如何检查和构造错误的。</p>
<h4 id="go-1.13-之前的错误">Go 1.13 之前的错误</h4>
<h4 id="检查错误">检查错误</h4>
<p>Go 的错误是值。程序通过几种方式，基于这些值来做出决定。最常见的方式是将错误与 <code>nil</code> 进行比较，以查看操作是否失败。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// something went wrong</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时，我们会将错误与一个已知的 <em>标记</em> 值进行比较，以查看是否发生了特定的错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrNotFound = errors.New(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == ErrNotFound &#123;</span><br><span class="line">    <span class="comment">// something wasn&#x27;t found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个错误值可以是任意类型，只要它满足了语言定义的 <code>error</code> 接口。程序可以使用类型断定或者类型选择，将错误值视为更具体的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NotFoundError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *NotFoundError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.Name + <span class="string">&quot;: not found&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e, ok := err.(*NotFoundError); ok &#123;</span><br><span class="line">    <span class="comment">// e.Name wasn&#x27;t found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="添加信息">添加信息</h4>
<p>通常，函数沿调用栈传递错误，同时向其添加信息，例如对错误发生时的情况的简要概述。一种简单的实现方式是构造一个包含上一个错误的文本的新错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decompress %v: %v&quot;</span>, name, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>fmt.Errorf</code> 创建新错误会丢弃除了文本外原始错误中的所有所有内容。正如从上面的 <code>QueryError</code> 所看到的，有时，我们可能想要定义一个包含底层错误的新的错误类型，并将其保留以供代码检查。下面又是 <code>QueryError</code>： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> QueryError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Query <span class="keyword">string</span></span><br><span class="line">    Err   error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 程序可以查看 <code>*QueryError</code> 的值，然后基于底层错误进行决策。有时，你会看到这被成为“解封”错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission &#123;</span><br><span class="line">    <span class="comment">// query failed because of a permission problem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准库中的 <code>os.PathError</code> 类型是一个错误包含另一个错误的又一个例子。</p>
<h4 id="go-1.13-中的错误">Go 1.13 中的错误</h4>
<h4 id="unwrap-方法">Unwrap 方法</h4>
<p>Go 1.13 为 <code>errors</code> 和 <code>fmt</code> 标准库包引入了新特性，以简化处理包含另一个错误的错误。其中最重要的是约定而不是更改：包含另一个错误的错误可以实现 <code>Unwrap</code> 方法，返回底层错误。如果 <code>e1.Unwrap()</code> 返回 <code>e2</code>，那么我们说 <code>e1</code> _封装__ 了 <code>e2</code>，并且你可以 <em>解封</em> <code>e1</code> 以获得 <code>e2</code>。</p>
<p>遵循此约定，我们可以为上面的 <code>QueryError</code> 类型提供一个 <code>Unwrap</code> 方法，该方法返回包含的错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *QueryError)</span> <span class="title">Unwrap</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> e.Err &#125;</span><br></pre></td></tr></table></figure>
<p>解封错误的结果可能本身包含 <code>Unwrap</code> 方法。我们称由重复解封产生的错误序列为 <em>错误链</em>。</p>
<h4 id="使用-is-和-as-函数检查错误">使用 Is 和 As 函数检查错误</h4>
<p>Go 1.13 的 <code>errors</code> 包包含了两个用来检查错误的新函数：<code>Is</code> 和 <code>As</code>。</p>
<p><code>errors.Is</code> 函数将一个错误与另一个值进行比较。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Similar to:</span></span><br><span class="line"><span class="comment">//   if err == ErrNotFound &#123; … &#125;</span></span><br><span class="line"><span class="keyword">if</span> errors.Is(err, ErrNotFound) &#123;</span><br><span class="line">    <span class="comment">// something wasn&#x27;t found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 而 <code>As</code> 函数测试错误是否为特定的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Similar to:</span></span><br><span class="line"><span class="comment">//   if e, ok := err.(*QueryError); ok &#123; … &#125;</span></span><br><span class="line"><span class="keyword">var</span> e *QueryError</span><br><span class="line"><span class="keyword">if</span> errors.As(err, &amp;e) &#123;</span><br><span class="line">    <span class="comment">// err is a *QueryError, and e is set to the error&#x27;s value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最简单的情况下，<code>errors.Is</code> 函数的行为类似于与标记值的比较，而 <code>errors.As</code> 函数的行为类似于类型声明。但是，在处理封装错误时，这些函数会考虑错误链中的所有错误。我们再看看上面的例子，解封 <code>QueryError</code> 以检查底层错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission &#123;</span><br><span class="line">    <span class="comment">// query failed because of a permission problem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>errors.Is</code> 函数，我们可以这样写： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> errors.Is(err, ErrPermission) &#123;</span><br><span class="line">    <span class="comment">// err, or some error that it wraps, is a permission problem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>errors</code> 包还包含了一个新的 <code>Unwrap</code> 函数，它返回错误的 <code>Unwrap</code> 方法的调用结果，或者在错误没有 <code>Unwrap</code> 方法时返回 <code>nil</code>。通常，最好使用 <code>errors.Is</code> 或者 <code>errors.As</code>，因为这些函数将在一次调用中检查整个链。</p>
<h4 id="使用-w-封装错误">使用 %w 封装错误</h4>
<p>如前所述，通常我们会使用 <code>fmt.Errorf</code> 函数来给错误添加额外的信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decompress %v: %v&quot;</span>, name, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Go 1.13 中，<code>fmt.Errorf</code> 函数支持一个新的动词：<code>%w</code>。当存在该动词时，<code>fmt.Errorf</code> 返回的错误将带有一个 <code>Unwrap</code> 方法，这个方法会返回 <code>%w</code> 的参数，而这个参数必须是一个错误。除此之外，<code>%w</code> 与 <code>%v</code> 相同。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Return an error which unwraps to err.</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decompress %v: %w&quot;</span>, name, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 使用 <code>%w</code> 来封装错误也使其可用于 <code>errors.Is</code> 和 <code>errors.As</code>： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := fmt.Errorf(<span class="string">&quot;access denied: %w”, ErrPermission)</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">if errors.Is(err, ErrPermission) ...</span></span><br></pre></td></tr></table></figure> #### 是否封装</p>
<p>无论是通过 <code>fmt.Errorf</code> 还是实现自定义类型，当为错误添加额外的上下文时，你都需要确定新的错误是否应该封装原始错误。这个问题并没有唯一的答案。它取决于创建新错误的上下文。封装错误已将其暴露给调用者。当封装会暴露实现细节时，不要封装。</p>
<p>举个例子，假设有一个 <code>Parse</code> 函数，它从 <code>io.Reader</code> 读取复杂结构的数据。如果发生错误，我们希望可能报告错误发生代码行号和列号。如果在从 <code>io.Reader</code> 读取数据的时候发生了错误，那么我们会想要封装这个错误以检查底层错误。由于调用者给函数提供 <code>io.Reader</code>，因此，暴露它所产生的错误是有意义的。</p>
<p>相反，一个对数据库进行多次调用的函数可能不应该返回封装了这些调用某个结果的错误。如果函数使用的数据库是实现细节，那么暴露这些错误则违反了抽象。例如，如果你的包 <code>pkg</code> 的 <code>LookupUser</code> 函数使用了 Go 的 <code>database/sql</code> 包，那么它可能会遇到 <code>sql.ErrNoRows</code> 错误。如果你用 <code>fmt.Errorf("accessing DB: %v", err)</code> 来返回错误，那么调用者无法检查底层信息以查找 <code>sql.ErrNoRows</code>。但如果反过来，函数返回 <code>fmt.Errorf("accessing DB: %w", err)</code>，那么调用者可以合理地这样写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := pkg.LookupUser(...)</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, sql.ErrNoRows) …</span><br></pre></td></tr></table></figure>
<p>此时，如果你不想影响到客户端的话，该函数必须始终返回 <code>sql.ErrNoRows</code>，即使切换到其他数据库包也必须返回。换句话说，封装一个错误会使得这个错误成为你的 API 的一部分。如果你不想将来把这个错误作为 API 的一部分来支持，则不应该封装这个错误。</p>
<p>重要的是记住，无论封装与否，错误文本都将相同。无论哪种方式，试图理解错误的 <em>人</em> 都将获得相同的信息；对于封装的选择是关于是否要为 <em>程序</em> 提供额外的信息，以便他们可以做出更明智的决定；还是隐瞒该信息以保留抽象层。</p>
<h4 id="利用-is-和-as-方法自定义错误测试">利用 Is 和 As 方法自定义错误测试</h4>
<p><code>errors.Is</code> 函数检查链中的每个错误，以查找与目标值匹配的错误。默认情况下，如果错误和目标相等，那么二者匹配。此外，链中的错误可能会通过实现 <code>Is</code> <em>方法</em> 来声明它与目标匹配。</p>
<p>例如，考虑这个受 <a href="https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html">Upspin 错误包</a> 启发的错误，它将错误与模板进行比较，并且仅考虑模板中那些非零字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Error <span class="keyword">struct</span> &#123;</span><br><span class="line">    Path <span class="keyword">string</span></span><br><span class="line">    User <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Error)</span> <span class="title">Is</span><span class="params">(target error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    t, ok := target.(*Error)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (e.Path == t.Path || t.Path == <span class="string">&quot;&quot;</span>) &amp;&amp;</span><br><span class="line">           (e.User == t.User || t.User == <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> errors.Is(err, &amp;Error&#123;User: <span class="string">&quot;someuser&quot;</span>&#125;) &#123;</span><br><span class="line">    <span class="comment">// err&#x27;s User field is &quot;someuser&quot;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>errors.As</code> 函数在 <code>As</code> 方法存在的情况下行为类似。</p>
<h4 id="错误和包-api">错误和包 API</h4>
<p>返回错误的包（大部分都会返回）应该描述程序员可能依赖的那些错误的属性。一个经过精心设计的包也要避免返回那些带有不应该依赖的属性的错误。</p>
<p>最简单的规范是说，操作成功或者失败，分别返回 nil 或者非 nil 的错误值。在许多情况下，不需要进一步的信息。</p>
<p>如果我们希望函数返回可识别的错误条件，例如“找不到项目”，那么我们可以返回封装了标记值的错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrNotFound = errors.New(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FetchItem returns the named item.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If no item with the name exists, FetchItem returns an error</span></span><br><span class="line"><span class="comment">// wrapping ErrNotFound.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FetchItem</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Item, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> itemNotFound(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;%q: %w&quot;</span>, name, ErrNotFound)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有其他提供错误的模式：可以由调用方进行语义检查，例如直接返回标记值，特定类型或者可以使用判定函数检查的值。</p>
<p>在所有情况下，都应该注意，不要向用户公开内部细节。正如我们在上面的“是否要封装”中提到的那样，当你从另一个包中返回错误时，你应该将错误转换为不暴露底层错误的形式，除非你愿意将来再返回该特定错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// The *os.PathError returned by os.Open is an internal detail.</span></span><br><span class="line">    <span class="comment">// To avoid exposing it to the caller, repackage it as a new</span></span><br><span class="line">    <span class="comment">// error with the same text. We use the %v formatting verb, since</span></span><br><span class="line">    <span class="comment">// %w would permit the caller to unwrap the original *os.PathError.</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数被定义为返回一个封装某些标记或者类型的错误，请不要直接返回底层错误。 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrPermission = errors.New(<span class="string">&quot;permission denied&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoSomething returns an error wrapping ErrPermission if the user</span></span><br><span class="line"><span class="comment">// does not have permission to do something.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !userHasPermission() &#123;</span><br><span class="line">        <span class="comment">// If we return ErrPermission directly, callers might come</span></span><br><span class="line">        <span class="comment">// to depend on the exact error value, writing code like this:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//     if err := pkg.DoSomething(); err == pkg.ErrPermission &#123; … &#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// This will cause problems if we want to add additional</span></span><br><span class="line">        <span class="comment">// context to the error in the future. To avoid this, we</span></span><br><span class="line">        <span class="comment">// return an error wrapping the sentinel so that users must</span></span><br><span class="line">        <span class="comment">// always unwrap it:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//     if err := pkg.DoSomething(); errors.Is(err, pkg.ErrPermission) &#123; ... &#125;</span></span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w&quot;</span>, ErrPermission)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 总结</p>
<p>尽管我们所讨论的更改仅包含三个函数和一个格式化动词，但我们希望它们能对改善 Go 程序中的错误处理的方式有所帮助。我们希望通过封装来提供额外的上下文这种行为变得常见，从而帮助程序做出更好的决策，并帮助程序员更快地发现错误。</p>
<p>正如 Russ Cox 在他的 <a href="https://blog.golang.org/experiment">GopherCon 2019 主题演讲</a>中所说的那样，在通往 Go 2 的路上，我们实验、简化和发布。现在，我们已经发布了这些更改，期待接下来的实验。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>没事翻着玩</tag>
      </tags>
  </entry>
  <entry>
    <title>uwsgi代码小札|gracefully reload之从停止说起</title>
    <url>/2017/02/27/uwsgi%E4%BB%A3%E7%A0%81%E5%B0%8F%E6%9C%AD-gracefully-reload%E4%B9%8B%E4%BB%8E%E5%81%9C%E6%AD%A2%E8%AF%B4%E8%B5%B7/</url>
    <content><![CDATA[<blockquote>
<p>说明：以master为例</p>
</blockquote>
<p>根据uwsgi文档，当uwsgi接收到SIGHUP信号的时候，会优雅地重载所有的worker和master进程。（参考:<a href="http://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/Management.html#id2">uwsgi中文</a>）</p>
<p>而在<code>master_loop()</code>方法（位于<code>core/master.c</code>）中，注册了接收到SIGHUP信号的处理方法为<code>grace_them_all</code>：<code>uwsgi_unix_signal(SIGHUP, grace_them_all);</code></p>
<h3 id="起始void-grace_them_allint-signum">起始：<code>void grace_them_all(int signum)</code></h3>
<blockquote>
<p>位于uwsgi/core/uwsgi.c中</p>
</blockquote>
<p>在这个方法中，uwsgi会针对不同的模式，修改状态，关闭清理不同的进程。具体执行如下： 1. 检查uwsgi实例是否已经在重载，或者正在关闭。是则直接返回，以避免再次重载。 2. lazy模式下，对所有正在运行中的worker，调用<code>uwsgi_curse(i, SIGHUP)</code>，然后直接返回 3. 设置uwsgi的状态为正在优雅重载（<code>uwsgi.status.gracefully_reloading = 1;</code>） 4. 调用<code>uwsgi_destroy_processes()</code> 1. 给spooler发送<code>SIGKILL</code>信号杀死spooler 2. 停止uwsgi的守护进程（daemon）们 3. 杀死gateway（来自uwsgi.h中的注释：gateway是由master管理的进程，用以扩展服务器的核心特性，它可以prefork或者spawn线程） 4. 杀死emperor 5. 如果定义了<code>UWSGI_SSL</code>，还要调用<code>uwsgi_legion_announce_death()</code>宣告legion的death状态 6. 如果设置了即使在重载时也要强制取消订阅请求（<code>unsubscribe_on_graceful_reload</code>），那么则取消订阅（调用<code>uwsgi_unsubscribe_all()</code>） 7. 对于每个worker，如果不是master的话，则调用<code>uwsgi_curse(i, SIGHUP);</code>来杀死worker 8. 对于每个mule，如果不是父mule的话，则调用<code>uwsgi_curse_mule(i, SIGHUP);</code>来杀死Mule</p>
<p>整个过程图如下： <img src="/img/grace_them_all.jpeg" alt="grace_them_all(int signum)" /></p>
<h4 id="给指定worker-id的worker发送死亡信号siguwsgi_curse">给指定worker id的worker发送死亡信号sig：<code>uwsgi_curse</code></h4>
<blockquote>
<p>位于uwsgi/core/master_utils.c中</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void uwsgi<span class="constructor">_curse(<span class="params">int</span> <span class="params">wid</span>, <span class="params">int</span> <span class="params">sig</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置worker的最后死亡期限</span></span><br><span class="line">	uwsgi.workers<span class="literal">[<span class="identifier">wid</span>]</span>.cursed_at = uwsgi<span class="constructor">_now()</span>;</span><br><span class="line">        uwsgi.workers<span class="literal">[<span class="identifier">wid</span>]</span>.no_mercy_at = uwsgi.workers<span class="literal">[<span class="identifier">wid</span>]</span>.cursed_at + uwsgi.worker_reload_mercy;</span><br><span class="line">    <span class="comment">// 给worker发送信号sig</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">sig</span>) &#123;</span><br><span class="line">		(void) kill(uwsgi.workers<span class="literal">[<span class="identifier">wid</span>]</span>.pid, <span class="keyword">sig</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="管理worker的优雅重载void-gracefully_killint-signum">管理worker的优雅重载：<code>void gracefully_kill(int signum)</code></h3>
<blockquote>
<p>位于uwsgi/core/uwsgi.c中</p>
</blockquote>
<p>master通过<code>kill()</code>函数来向worker发送SIGHUP信号。 而在<code>uwsgi_worker_run()</code>方法中注册了信号<code>SIGHUP</code>的处理方法为<code>gracefully_kill</code>：<code>uwsgi_unix_signal(SIGHUP, gracefully_kill);</code>。我们来看看这个方法又进行了什么操作： 1. 将worker管理的下一个请求(<code>manage_next_request</code>)置为0（表示的意思要再研究下） 2. 对于多线程，等待线程终止（<code>wait_for_threads()</code>），等待请求处理完成之后，在需要的时候（worker.close_sockets不为0）关闭所有的socket，最后调用<code>exit(UWSGI_RELOAD_CODE)</code>退出。结束该方法。 3. 对于异步模式，目前没有什么好的方式进行优雅重载，因此处理方式则是，在需要的时候（worker.close_sockets不为0）关闭所有的socket，然后调用<code>exit(UWSGI_RELOAD_CODE)</code>退出。结束该方法。 4. 对于无待处理请求的worker，在需要的时候（worker.close_sockets不为0）关闭所有的socket，然后调用<code>exit(UWSGI_RELOAD_CODE)</code>退出</p>
<blockquote>
<p>这里的<code>exit()</code>函数并非系统的<code>exit</code>，而是一个宏定义：<code>#define exit(x) uwsgi_exit(x)</code></p>
</blockquote>
<p>图解如下： <img src="/img/gracefully_kill.jpeg" alt="gracefully_kill(int signum)" /></p>
<h4 id="退出void-uwsgi_exitint-status">退出：<code>void uwsgi_exit(int status)</code></h4>
<ol type="1">
<li>将uwsgi的<code>last_exit_code</code>属性值为status值</li>
<li>调用系统函数<code>exit</code>退出当前进程</li>
</ol>
<p>通过上面一系列操作，uwsgi就完成了重载中的<code>stop</code>一步。接下来就是<code>start</code>了。这个阶段，我们稍后再说~~</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/articles/TheArtOfGracefulReloading.html">优雅重载的艺术</a></li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>读代码</tag>
        <tag>uWSGI</tag>
      </tags>
  </entry>
  <entry>
    <title>uwsgi代码小札|信号与signal.c</title>
    <url>/2016/10/23/uwsgi%E4%BB%A3%E7%A0%81%E5%B0%8F%E6%9C%AD-%E4%BF%A1%E5%8F%B7%E4%B8%8Esignal-c/</url>
    <content><![CDATA[<blockquote>
<p>说明：当前使用的版本为uwsgi 2.0</p>
</blockquote>
<p>目前在网络上能够找到的uwsgi源码相关的文档少之又少（当然，也不排除是官方文档大家觉得已经足够，或者是如我一般愚笨的人少之又少╮(╯_╰)╭）。在这个背景下，作为uwsgi小白的我，由于种种原因，决定自食其力。因此，准备开一个uwsgi源码阅读系列，结合官网，整理自己阅读uwsgi源码过程中的所思所想所得，作为不备之需。本系列没有deadline，不定时更新。</p>
<blockquote><p><strong>免责声明</strong>：由于本文作者（也就是我）目前尚未全面掌握uwsgi，C代码勉强能读懂，因此假若本文有错误的地方，请不要犹豫，不要客气，尽情在评论中提出！</p>
</blockquote>
<p>好了，废话说完了，进入正题︿(￣︶￣)︿</p>
<h1 id="uwsgi中的信号及其处理">uWSGI中的信号及其处理</h1>
<p>uWSGI信号量与UNIX/Posix信号量毫无共同之处。你可以定义一个信号，绑定该信号接收到时应该触发的操作（信号处理函数）。通过uwsgi中的信号，你可以监控到文件/目录的修改，可以定时进行一些处理工作等等等等。</p>
<h2 id="相关结构说明">相关结构说明</h2>
<h3 id="uwsgi_signal_entry"><code>uwsgi_signal_entry</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uwsgi_signal_entry</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> wid; <span class="comment">// worker id</span></span><br><span class="line">	<span class="keyword">uint8_t</span> modifier1;</span><br><span class="line">	<span class="keyword">char</span> receiver[<span class="number">64</span>]; <span class="comment">// 信号目标，也就是signal targer</span></span><br><span class="line">	<span class="keyword">void</span> *handler; <span class="comment">// 信号处理程序</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>信号表保存在<code>uwsgi_shared</code>结构中，定义为<code>struct uwsgi_signal_entry *signal_table;</code> 信号表由所有worker共享 (并通过共享锁对抗竞争条件)。当一个workder接收到一个信号，它会搜索信号表，查找对应的处理程序并执行。</p>
</blockquote>
<h3 id="定时器">定时器</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通定时器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uwsgi_timer</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value; <span class="comment">// 定时时间</span></span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">int</span> registered;</span><br><span class="line">	<span class="keyword">uint8_t</span> sig; <span class="comment">// 绑定的信号量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 红黑定时器（rbtimer）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uwsgi_signal_rb_timer</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value; <span class="comment">// 定时时间</span></span><br><span class="line">	<span class="keyword">int</span> registered;</span><br><span class="line">	<span class="keyword">int</span> iterations;</span><br><span class="line">	<span class="keyword">int</span> iterations_done;</span><br><span class="line">	<span class="keyword">uint8_t</span> sig; <span class="comment">// 绑定的信号量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uwsgi_rb_timer</span> *<span class="title">uwsgi_rb_timer</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="监控器">监控器</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件监控器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uwsgi_fmon</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> filename[<span class="number">0xff</span>]; <span class="comment">// 监控的文件名</span></span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">int</span> registered;</span><br><span class="line">	<span class="keyword">uint8_t</span> sig; <span class="comment">// 绑定的信号值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="uwsgi中的信号api">uWSGI中的信号API</h2>
<blockquote>
<p>信号API位于core/signal.c文件中。</p>
</blockquote>
<h3 id="处理uwsgi信号-uwsgi_signal_handler">处理uwsgi信号: <code>uwsgi_signal_handler</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uwsgi_signal_handler</span><span class="params">(struct wsgi_request *wsgi_req, <span class="keyword">uint8_t</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 搜索信号表(signal_table)，找到对应的信号项use</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uwsgi_signal_entry</span> *<span class="title">use</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pos = (uwsgi.mywid * <span class="number">256</span>) + sig;</span><br><span class="line"></span><br><span class="line">	use = &amp;uwsgi.shared-&gt;signal_table[pos];</span><br><span class="line">    <span class="comment">// 执行处理函数前的一系列校验</span></span><br><span class="line">	<span class="keyword">if</span> (!use-&gt;handler)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!uwsgi.p[use-&gt;modifier1]-&gt;signal_handler) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// master模式下，如果注册该信号的worker id和当前的worker id不一致，并且注册该信号的worker id又不为0（表示master进程吗？）的话，返回错误。</span></span><br><span class="line">	<span class="keyword">if</span> (uwsgi.master_process) &#123;</span><br><span class="line">		<span class="keyword">if</span> (use-&gt;wid != <span class="number">0</span> &amp;&amp; use-&gt;wid != uwsgi.mywid) &#123;</span><br><span class="line">			uwsgi_log(<span class="string">&quot;[uwsgi-signal] you have registered this signal in worker %d memory area, only that process will be able to run it\n&quot;</span>, use-&gt;wid);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// lazy模式下（没有master），只有相同的worker(注册该信号的worker id和当前的worker id一致)才能运行处理函数</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (uwsgi.lazy) &#123;</span><br><span class="line">		<span class="keyword">if</span> (use-&gt;wid != uwsgi.mywid) &#123;</span><br><span class="line">			uwsgi_log(<span class="string">&quot;[uwsgi-signal] you have registered this signal in worker %d memory area, only that process will be able to run it\n&quot;</span>, use-&gt;wid);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 当master不活跃时，那么worker1就是主导COW的进程</span></span><br><span class="line">		<span class="keyword">if</span> (use-&gt;wid != <span class="number">1</span> &amp;&amp; use-&gt;wid != uwsgi.mywid) &#123;</span><br><span class="line">			uwsgi_log(<span class="string">&quot;[uwsgi-signal] you have registered this signal in worker %d memory area, only that process will be able to run it\n&quot;</span>, use-&gt;wid);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里，设置harakiri (如果需要)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uwsgi.mywid &gt; <span class="number">0</span> &amp;&amp; wsgi_req) &#123;<span class="comment">// 当前是worker的情况下</span></span><br><span class="line">		uwsgi.workers[uwsgi.mywid].sig = <span class="number">1</span>;</span><br><span class="line">		uwsgi.workers[uwsgi.mywid].signum = sig;</span><br><span class="line">		uwsgi.workers[uwsgi.mywid].signals++;</span><br><span class="line">		<span class="keyword">if</span> (uwsgi.harakiri_options.workers &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (uwsgi.muleid &gt; <span class="number">0</span>) &#123; <span class="comment">// 当前是mule的情况下</span></span><br><span class="line">		uwsgi.mules[uwsgi.muleid - <span class="number">1</span>].sig = <span class="number">1</span>;</span><br><span class="line">		uwsgi.mules[uwsgi.muleid - <span class="number">1</span>].signum = sig;</span><br><span class="line">		uwsgi.mules[uwsgi.muleid - <span class="number">1</span>].signals++;</span><br><span class="line">		<span class="keyword">if</span> (uwsgi.harakiri_options.mules &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			set_mule_harakiri(uwsgi.harakiri_options.mules);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (uwsgi.i_am_a_spooler &amp;&amp; (getpid() == uwsgi.i_am_a_spooler-&gt;pid)) &#123; <span class="comment">// 当前是spooler的情况下</span></span><br><span class="line">		<span class="keyword">if</span> (uwsgi.harakiri_options.spoolers &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			set_spooler_harakiri(uwsgi.harakiri_options.spoolers);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 执行信号处理函数，返回值保存在ret中。</span></span><br><span class="line">	<span class="keyword">int</span> ret = uwsgi.p[use-&gt;modifier1]-&gt;signal_handler(sig, use-&gt;handler);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uwsgi.mywid &gt; <span class="number">0</span> &amp;&amp; wsgi_req) &#123;<span class="comment">// 当前是worker的情况下</span></span><br><span class="line">		uwsgi.workers[uwsgi.mywid].sig = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (uwsgi.workers[uwsgi.mywid].cores[wsgi_req-&gt;async_id].harakiri &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			set_harakiri(wsgi_req, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (uwsgi.muleid &gt; <span class="number">0</span>) &#123; <span class="comment">// 当前是mule的情况下</span></span><br><span class="line">		uwsgi.mules[uwsgi.muleid - <span class="number">1</span>].sig = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (uwsgi.mules[uwsgi.muleid - <span class="number">1</span>].harakiri &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			set_mule_harakiri(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (uwsgi.i_am_a_spooler &amp;&amp; (getpid() == uwsgi.i_am_a_spooler-&gt;pid)) &#123; <span class="comment">// 当前是spooler的情况下</span></span><br><span class="line">		<span class="keyword">if</span> (uwsgi.harakiri_options.spoolers &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			set_spooler_harakiri(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="uwsgi_signal_registered"><code>uwsgi_signal_registered</code></h3>
<p>检查信号在当前worker内是否注册了处理函数。如果注册了，返回1，否则返回0 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uwsgi_signal_registered</span><span class="params">(<span class="keyword">uint8_t</span> sig)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pos = (uwsgi.mywid * <span class="number">256</span>) + sig;</span><br><span class="line">	<span class="keyword">if</span> (uwsgi.shared-&gt;signal_table[pos].handler != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### <code>uwsgi_register_signal</code> 注册信号以及相应的处理函数等。返回0表示注册成功，非0表示有异常 <img src="/img/635063610422159008.jpg" /></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uwsgi_register_signal</span><span class="params">(<span class="keyword">uint8_t</span> sig, <span class="keyword">char</span> *receiver, <span class="keyword">void</span> *handler, <span class="keyword">uint8_t</span> modifier1)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一个信号项</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uwsgi_signal_entry</span> *<span class="title">use</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 相关校验：必须有个master，并且只有master/worker可以注册信号处理函数，另外，receiver长度必须不大于63</span></span><br><span class="line">	<span class="keyword">if</span> (!uwsgi.master_process) &#123;</span><br><span class="line">		uwsgi_log(<span class="string">&quot;you cannot register signals without a master\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uwsgi.mywid == <span class="number">0</span> &amp;&amp; uwsgi.workers[<span class="number">0</span>].pid != uwsgi.mypid) &#123;</span><br><span class="line">                uwsgi_log(<span class="string">&quot;only the master and the workers can register signal handlers\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(receiver) &gt; <span class="number">63</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 通过共享锁对抗竞争条件</span></span><br><span class="line">	uwsgi_lock(uwsgi.signal_table_lock);</span><br><span class="line">    <span class="comment">// 找到信号表中注册该信号的位置</span></span><br><span class="line">	<span class="keyword">int</span> pos = (uwsgi.mywid * <span class="number">256</span>) + sig;</span><br><span class="line">	use = &amp;uwsgi.shared-&gt;signal_table[pos];</span><br><span class="line">    <span class="comment">// 判断master是否已经注册了这个信号，如果已注册，则返回错误</span></span><br><span class="line">	<span class="keyword">if</span> (use-&gt;handler &amp;&amp; uwsgi.mywid == <span class="number">0</span>) &#123;</span><br><span class="line">		uwsgi_log(<span class="string">&quot;[uwsgi-signal] you cannot re-register a signal as the master !!!\n&quot;</span>);</span><br><span class="line">		uwsgi_unlock(uwsgi.signal_table_lock);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 信号项的成员赋值</span></span><br><span class="line">	<span class="built_in">strncpy</span>(use-&gt;receiver, receiver, <span class="built_in">strlen</span>(receiver) + <span class="number">1</span>);</span><br><span class="line">	use-&gt;handler = handler;</span><br><span class="line">	use-&gt;modifier1 = modifier1;</span><br><span class="line">	use-&gt;wid = uwsgi.mywid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (use-&gt;receiver[<span class="number">0</span>] == <span class="number">0</span>) &#123;<span class="comment">// 未指定signal接受者，使用默认接收者</span></span><br><span class="line">		uwsgi_log(<span class="string">&quot;[uwsgi-signal] signum %d registered (wid: %d modifier1: %d target: default, any worker)\n&quot;</span>, sig, uwsgi.mywid, modifier1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">// 指定了signal接受者</span></span><br><span class="line">		uwsgi_log(<span class="string">&quot;[uwsgi-signal] signum %d registered (wid: %d modifier1: %d target: %s)\n&quot;</span>, sig, uwsgi.mywid, modifier1, receiver);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于cow(即写即拷)的特殊处理：如果是注册在master上，则将它给每个worker拷贝一份</span></span><br><span class="line">	<span class="keyword">if</span> (uwsgi.mywid == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">                <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=uwsgi.numproc;i++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> pos = (i * <span class="number">256</span>);</span><br><span class="line">                        <span class="built_in">memcpy</span>(&amp;uwsgi.shared-&gt;signal_table[pos], &amp;uwsgi.shared-&gt;signal_table[<span class="number">0</span>], <span class="keyword">sizeof</span>(struct uwsgi_signal_entry) * <span class="number">256</span>);</span><br><span class="line">                &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uwsgi_unlock(uwsgi.signal_table_lock); <span class="comment">// 释放锁</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加文件监控器-uwsgi_add_file_monitor">添加文件监控器: <code>uwsgi_add_file_monitor</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sig: 信号值</span></span><br><span class="line"><span class="comment">// filename：文件名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uwsgi_add_file_monitor</span><span class="params">(<span class="keyword">uint8_t</span> sig, <span class="keyword">char</span> *filename)</span></span></span><br></pre></td></tr></table></figure>
<ol type="1">
<li>检查参数filename的长度，不能超过254</li>
<li>通过文件监控表锁<code>uwsgi.fmon_table_lock</code>来处理竞争</li>
<li>如果当前已注册的文件监控器大小<code>ushared-&gt;files_monitored_cnt</code>已经是64（可添加的最大数），则退出</li>
<li>将信号sig和文件名filename信息附加到已监控文件数组<code>ushared-&gt;files_monitored</code>的尾部，修改注册状态。</li>
</ol>
<h3 id="添加定时器-uwsgi_add_timer">添加定时器: <code>uwsgi_add_timer</code></h3>
<p>返回0表示表示添加成功，非0表示失败。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uwsgi_add_timer</span><span class="params">(<span class="keyword">uint8_t</span> sig, <span class="keyword">int</span> secs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不在master模式下，则返回错误。</span></span><br><span class="line">	<span class="keyword">if</span> (!uwsgi.master_process) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	uwsgi_lock(uwsgi.timer_table_lock);</span><br><span class="line">    <span class="comment">// 判断是否已经添加了64个定时器，有则退出，否则将sig和secs注册到定时器表（master会用它来添加项到时间队列中）中</span></span><br><span class="line">	<span class="keyword">if</span> (ushared-&gt;timers_cnt &lt; <span class="number">64</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// fill the timer table, the master will use it to add items to the event queue</span></span><br><span class="line">		ushared-&gt;timers[ushared-&gt;timers_cnt].value = secs;</span><br><span class="line">		ushared-&gt;timers[ushared-&gt;timers_cnt].registered = <span class="number">0</span>;</span><br><span class="line">		ushared-&gt;timers[ushared-&gt;timers_cnt].sig = sig;</span><br><span class="line">		ushared-&gt;timers_cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		uwsgi_log(<span class="string">&quot;you can register max 64 timers !!!\n&quot;</span>);</span><br><span class="line">		uwsgi_unlock(uwsgi.timer_table_lock);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uwsgi_unlock(uwsgi.timer_table_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 添加rb定时器: <code>uwsgi_signal_add_rb_timer</code> 返回0表示表示添加成功，非0表示失败。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uwsgi_signal_add_rb_timer</span><span class="params">(<span class="keyword">uint8_t</span> sig, <span class="keyword">int</span> secs, <span class="keyword">int</span> iterations)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不在master模式下，则返回错误。</span></span><br><span class="line">	<span class="keyword">if</span> (!uwsgi.master_process)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	uwsgi_lock(uwsgi.rb_timer_table_lock);</span><br><span class="line">    <span class="comment">// 判断是否已经添加了64个定时器，有则退出，否则将sig和secs注册到定时器表（master会用它来添加项到时间队列中）中</span></span><br><span class="line">	<span class="keyword">if</span> (ushared-&gt;rb_timers_cnt &lt; <span class="number">64</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// fill the timer table, the master will use it to add items to the event queue</span></span><br><span class="line">		ushared-&gt;rb_timers[ushared-&gt;rb_timers_cnt].value = secs;</span><br><span class="line">		ushared-&gt;rb_timers[ushared-&gt;rb_timers_cnt].registered = <span class="number">0</span>;</span><br><span class="line">		ushared-&gt;rb_timers[ushared-&gt;rb_timers_cnt].iterations = iterations;</span><br><span class="line">		ushared-&gt;rb_timers[ushared-&gt;rb_timers_cnt].iterations_done = <span class="number">0</span>;</span><br><span class="line">		ushared-&gt;rb_timers[ushared-&gt;rb_timers_cnt].sig = sig;</span><br><span class="line">		ushared-&gt;rb_timers_cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		uwsgi_log(<span class="string">&quot;you can register max 64 rb_timers !!!\n&quot;</span>);</span><br><span class="line">		uwsgi_unlock(uwsgi.rb_timer_table_lock);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uwsgi_unlock(uwsgi.rb_timer_table_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 路由信号量: <code>uwsgi_route_signal</code> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uwsgi_route_signal</span><span class="params">(<span class="keyword">uint8_t</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到信号sig在信号表中对应的信号项</span></span><br><span class="line">	<span class="keyword">int</span> pos = (uwsgi.mywid * <span class="number">256</span>) + sig;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uwsgi_signal_entry</span> *<span class="title">use</span> =</span> &amp;ushared-&gt;signal_table[pos];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果信号接收者是worker/worker0（默认），则发送给第一个可用worker</span></span><br><span class="line">	<span class="keyword">if</span> (use-&gt;receiver[<span class="number">0</span>] == <span class="number">0</span> || !<span class="built_in">strcmp</span>(use-&gt;receiver, <span class="string">&quot;worker&quot;</span>) || !<span class="built_in">strcmp</span>(use-&gt;receiver, <span class="string">&quot;worker0&quot;</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (uwsgi_signal_send(ushared-&gt;worker_signal_pipe[<span class="number">0</span>], sig)) &#123;</span><br><span class="line">			uwsgi_log(<span class="string">&quot;could not deliver signal %d to workers pool\n&quot;</span>, sig);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果信号接收者是workers，则发送给所有worker</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(use-&gt;receiver, <span class="string">&quot;workers&quot;</span>)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= uwsgi.numproc; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (uwsgi_signal_send(uwsgi.workers[i].signal_pipe[<span class="number">0</span>], sig)) &#123;</span><br><span class="line">				uwsgi_log(<span class="string">&quot;could not deliver signal %d to worker %d\n&quot;</span>, sig, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果信号接收者是active-workers，则发送给所有活跃worker(active worker，判定标准是worker不是cheaped/suspended)</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(use-&gt;receiver, <span class="string">&quot;active-workers&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= uwsgi.numproc; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (uwsgi.workers[i].pid &gt; <span class="number">0</span> &amp;&amp; !uwsgi.workers[i].cheaped &amp;&amp; !uwsgi.workers[i].suspended) &#123;</span><br><span class="line">                        	<span class="keyword">if</span> (uwsgi_signal_send(uwsgi.workers[i].signal_pipe[<span class="number">0</span>], sig)) &#123;</span><br><span class="line">                                	uwsgi_log(<span class="string">&quot;could not deliver signal %d to worker %d\n&quot;</span>, sig, i);</span><br><span class="line">                        	&#125;</span><br><span class="line">			&#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">// 如果信号接收者是指定的worker，则发送给指定的worker（对于workerN，N不能大于最大的worker数）</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(use-&gt;receiver, <span class="string">&quot;worker&quot;</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">		i = atoi(use-&gt;receiver + <span class="number">6</span>);</span><br><span class="line">		<span class="keyword">if</span> (i &gt; uwsgi.numproc) &#123;</span><br><span class="line">			uwsgi_log(<span class="string">&quot;invalid signal target: %s\n&quot;</span>, use-&gt;receiver);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (uwsgi_signal_send(uwsgi.workers[i].signal_pipe[<span class="number">0</span>], sig)) &#123;</span><br><span class="line">			uwsgi_log(<span class="string">&quot;could not deliver signal %d to worker %d\n&quot;</span>, sig, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果信号接收者是subscribed，则发送给订阅了这个信号的进程（当前版本未实现）</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(use-&gt;receiver, <span class="string">&quot;subscribed&quot;</span>)) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果信号接收者是spooler，则发送给spooler</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(use-&gt;receiver, <span class="string">&quot;spooler&quot;</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ushared-&gt;worker_signal_pipe[<span class="number">0</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (uwsgi_signal_send(ushared-&gt;spooler_signal_pipe[<span class="number">0</span>], sig)) &#123;</span><br><span class="line">				uwsgi_log(<span class="string">&quot;could not deliver signal %d to the spooler\n&quot;</span>, sig);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果信号接收者是mules，则发送给所有的mule</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(use-&gt;receiver, <span class="string">&quot;mules&quot;</span>)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; uwsgi.mules_cnt; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (uwsgi_signal_send(uwsgi.mules[i].signal_pipe[<span class="number">0</span>], sig)) &#123;</span><br><span class="line">				uwsgi_log(<span class="string">&quot;could not deliver signal %d to mule %d\n&quot;</span>, sig, i + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果信号接收者是指定的mule，则发送给指定的mule（对于muleN，N不能大于最大的mule数）</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(use-&gt;receiver, <span class="string">&quot;mule&quot;</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">		i = atoi(use-&gt;receiver + <span class="number">4</span>);</span><br><span class="line">		<span class="keyword">if</span> (i &gt; uwsgi.mules_cnt) &#123;</span><br><span class="line">			uwsgi_log(<span class="string">&quot;invalid signal target: %s\n&quot;</span>, use-&gt;receiver);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (uwsgi_signal_send(ushared-&gt;mule_signal_pipe[<span class="number">0</span>], sig)) &#123;</span><br><span class="line">				uwsgi_log(<span class="string">&quot;could not deliver signal %d to a mule\n&quot;</span>, sig);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (uwsgi_signal_send(uwsgi.mules[i - <span class="number">1</span>].signal_pipe[<span class="number">0</span>], sig)) &#123;</span><br><span class="line">				uwsgi_log(<span class="string">&quot;could not deliver signal %d to mule %d\n&quot;</span>, sig, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果信号接收者是farm_name，那么会根据name获取uwsg_farm实例，然后将信号发送给name指定的farm</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(use-&gt;receiver, <span class="string">&quot;farm_&quot;</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">		<span class="keyword">char</span> *name = use-&gt;receiver + <span class="number">5</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">uwsgi_farm</span> *<span class="title">uf</span> =</span> get_farm_by_name(name);</span><br><span class="line">		<span class="keyword">if</span> (!uf) &#123;</span><br><span class="line">			uwsgi_log(<span class="string">&quot;unknown farm: %s\n&quot;</span>, name);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (uwsgi_signal_send(uf-&gt;signal_pipe[<span class="number">0</span>], sig)) &#123;</span><br><span class="line">			uwsgi_log(<span class="string">&quot;could not deliver signal %d to farm %d (%s)\n&quot;</span>, sig, uf-&gt;id, uf-&gt;name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果信号接收者是指定的farm，则发送给指定的farm（对于farmN，N不能大于最大的farm数）</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(use-&gt;receiver, <span class="string">&quot;farm&quot;</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">		i = atoi(use-&gt;receiver + <span class="number">4</span>);</span><br><span class="line">		<span class="keyword">if</span> (i &gt; uwsgi.farms_cnt || i &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			uwsgi_log(<span class="string">&quot;invalid signal target: %s\n&quot;</span>, use-&gt;receiver);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (uwsgi_signal_send(uwsgi.farms[i - <span class="number">1</span>].signal_pipe[<span class="number">0</span>], sig)) &#123;</span><br><span class="line">				uwsgi_log(<span class="string">&quot;could not deliver signal %d to farm %d (%s)\n&quot;</span>, sig, i, uwsgi.farms[i - <span class="number">1</span>].name);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果信号接收者不是上面任意一个，则输出日志后退出</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// unregistered signal, sending it to all the workers</span></span><br><span class="line">		uwsgi_log(<span class="string">&quot;^^^ UNSUPPORTED SIGNAL TARGET: %s ^^^\n&quot;</span>, use-&gt;receiver);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 其他一些函数 * 创建信号管道: <code>create_signal_pipe</code> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_signal_pipe</span><span class="params">(<span class="keyword">int</span> *sigpipe)</span></span></span><br></pre></td></tr></table></figure> * 发送远程信号: <code>uwsgi_remote_signal_send</code> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uwsgi_remote_signal_send</span><span class="params">(<span class="keyword">char</span> *addr, <span class="keyword">uint8_t</span> sig)</span></span></span><br></pre></td></tr></table></figure> * 发送信号: <code>uwsgi_signal_send</code> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uwsgi_signal_send</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint8_t</span> sig)</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>等待信号: <code>uwsgi_signal_wait</code> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uwsgi_signal_wait</span><span class="params">(struct wsgi_request *wsgi_req, <span class="keyword">int</span> signum)</span></span></span><br></pre></td></tr></table></figure></li>
<li>接收信号: <code>uwsgi_receive_signal</code> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uwsgi_receive_signal</span><span class="params">(struct wsgi_request *wsgi_req, <span class="keyword">int</span> fd, <span class="keyword">char</span> *name, <span class="keyword">int</span> id)</span> </span></span><br></pre></td></tr></table></figure> # 参考</li>
<li>uWSGI信号框架：<a href="http://uwsgi-docs.readthedocs.io/en/latest/Signals.html">官方</a> | <a href="http://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/Signals.html">自译中文版</a></li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>读代码</tag>
        <tag>uWSGI</tag>
      </tags>
  </entry>
  <entry>
    <title>译|interface 和反射的关系</title>
    <url>/2018/12/22/%E3%80%90%E8%AF%91%E3%80%91interface-%E5%92%8C%E5%8F%8D%E5%B0%84%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>原文：<a href="https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/">The Relationship Between Interfaces and Reflection</a></p>
<hr />
<p>interface 是 Go 中抽象的基本工具之一。在给 interface 赋值时，interface 会存储类型信息。反射（reflection）是一种在运行时检查类型和值信息的方法。</p>
<p>Go 通过 <code>reflect</code> 包实现了反射，该包提供了检查 interface 结构元素甚至是运行时修改值的类型和方法。</p>
<p>在这篇文章中，我希望说明 interface 结构的各个部分与 reflect API 的关系，并最终让 reflect 包的使用更方便！</p>
<h1 id="为-interface-赋值">为 interface 赋值</h1>
<p>interface 编码了三个东西：值、方法集和所存储值的类型。</p>
<p>interface 的结构如下所示：</p>
<figure>
<img src="https://blog.gopheracademy.com/postimages/advent-2018/interfaces-and-reflect/interface.svg" alt="interface-diagram" /><figcaption aria-hidden="true">interface-diagram</figcaption>
</figure>
<p>在该图中，我们可以清楚地看到 interface 的三个部分：<code>_type</code> 是类型信息，<code>*data</code> 是一个指向实际值的指针，而 <code>itab</code> 对方法集进行了编码。</p>
<p>当一个函数有一个 interface 参数时，将值传递给该函数会将值、方法集和类型打包到 interface 中。</p>
<h1 id="利用-reflect-包在运行时检查-interface-数据">利用 reflect 包，在运行时检查 interface 数据</h1>
<p>一旦一个值被存储在 interface 中，就可以使用 <code>reflect</code> 包来检查其各个部分。我们无法直接检查 interface 结构；而 reflect 包维护了让我们有权访问的 interface 结构的副本。</p>
<p>虽然我们可以通过 reflect 对象访问 interface，但是它与底层的 interface 有直接关联。</p>
<p><code>reflect.Type</code> 和 <code>reflect.Value</code> 类型提供了访问 interface 组成部分的方法。</p>
<p><code>reflect.Type</code> 侧重于公开与类型相关的数据，因此它仅限于 interface 结构的 <code>_type</code> 部分；而 <code>reflect.Value</code> 必须将类型信息与值相结合，以允许程序员检查和操作值，因此该类型必须查看 <code>_type</code> 以及 <code>data</code>。</p>
<h2 id="reflect.type---检查类型">reflect.Type - 检查类型</h2>
<p><code>reflect.TypeOf()</code> 函数用于提取一个值的类型信息。由于它唯一的参数是一个空的 interface，因此传递给该函数的值将被赋给一个 interface，故而可以拿到类型、方法集和值。</p>
<p><code>reflect.TypeOf()</code> 返回一个 <code>reflect.Type</code>，它提供了让你检查值类型的方法。</p>
<p>下面是一些可用的 <code>Type</code> 方法，以及和它们的返回相对应的 interface 结构信息。</p>
<figure>
<img src="https://blog.gopheracademy.com/postimages/advent-2018/interfaces-and-reflect/reflect-type.svg" alt="reflect-type-diagram" /><figcaption aria-hidden="true">reflect-type-diagram</figcaption>
</figure>
<h3 id="reflect.type-使用示例"><code>reflect.Type</code> 使用示例</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gift <span class="keyword">struct</span> &#123;</span><br><span class="line">	Sender    <span class="keyword">string</span></span><br><span class="line">	Recipient <span class="keyword">string</span></span><br><span class="line">	Number    <span class="keyword">uint</span></span><br><span class="line">	Contents  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g := Gift&#123;</span><br><span class="line">		Sender:    <span class="string">&quot;Hank&quot;</span>,</span><br><span class="line">		Recipient: <span class="string">&quot;Sue&quot;</span>,</span><br><span class="line">		Number:    <span class="number">1</span>,</span><br><span class="line">		Contents:  <span class="string">&quot;Scarf&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t := reflect.TypeOf(g)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> kind := t.Kind(); kind != reflect.Struct &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;This program expects to work on a struct; we got a %v instead.&quot;</span>, kind)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		f := t.Field(i)</span><br><span class="line">		log.Printf(<span class="string">&quot;Field %03d: %-10.10s %v&quot;</span>, i, f.Name, f.Type.Kind())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序的目的是打印 <code>Gift</code> 结构中的字段。当把 <code>g</code> 值传递给 <code>reflect.TypeOf()</code> 时，<code>g</code> 被赋给一个 interface，此时编译器会使用类型和方法集信息来填充它。这使得我们可以遍历该 interface 结构的类型部分的 <code>[]fields</code> 字段，得到以下输出：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2018</span>/<span class="number">12</span>/<span class="number">16</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span> Field <span class="number">000</span>: Sender     string</span><br><span class="line"><span class="attribute">2018</span>/<span class="number">12</span>/<span class="number">16</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span> Field <span class="number">001</span>: Recipient  string</span><br><span class="line"><span class="attribute">2018</span>/<span class="number">12</span>/<span class="number">16</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span> Field <span class="number">002</span>: Number     uint</span><br><span class="line"><span class="attribute">2018</span>/<span class="number">12</span>/<span class="number">16</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span> Field <span class="number">003</span>: Contents   string</span><br></pre></td></tr></table></figure>
<h2 id="reflect.method---检查-itab-方法集">reflect.Method - 检查 itab / 方法集</h2>
<p><code>reflect.Type</code> 类型还允许你访问 <code>itab</code> 的组成部分，提取 interface 的方法信息。</p>
<figure>
<img src="https://blog.gopheracademy.com/postimages/advent-2018/interfaces-and-reflect/reflect-method.svg" alt="reflect-method-diagram" /><figcaption aria-hidden="true">reflect-method-diagram</figcaption>
</figure>
<h3 id="使用-reflect-检查方法">使用 reflect 检查方法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reindeer <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Reindeer)</span> <span class="title">TakeOff</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;%q lifts off.&quot;</span>, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Reindeer)</span> <span class="title">Land</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;%q gently lands.&quot;</span>, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Reindeer)</span> <span class="title">ToggleNose</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r != <span class="string">&quot;rudolph&quot;</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;invalid reindeer operation&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;%q nose changes state.&quot;</span>, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := Reindeer(<span class="string">&quot;rudolph&quot;</span>)</span><br><span class="line"></span><br><span class="line">	t := reflect.TypeOf(r)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumMethod(); i++ &#123;</span><br><span class="line">		m := t.Method(i)</span><br><span class="line">		log.Printf(<span class="string">&quot;%s&quot;</span>, m.Name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码遍历了存储在 <code>itab</code> 中的所有函数数据，然后展示每个方法的名字： <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2018</span>/<span class="number">12</span>/<span class="number">16</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span> Land</span><br><span class="line"><span class="attribute">2018</span>/<span class="number">12</span>/<span class="number">16</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span> TakeOff</span><br><span class="line"><span class="attribute">2018</span>/<span class="number">12</span>/<span class="number">16</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span> ToggleNose</span><br></pre></td></tr></table></figure> ## reflect.Value - 检查值</p>
<p>目前为止，我们只讨论了类型信息 —— 字段、方法等等。而 <code>reflect.Value</code> 为我们提供了 interface 中所存储的实际值的信息。</p>
<p>与 <code>reflect.Value</code> 相关联的方法必须结合类型信息和实际值。例如，为了从结构中提取字段，reflect 包必须结合结构布局信息（特别是存储在 <code>_type</code> 中的字段和字段偏移量），以及 interface 的 <code>*data</code> 部分指向的实际值，以实现正确的结构解码。</p>
<figure>
<img src="https://blog.gopheracademy.com/postimages/advent-2018/interfaces-and-reflect/reflect-value.svg" alt="reflect-value-diagram" /><figcaption aria-hidden="true">reflect-value-diagram</figcaption>
</figure>
<h3 id="示例查看修改值">示例：查看修改值</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="keyword">string</span></span><br><span class="line">	Grade <span class="keyword">int</span></span><br><span class="line">	Nice  <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adult <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name       <span class="keyword">string</span></span><br><span class="line">	Occupation <span class="keyword">string</span></span><br><span class="line">	Nice       <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// search a slice of structs for Name field that is &quot;Hank&quot; and set its Nice</span></span><br><span class="line"><span class="comment">// field to true.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nice</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// retrieve the underlying value of i.  we know that i is an</span></span><br><span class="line">	<span class="comment">// interface.</span></span><br><span class="line">	v := reflect.ValueOf(i)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we&#x27;re only interested in slices to let&#x27;s check what kind of value v is. if</span></span><br><span class="line">	<span class="comment">// it isn&#x27;t a slice, return immediately.</span></span><br><span class="line">	<span class="keyword">if</span> v.Kind() != reflect.Slice &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// v is a slice.  now let&#x27;s ensure that it is a slice of structs.  if not,</span></span><br><span class="line">	<span class="comment">// return immediately.</span></span><br><span class="line">	<span class="keyword">if</span> e := v.Type().Elem(); e.Kind() != reflect.Struct &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// determine if our struct has a Name field of type string and a Nice field</span></span><br><span class="line">	<span class="comment">// of type bool</span></span><br><span class="line">	st := v.Type().Elem()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> nameField, found := st.FieldByName(<span class="string">&quot;Name&quot;</span>); found == <span class="literal">false</span> || nameField.Type.Kind() != reflect.String &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> niceField, found := st.FieldByName(<span class="string">&quot;Nice&quot;</span>); found == <span class="literal">false</span> || niceField.Type.Kind() != reflect.Bool &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set any Nice fields to true where the Name is &quot;Hank&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.Len(); i++ &#123;</span><br><span class="line">		e := v.Index(i)</span><br><span class="line">		name := e.FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">		nice := e.FieldByName(<span class="string">&quot;Nice&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> name.String() == <span class="string">&quot;Hank&quot;</span> &#123;</span><br><span class="line">			nice.SetBool(<span class="literal">true</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	children := []Child&#123;</span><br><span class="line">		&#123;Name: <span class="string">&quot;Sue&quot;</span>, Grade: <span class="number">1</span>, Nice: <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;Ava&quot;</span>, Grade: <span class="number">3</span>, Nice: <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;Hank&quot;</span>, Grade: <span class="number">6</span>, Nice: <span class="literal">false</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;Nancy&quot;</span>, Grade: <span class="number">5</span>, Nice: <span class="literal">true</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	adults := []Adult&#123;</span><br><span class="line">		&#123;Name: <span class="string">&quot;Bob&quot;</span>, Occupation: <span class="string">&quot;Carpenter&quot;</span>, Nice: <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;Steve&quot;</span>, Occupation: <span class="string">&quot;Clerk&quot;</span>, Nice: <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;Nikki&quot;</span>, Occupation: <span class="string">&quot;Rad Tech&quot;</span>, Nice: <span class="literal">false</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;Hank&quot;</span>, Occupation: <span class="string">&quot;Go Programmer&quot;</span>, Nice: <span class="literal">false</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;adults before nice: %v&quot;</span>, adults)</span><br><span class="line">	nice(adults)</span><br><span class="line">	log.Printf(<span class="string">&quot;adults after nice: %v&quot;</span>, adults)</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;children before nice: %v&quot;</span>, children)</span><br><span class="line">	nice(children)</span><br><span class="line">	log.Printf(<span class="string">&quot;children after nice: %v&quot;</span>, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">2018/12/16 12:00:00 adults before nice:</span> [&#123;<span class="string">Bob</span> <span class="string">Carpenter</span> <span class="literal">true</span>&#125; &#123;<span class="string">Steve</span> <span class="string">Clerk</span> <span class="literal">true</span>&#125; &#123;<span class="string">Nikki</span> <span class="string">Rad</span> <span class="string">Tech</span> <span class="literal">false</span>&#125; &#123;<span class="string">Hank</span> <span class="string">Go</span> <span class="string">Programmer</span> <span class="literal">false</span>&#125;]</span><br><span class="line"><span class="attr">2018/12/16 12:00:00 adults after nice:</span> [&#123;<span class="string">Bob</span> <span class="string">Carpenter</span> <span class="literal">true</span>&#125; &#123;<span class="string">Steve</span> <span class="string">Clerk</span> <span class="literal">true</span>&#125; &#123;<span class="string">Nikki</span> <span class="string">Rad</span> <span class="string">Tech</span> <span class="literal">false</span>&#125; &#123;<span class="string">Hank</span> <span class="string">Go</span> <span class="string">Programmer</span> <span class="literal">true</span>&#125;]</span><br><span class="line"><span class="attr">2018/12/16 12:00:00 children before nice:</span> [&#123;<span class="string">Sue</span> <span class="number">1</span> <span class="literal">true</span>&#125; &#123;<span class="string">Ava</span> <span class="number">3</span> <span class="literal">true</span>&#125; &#123;<span class="string">Hank</span> <span class="number">6</span> <span class="literal">false</span>&#125; &#123;<span class="string">Nancy</span> <span class="number">5</span> <span class="literal">true</span>&#125;]</span><br><span class="line"><span class="attr">2018/12/16 12:00:00 children after nice:</span> [&#123;<span class="string">Sue</span> <span class="number">1</span> <span class="literal">true</span>&#125; &#123;<span class="string">Ava</span> <span class="number">3</span> <span class="literal">true</span>&#125; &#123;<span class="string">Hank</span> <span class="number">6</span> <span class="literal">true</span>&#125; &#123;<span class="string">Nancy</span> <span class="number">5</span> <span class="literal">true</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>在这最后一个例子中，我们将前面学到的东西结合起来，通过 <code>reflect.Value</code> 来实际修改一个值。在这个场景下，有人（可能是 Hank）写了一个 <code>nice()</code> 函数，对于切片中的任意结构项，如果名字是“Hank”的话，它会将其从淘气（naughty）切换成友好（nice）。</p>
<p>注意：<code>nice()</code> 能够修改你传给它的任意切片的值，实际上，该函数接收到的参数类型是无关紧要的 —— 只要它是一个由结构组成的切片，并且该结构拥有 <code>Name</code> 和 <code>Nice</code> 字段。</p>
<h1 id="总结">总结</h1>
<p>Go 中的反射是使用 interface 和 <code>reflect</code> 包实现的。它并没有什么神奇之处：当你使用反射时，你可以直接访问一个 interface 中的各个部分以及所存储的值。</p>
<p>通过这种方式，interface 几乎就像是镜像，允许程序进行自检。</p>
<p>虽然 Go 是一种静态类型语言，但是反射和 interface 相结合，提供了通常是动态语言独有的非常强大的技术。</p>
<p>有关 Go 中反射的更多信息，请务必阅读包文档，以及该主题的许多其他精彩的博客文章。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>没事翻着玩</tag>
      </tags>
  </entry>
  <entry>
    <title>xadmin笔记：插件开发</title>
    <url>/2016/05/20/xadmin%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>adminx官方文档对插件系统的描述如下：</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Xadmin 的插件系统做的事情其实就是在<code>AdminView</code>运行过程中改变其执行的逻辑， 或是改变其返回的结果，起到修改或增强原有功能的效果。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>在实际运用过程中，我们可以制作插件来给页面添加新的布局、按钮等，来为页面添加更多自定义功能。</p>
<p>插件的制作过程如下：</p>
<ol type="1">
<li>创建自己的插件类， 插件类继承<code>BaseAdminPlugin</code>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xadmin.views <span class="keyword">import</span> BaseAdminPlugin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomizePlugin</span>(<span class="params">BaseAdminPlugin</span>):</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>编写<code>MyCustomizePlugin</code>类</p></li>
<li><p>将开发好的plugin注册到<code>AdminView</code>中：</p></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xadmin.site.register_plugin(MyCustomizePlugin, ListAdminView)</span><br></pre></td></tr></table></figure>
<h1 id="开发过程说明">开发过程说明</h1>
<p>其实官方文档已经说明了大致过程了，但由于各种原因（好吧，可能是因为我比较笨〒▽〒），很难理解应用在实际的开发过程中。下面是消化理解后整理的过程，以备后续不时之需。</p>
<h2 id="编写自定义plugin">编写自定义plugin</h2>
<p>在<code>AdminView</code>的执行过程中，可以被插件截获或修改的方法使用<code>filter_hook()</code>装饰。因此，可以查看要注册到的AdminView源码中使用该装饰器的方法。</p>
<h3 id="init_requestself-args-kwargs"><code>init_request(self, *args, **kwargs)</code></h3>
<p>插件在该方法中一般进行初始化的操作并且返回一个 Boolean 值告诉<code>AdminView</code>是否需要加载该插件。当 init_request() 方法返回值为 False 时，<code>AdminView</code>不会加载该插件。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mycustomize_allow = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_request</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bool</span>(self.mycustomize_allow)</span><br></pre></td></tr></table></figure>
<p>若要在<code>MyModelAdmin</code>中使用该插件，则可以在<code>MyModelAdmin</code>中设置<code>mycustomize_allow</code>值为<code>True</code></p>
<h3 id="block_xxxself-context-nodes"><code>block_xxx(self, context, nodes)</code></h3>
<ol type="1">
<li>context 即为 TemplateContext， nodes 参数包含了其他插件的返回内容。您可以直接返回 HTML 片段，或是将内容加入到 nodes 参数中</li>
</ol>

2.  Xadmin 中的模板代码中的view_block Tag 即为插件的 插入点 。插件可以在自己的插件类中使用 block_ + 插入点名称 方法将 HTML 片段插入到页面的这个位置

<p>使用例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">block_nav_menu</span>(<span class="params">self, context, nodes</span>):</span></span><br><span class="line">	context.update(&#123;</span><br><span class="line">		<span class="string">&#x27;options&#x27;</span>: [<span class="string">&#x27;intall&#x27;</span>, <span class="string">&#x27;unintall&#x27;</span>]</span><br><span class="line">	&#125;)</span><br><span class="line">	nodes.append(loader.render_to_string(<span class="string">&#x27;path/to/render/template&#x27;</span>, context=context))</span><br></pre></td></tr></table></figure>

上面的这个实现，会在{% view_block 'nav_menu' %}所在的位置，插入用context渲染`path/to/render/template`后的内容。

<p>接下来是干货！！</p>
<p><img src="/img/xadmin_view_block_basic.PNG" alt="基本插入点" /> <img src="/img/xadmin_view_block_list.PNG" alt="模型列表页面插入点" /> <img src="/img/xadmin_view_block_edit.PNG" alt="模型编辑页面插入点" /></p>
<h3 id="get_mediaself-media"><code>get_media(self, media)</code></h3>
<p>该方法可以用来添加额外的js/css文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_media</span>(<span class="params">self, media</span>):</span></span><br><span class="line">    media.add_js((<span class="string">&#x27;/path/to/js_or_css&#x27;</span>,))</span><br><span class="line">    <span class="keyword">return</span> media</span><br></pre></td></tr></table></figure>
<h3 id="get_contextself"><code>get_context(self)</code></h3>
<p>返回显示页面所需的 context 对象。</p>
<h2 id="注册plugin">注册plugin</h2>
<p>根据官方文档，有以下几种<code>AdminView</code>：</p>
<ul>
<li><p><a href="https://xadmin.readthedocs.io/en/latest/views_api.html#xadmin.views.BaseAdminView">BaseAdminView</a></p>
<p>所有<code>AdminView</code>的基础类，注册在该 View 上的插件可以影响所有的<code>AdminView</code></p></li>
<li><p><a href="https://xadmin.readthedocs.io/en/latest/views_api.html#xadmin.views.CommAdminView">CommAdminView</a></p>
<p>用户已经登陆后显示的 View，也是所有登陆后 View 的基础类。该 View主要作用是创建了 Xadmin 的通用元素，例如：系统菜单，用户信息等。插件可以通过注册该 View 来修改这些信息。</p></li>
<li><p><a href="https://xadmin.readthedocs.io/en/latest/views_api.html#xadmin.views.ModelAdminView">ModelAdminView</a></p>
<p>基于 Model 的<code>AdminView</code>的基础类，注册的插件可以影响所有基于 Model 的 View。</p></li>
<li><p><a href="https://xadmin.readthedocs.io/en/latest/views_api.html#xadmin.views.ListAdminView">ListAdminView</a></p>
<p>Model 列表页面 View。</p></li>
<li><p><a href="https://xadmin.readthedocs.io/en/latest/views_api.html#xadmin.views.ModelFormAdminView">ModelFormAdminView</a></p>
<p>Model 编辑页面 View。</p></li>
<li><p><a href="https://xadmin.readthedocs.io/en/latest/views_api.html#xadmin.views.CreateAdminView">CreateAdminView</a></p>
<p>Model 创建页面 View。</p></li>
<li><p><a href="https://xadmin.readthedocs.io/en/latest/views_api.html#xadmin.views.UpdateAdminView">UpdateAdminView</a></p>
<p>Model 修改页面 View。</p></li>
<li><p><a href="https://xadmin.readthedocs.io/en/latest/views_api.html#xadmin.views.DeleteAdminView">DeleteAdminView</a></p>
<p>Model 删除页面 View。</p></li>
<li><p><a href="https://xadmin.readthedocs.io/en/latest/views_api.html#xadmin.views.DetailAdminView">DetailAdminView</a></p>
<p>Model 详情页面 View。</p></li>
</ul>
<blockquote>
<p>说明：注册语句可以直接在<code>adminx.py</code>中实现，也可以放在别的地方，然后导入到<code>adminx.py</code>中即可。</p>
</blockquote>
<h1 id="举个栗子-大白话开发过程">举个栗子 + 大白话开发过程</h1>
<p>举个例子。假设我要在<strong>Model 编辑页面</strong>上正文的导航条上加个菜单。那么，</p>
<ol type="1">
<li>声明这个插件类，继承<code>BaseAdminPlugin</code></li>
<li>因为我要在所有编辑页面上都加，也就是说创建页面和修改页面都要有，因此选择注册到<code>ModelFormAdminView</code>上。</li>
<li>声明插件类的<code>init_request</code>方法，添加一个属性<code>xxx_allow</code>来决定要不要使用该插件。 
4. 因为是要修改页面的，因此要找到插入点。有了上面的干货，发现插入点是{% view_block 'nav_menu' %}
</li>
<li>找到插入点了，编写<code>block_nav_menu</code>方法。使用context.update添加一些菜单信息，在我的<code>xxx_template.html</code>模板里面要使用这些菜单信息来构建菜单。然后使用<code>nodes.append(loader.render_to_string('/path/to/xxx_template.html', context=context))</code>添加渲染信息</li>
<li>当然，还要编写xxx_template.html啦。</li>
<li>决定不要在xxx_template.html中实现js，于是单独实现了一个js。这样的话，需要在插件类中实现<code>get_media</code>加入新的js，才能使我这个新的js对这个插件生效</li>
<li>最后，在我的modeladmin上面设置<code>xxx_allow=True</code>，从而使得此model使用该插件。</li>
</ol>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://xadmin.readthedocs.io/en/latest/make_plugin.html">Xadmin 插件制作</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>一些SQL优化技巧</title>
    <url>/2015/11/13/%E4%B8%80%E4%BA%9BSQL%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="索引">索引</h1>
<p>合理有效的使用索引可以提高查询效率 ## 选择合适的索引列规则 1. 选择在where子句中常用的查询列 2. 选择常用来关联表的字段 3. 对普通的B-TREE索引，应选择具有选择性高的字段做索引字段。若字段的不同取值很少，则选择性低，适合建位映射索引(效率更高，占用空间更小)。 4. 不要在经常被修改的字段上建索引。索引会降低update, insert, delete等操作的效率</p>
<h2 id="避免在索引列上使用计算或在非基于函数的索引列上使用函数">避免在索引列上使用计算或在非基于函数的索引列上使用函数</h2>
<ol type="1">
<li>where子句中，若索引列是函数的一部分，优化器将不使用索引而使用全表扫描</li>
<li>使用了<code>!=</code>, <code>|</code>, 类型转换将不使用索引</li>
<li>要对使用函数的列启用索引，建议建基于函数的索引；也可以将计算右移</li>
</ol>
<h2 id="总使用索引的第一个列">总使用索引的第一个列</h2>
<ol type="1">
<li>若索引是复合索引，只有在它的第一个列被where子句引用时，优化器才会选择使用该索引。</li>
</ol>
<h1 id="顺序选择">顺序选择</h1>
<h2 id="表名顺序">表名顺序</h2>
<ol type="1">
<li>ORACLE解释器按 **从右到左 的顺序处理FROM子句中的表名。</li>
<li>在FROM子句包含多个表的情况下，应选择记录数最小的表作为基础表。</li>
<li>若有3个以上的表，则需选择交叉表作为基础表</li>
</ol>
<h2 id="where子句中的连接顺序">where子句中的连接顺序</h2>
<ol type="1">
<li>ORACLE **自下而上 的解析where子句。表之间的连接应该写在其他where条件之前，那些可以过滤掉最大数量记录的条件应写在where子句的末尾。</li>
</ol>
<h1 id="更优的方法">更优的方法</h1>
<h2 id="使用union-all而不是union">使用union all，而不是union</h2>
<p>union = union all + 排序剔重 若不需要踢重，使用union all会节省时间，提高效率</p>
<h2 id="使用truncate而不是delete">使用truncate，而不是delete</h2>
<p>delete后，数据可以恢复。 而truncate后，数据不可恢复，因此很少资源被调用，执行时间也短。</p>
<h2 id="使用where子句而不是having子句">使用where子句，而不是having子句</h2>
<p>having语句是检索出结果后对结果集过滤。一般用于对一些聚合函数的比较</p>
<h2 id="使用union而不是or">使用union，而不是or</h2>
<ol type="1">
<li>对索引列用or会造成全表扫描</li>
<li>也可以用in替换or，更进一步，用exist替换in</li>
</ol>
<h1 id="其他">其他</h1>
<ol type="1">
<li>优化group by语句：将不需要的记录在group by之前过滤掉</li>
<li>慎用is null：null值不在索引中，若用is null操作会使用不了索引</li>
<li>在OLTP总是用绑定变量。例如：<code>select * from tbl where msisdn=:1</code></li>
<li>select语句中避免出现*</li>
</ol>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>一枚心跳的旅程 — pika心跳机制</title>
    <url>/2016/09/28/%E4%B8%80%E6%9E%9A%E5%BF%83%E8%B7%B3%E7%9A%84%E6%97%85%E7%A8%8B%20%E2%80%94%20pika%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="简单的背景介绍">简单的背景介绍</h2>
<ol type="1">
<li>pika是AMQP 0-9-1协议的一个纯Python实现。本文使用的pika版本为0.10.0</li>
<li>AMQP 0-9-1提供了心跳机制，来确保应用服务层及时发现已崩溃的连接（以及完全无响应的对端）。心跳机制也能保证进程不被某些网络设备杀掉。</li>
<li>RabbitMQ的心跳机制（搬运自官网）
<ul>
<li>使用心跳超时间隔(heartbeat timeout interval)。该值定义了经过多长时间，RabbitMQ和客户端库应该认为对端的TCP连接已经失活(dead)。该值是在客户端和RabbitMQ服务器在连接的时候协商决定的。必须配置客户端请求心跳。在RabbitMQ v3.0及之后的版本，broker会尝试协商默认的heartbeat值（客户端仍然可以否决该值）。<strong>默认值是60s（3.5.5版本之前则是580s）</strong></li>
<li><strong>每半个超时时间发送一个心跳帧。在两次心跳没有响应后，就会认为对端不可达。</strong></li>
</ul></li>
</ol>
<h2 id="角色说明">角色说明</h2>
<h3 id="heartbeatchecker心跳检查器"><code>HeartbeatChecker</code>：心跳检查器</h3>
<ul>
<li><p>初始化：<code>__init__(connection, interval, idle_count=MAX_IDLE_COUNT)</code></p>
<ol type="1">
<li>将心跳检查器与connnection对象绑定，设置心跳检查间隔_interval、经过多少个丢失的心跳间隔数后认为连接idle或者断连的心跳间隔数_max_idle_count（默认情况下是MAX_IDLE_COUNT=2）</li>
<li>初始化多个计数器为0</li>
<li>为最后一个定时器初始化句柄(None)</li>
<li>调用<code>_setup_timer()</code>方法设置定时器在每个_interval秒后触发</li>
</ol></li>
<li><p>设置定时器：<code>_setup_timer()</code></p>
<p>添加定时器，在每个_interval秒后调用<code>send_and_check()</code>方法检查及发送心跳</p></li>
<li><p>定时器方法：<code>send_and_check()</code></p>
<p><img src="/img/pika.heartbeat.send_and_check.png" /></p>
<p>由定时器调用，需要时发送一个心跳，检查是否错过了任何心跳，并在太长时间处于idle状态的情况下断开连接</p>
<ol type="1">
<li><p>判断连接是否处于idle状态，是则调用<code>_close_connection()</code>方法关闭连接 &gt; 如何判断连接状态：当前的idle计数器大于或等于设置的最大idel计数器时，则认为连接处于idle状态</p></li>
<li><p>如果connection对象并未收到任何数据，则将当前的idle计数器加一；否则清零当前的idle计数器 &gt; 如何判断connection对象收到数据：判断接收到的字节数计数器(<code>_bytes_received</code>)以及连接对象收到的字节数计数器(<code>bytes_received_on_connection</code>)是否相等。</p></li>
<li><p>调用<code>_update_counters()</code>方法更新发送/接收到的字节数计数器</p></li>
<li><p>调用<code>_send_heartbeat_frame()</code>方法发送一个心跳帧给对端（也就是RabbitMQ服务器啦），同时将发送的心跳帧计数器(<code>_heartbeat_frames_sent</code>)加一。</p></li>
<li><p>调用<code>_start_timer()</code>方法启动新一轮的定时器。这个时候会先判断connection对象的定时器是否还是当前这个实例，如果是的话，会调用<code>_setup_timer()</code>方法设置定时器。</p></li>
</ol></li>
<li><p>接收心跳帧：<code>received()</code></p>
<p>将收到的心跳帧计时器加一</p></li>
<li><p>停止心跳检查器：<code>stop()</code></p>
<p>将该定时器从绑定的connection对象移除</p></li>
</ul>
<h3 id="connection实现与rabbitmq通信的核心类"><code>Connection</code>：实现与RabbitMQ通信的核心类</h3>
<blockquote>
<p>只说明几个跟心跳有关的方法</p>
</blockquote>
<ul>
<li><p>创建心跳检查器：<code>_create_heartbeat_checker()</code></p>
<p>如果参数heartbeat有值并且大于0，则使用当前的connection实例(self)和设置的heartbeat值来初始化一个心跳检查器</p></li>
<li><p>停止并删除绑定的心跳检查器：<code>_remove_heartbeat()</code></p></li>
<li><p>协商心跳超时时间：<code>_tune_heartbeat_timeout(client_value, server_value)</code></p>
<ul>
<li>client_value是客户端给出的心跳超时时间，None表示完全接受服务端给出的值(即server_value)，0表示禁用心跳，否则使用一个正整数(s)</li>
<li>server_value是broker建议的心跳超时时间，0表示禁用心跳</li>
<li>该方法最终返回一个使用的心跳超时时间，并将其返回给服务器</li>
</ul></li>
</ul>
<h2 id="旅程开始">旅程开始</h2>
<p>在pika与RabbitMQ服务器通信最最最开始的时候，是需要创建连接的。这个时候呢，pika作为客户端，需要设置一个<code>heartbeat</code>(<code>heartbeat_interval</code>已弃用)参数。默认情况下，该参数的值由<code>DEFAULT_HEARTBEAT_TIMEOUT</code>（默认是<code>None</code>）指定，表示RabbitMQ你说心跳时间间隔是啥就是啥，我客户端这边完全没意见。</p>
<p>接着，就是连接建立的各种过程中。在这个过程中，当接收到broker发送的Connection.Tune时，客户端会根据对端的心跳时间间隔和客户端定义的心跳间隔（也就是<code>heartbeat</code>参数）协商一个合适的心跳时间间隔（调用<code>_tune_heartbeat_timeout()</code>方法）。协商策略是： * 如果客户端这边的值为None，则心跳时间间隔由RabbitMQ决定； * 如果客户端这边的值或者RabbitMQ那边的值为0，则禁用心跳； * 否则，选客户端这边的值和RabbitMQ那边的值之间的最大值。</p>
<p>然后根据协商后的心跳时间间隔，绑定一个新的心跳检查器。此时，这个新的心跳检查器就会带着它的处理句柄跳进IOLoop，也就是轮询器中，等待它的时间的到来。</p>
<p>后面就是业务交互过程了。</p>
<p>在处理从socket接收到的帧时，如果接收到了心跳，则调用心跳检查器的<code>received()</code>方法，增加心跳检查器的收到心跳帧计时器。</p>
<p>在轮询的过程中，心跳检查器的时间来了，它会执行绑定的处理句柄，也就是<code>send_and_check()</code>方法。此时，它会设置idle次数计数器、更新接收/发送帧计数器、响应一个心跳帧给对端。然后，带着它的处理句柄再次跳进轮询器中，等待新一轮的时间的到来。</p>
<p>当然，这是正常的情况。如果上面这一步中，心跳检查器发现自己绑定的connection已经多次没收到数据了，次数多得已经超过自己的容忍程度（此时，猜测对端已经死掉），这个时候，会主动断开与对端的连接。又或者如果绑定的connection的心跳检查器已经不再是自己了，则不再跳进轮询器。</p>
<p>另外有一点需要注意的是，pika中有个<code>BlockingConnection</code>(它位于pika的异步之上，提供阻塞连接)。因为是阻塞连接，因此定时器在这里并没啥用处，从而导致心跳检查器无法定时触发。这进一步导致了，如果在RabbitMQ多次发送心跳进行探测的时候客户端都阻塞无法响应的话，RabbitMQ会认为客户端已经不在了，从而断开与客户端之间的连接~~</p>
<p>到了最后的最后，告别的时刻来临。此时，会把心跳检查器停止（如果，它还在的话）……</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://www.rabbitmq.com/heartbeats.html">Detecting Dead TCP Connections with Heartbeats</a></li>
<li><a href="https://my.oschina.net/hncscwc/blog/195343">rabbitmq——heartbeat</a></li>
</ul>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>读代码</tag>
        <tag>pika</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>一次抓虫引发的对python导入机制的初步认识</title>
    <url>/2016/11/19/%E4%B8%80%E6%AC%A1%E6%8A%93%E8%99%AB%E5%BC%95%E5%8F%91%E7%9A%84%E5%AF%B9python%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<p>前段时间因为生产上连接数的问题，手机被告警信息一波一波地袭击。问题的现象是，项目中每个进程都有一个全局的连接对象，一个对象对应一个socket连接。从输出日志可以看出这个对象有正常的建立连接和断开连接过程。但奇怪的是，通过<code>netstat</code>查看连接数，却超过了进程数，说明进程的连接对象并不是进程内全局唯一的。</p>
<p>于是给日志加上了线程id，再次运行发现，同一个线程（该项目使用的是多进程单线程）中对该连接对象进行了两次初始化，并且这两次初始化的对象id（通过内置的<code>id()</code>方法得出）不同。说明该连接对象并非进程内全局唯一的。</p>
<p>可是这是为什么呢？？？</p>
<p>这个连接对象是作为模块内全局对象定义的，并且被同一个模块内的函数所访问。其他模块通过导入该模块的函数来间接使用该连接对象。因此，理论上讲，导入相同的模块，使用的应该是同一个对象才对。百思不得其解的情况下，有一个疑问摆在面前 —— python，是如何处理导入的呢？</p>
<p>为了弄清这个问题，我们来做个测试。</p>
<p>测试验证目录树如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── main.py &lt;- 程序主入口</span><br><span class="line">└── test_import</span><br><span class="line">    ├── a.py</span><br><span class="line">    ├── b.py</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── main.py</span><br><span class="line">    ├── query</span><br><span class="line">    │   ├── client.py &lt;- 这个模块就是保存全局连接对象的模块啦</span><br><span class="line">    │   └── __init__.py</span><br><span class="line">    └── v1</span><br><span class="line">        ├── c.py</span><br><span class="line">        └── __init__.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每个文件内容如下： * <code>main.py</code>：主入口 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> test_import <span class="keyword">import</span> main</span><br><span class="line"></span><br><span class="line">main.main()</span><br><span class="line"><span class="comment">#import sys</span></span><br><span class="line"><span class="comment">#print &quot;id of conn in test_import.query.client&quot;, id(sys.modules[&#x27;test_import.query.client&#x27;].__dict__[&#x27;conn&#x27;])</span></span><br><span class="line"><span class="comment">#print &quot;id of conn in query.client&quot;, id(sys.modules[&#x27;query.client&#x27;].__dict__[&#x27;conn&#x27;])</span></span><br></pre></td></tr></table></figure> * <code>test_import/a.py</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> query.client <span class="keyword">import</span> get_data</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;in&quot;</span>, __file__</span><br><span class="line">    get_data()</span><br></pre></td></tr></table></figure> * <code>test_import/b.py</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> query.client <span class="keyword">import</span> get_data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;in&quot;</span>, __file__</span><br><span class="line">    get_data()</span><br></pre></td></tr></table></figure> * <code>test_import/main.py</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> v1 <span class="keyword">import</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> a <span class="keyword">import</span> a</span><br><span class="line"><span class="keyword">from</span> b <span class="keyword">import</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;in&quot;</span>, __file__</span><br><span class="line">    a()</span><br><span class="line">    b()</span><br><span class="line">    c.c()</span><br></pre></td></tr></table></figure> * <code>test_import/query/client.py</code>：我们在这里创建一个模块全局变量，并且将其当成整个project的全局变量使用 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Conn</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">conn = Conn()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;[&#123;0&#125;] id of conn is &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(__file__, <span class="built_in">id</span>(conn)) <span class="comment"># 通过conn的id来识别是否属于同一个实例</span></span><br></pre></td></tr></table></figure> * <code>test_import/v1/c.py</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line">current_dir = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">sys.path.append(os.path.dirname(current_dir))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> query.client <span class="keyword">import</span> get_data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;in&quot;</span>, __file__</span><br><span class="line">    get_data()</span><br></pre></td></tr></table></figure> 好了，准备好测试项目之后，让我们开始研究吧～～</p>
<p>首先，运行一下： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ python main.py </span><br><span class="line"><span class="keyword">in</span> /Users/ele/lab/<span class="built_in">test</span>/test_import/main.pyc</span><br><span class="line"><span class="keyword">in</span> /Users/ele/lab/<span class="built_in">test</span>/test_import/a.pyc</span><br><span class="line">[/Users/elexu/lab/<span class="built_in">test</span>/test_import/query/client.pyc] id of conn is 4327254928</span><br><span class="line"><span class="keyword">in</span> /Users/ele/lab/<span class="built_in">test</span>/test_import/b.pyc</span><br><span class="line">[/Users/ele/lab/<span class="built_in">test</span>/test_import/query/client.pyc] id of conn is 4327254928</span><br><span class="line"><span class="keyword">in</span> /Users/ele/lab/<span class="built_in">test</span>/test_import/v1/c.pyc</span><br><span class="line">[/Users/ele/lab/<span class="built_in">test</span>/test_import/query/client.pyc] id of conn is 4327254480</span><br></pre></td></tr></table></figure> 从结果可以看出，a.py和b.py中访问的是同个<code>conn</code>对象，而在c.py中访问的却是另一个<code>conn</code>对象。</p>
<p>这里要提到一个东东 —— <code>sys.modules</code>。关于它有几点信息： 1. <code>sys.modules</code>是python标准库sys中的一个类型为<code>dict</code>的成员，包含自python启动起导入的所有模块。该字典中，键为模块名，值为模块对象。 2. 当导入一个新模块的时候，python会把它们添加到<code>sys.modules</code>中。当第二次导入时，python会在<code>sys.modules</code>中进行查找</p>
<p>因此，为了解释我们第一次运行的结果中，a.py和b.py中访问的对象与c.py不同的原因，可以在a.py/b.py/c.py中的<code>from query.client import get_data</code>之后都加上这么一句话： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span> __file__, [(k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> sys.modules.items() <span class="keyword">if</span> <span class="string">&quot;client&quot;</span> <span class="keyword">in</span> k]</span><br></pre></td></tr></table></figure> &gt; 说明：因为我们要探究的是client这个模块，因此使用<code>if "client" in k</code>来过滤掉不需要的模块信息。</p>
<p>再次运行： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/Users/ele/lab/test/test_import/v1/c.py [(<span class="string">&#x27;query.client&#x27;</span>, &lt;module <span class="string">&#x27;query.client&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;/Users/ele/lab/test/test_import/query/client.pyc&#x27;</span>&gt;)]</span><br><span class="line">/Users/ele/lab/test/test_import/a.py [(<span class="string">&#x27;test_import.query.client&#x27;</span>, &lt;module <span class="string">&#x27;test_import.query.client&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;/Users/ele/lab/test/test_import/query/client.pyc&#x27;</span>&gt;), (<span class="string">&#x27;query.client&#x27;</span>, &lt;module <span class="string">&#x27;query.client&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;/Users/ele/lab/test/test_import/query/client.pyc&#x27;</span>&gt;)]</span><br><span class="line">/Users/ele/lab/test/test_import/b.py [(<span class="string">&#x27;test_import.query.client&#x27;</span>, &lt;module <span class="string">&#x27;test_import.query.client&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;/Users/ele/lab/test/test_import/query/client.pyc&#x27;</span>&gt;), (<span class="string">&#x27;query.client&#x27;</span>, &lt;module <span class="string">&#x27;query.client&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;/Users/ele/lab/test/test_import/query/client.pyc&#x27;</span>&gt;)]</span><br><span class="line">……</span><br></pre></td></tr></table></figure> 在c.py中，涉及到client到模块信息只有'query.client'，而a.py和b.py却多了'test_import.query.client'。</p>
<p>对这个结果进行推论：python导入了两个模块，'query.client'和'test_import.query.client'。虽然这两个模块实际上使用到是同一份源代码（即client.py），但是由于模块名不同，因此python将它们二者当成两个完全不一样到模块处理。在导入过程中，这两个模块fen b分别初始化了一次<code>conn</code>对象。c.py是从'query.client'导入的，而a.py和b.py是从'test_import.query.client'导入，所以a.py和b.py中访问的<code>conn</code>对象才与c.py不同。</p>
<p>取消main.py中最后两行注释语句，看看结果是否如我们所推断的那样: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">in /Users/elexu/lab/test/test_import/main.pyc</span><br><span class="line">in /Users/elexu/lab/test/test_import/a.pyc</span><br><span class="line">[/Users/elexu/lab/test/test_import/query/client.pyc] id of conn is 4533709840</span><br><span class="line">in /Users/elexu/lab/test/test_import/b.pyc</span><br><span class="line">[/Users/elexu/lab/test/test_import/query/client.pyc] id of conn is 4533709840</span><br><span class="line">in /Users/elexu/lab/test/test_import/v1/c.pyc</span><br><span class="line">[/Users/elexu/lab/test/test_import/query/client.pyc] id of conn is 4533709392</span><br><span class="line">id of conn in test_import.query.client 4533709840</span><br><span class="line">id of conn in query.client 4533709392</span><br></pre></td></tr></table></figure> Bingo！！！</p>
<p>接下来有第二个疑问。代码层面，a.py/b.py/c.py使用的都是相同的导入代码：<code>from query.client import get_data</code>。因此，为什么导入模块名会不同呢？对于该问题，我们可以从python的模块导入路径切入。</p>
<p>再次，在a.py/b.py/c.py中的<code>from query.client import get_data</code>之前加入以下语句： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span> __file__, <span class="built_in">filter</span>(<span class="keyword">lambda</span> p: <span class="string">&quot;test&quot;</span> <span class="keyword">in</span> p, sys.path)</span><br></pre></td></tr></table></figure> &gt; 说明：为了避免打印出一堆无关的路径，使用filter()进行了过滤</p>
<p>再次运行下： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/Users/ele/lab/<span class="built_in">test</span>/test_import/v1/c.py [<span class="string">&#x27;/Users/ele/lab/test&#x27;</span>, <span class="string">&#x27;/Users/ele/lab/test/test_import&#x27;</span>]</span><br><span class="line">……</span><br><span class="line">/Users/ele/lab/<span class="built_in">test</span>/test_import/a.py [<span class="string">&#x27;/Users/ele/lab/test&#x27;</span>, <span class="string">&#x27;/Users/ele/lab/test/test_import&#x27;</span>]</span><br><span class="line">……</span><br><span class="line">/Users/ele/lab/<span class="built_in">test</span>/test_import/b.py [<span class="string">&#x27;/Users/ele/lab/test&#x27;</span>, <span class="string">&#x27;/Users/ele/lab/test/test_import&#x27;</span>]</span><br><span class="line">……</span><br></pre></td></tr></table></figure> 发现在a.py/b.py/c.py中，与我们的测试目录相关的路径都是一样的。</p>
<p>看来，只能逐个击破了。</p>
<p>将c.py中的下面两行代码注释掉： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">current_dir = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">sys.path.append(os.path.dirname(current_dir))</span><br></pre></td></tr></table></figure> 运行之后会得到<code>ImportError: No module named query.client</code>这样的错误。这说明了，c.py中的<code>query.client</code>是从<code>/Users/ele/lab/test/test_import</code>中导入的。</p>
<p>现在，来看看a.py和b.py。将test_import.main中涉及到c.py到内容注释掉，然后运行。此时sys.path中已经没有了<code>/Users/ele/lab/test/test_import</code>这一项，但是a.py和b.py仍然可以正常导入。说明，a.py和b.py中的<code>from query.client import get_data()</code>并非从<code>/Users/ele/lab/test/test_import</code>这个路径上搜索导入的。</p>
<p>现在我们来总结解释下。</p>
<p>python在a.py/b.py和c.py中运行到<code>from query.client import get_data()</code>这条语句的时候，由于搜索路径不同，因此导入生成到模块名不同，这近一步导致了python讲它们当成两个完全独立到模块进行处理。</p>
<p>修改方法也很简单。只需将c.py中的<code>from query.client import get_data</code>修改成<code>from test_import.query.client import get_data</code>即可。</p>
<p>运行验证下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> /Users/ele/lab/<span class="built_in">test</span>/test_import/main.pyc</span><br><span class="line"><span class="keyword">in</span> /Users/ele/lab/<span class="built_in">test</span>/test_import/a.pyc</span><br><span class="line">[/Users/ele/lab/<span class="built_in">test</span>/test_import/query/client.pyc] id of conn is 4373236432</span><br><span class="line"><span class="keyword">in</span> /Users/ele/lab/<span class="built_in">test</span>/test_import/b.pyc</span><br><span class="line">[/Users/ele/lab/<span class="built_in">test</span>/test_import/query/client.pyc] id of conn is 4373236432</span><br><span class="line"><span class="keyword">in</span> /Users/ele/lab/<span class="built_in">test</span>/test_import/v1/c.py</span><br><span class="line">[/Users/ele/lab/<span class="built_in">test</span>/test_import/query/client.pyc] id of conn is 4373236432</span><br></pre></td></tr></table></figure>
<p>o(<sup>▽</sup>)o</p>
<h2 id="碎碎念">碎碎念</h2>
<p>python这个磨人的小妖精～～</p>
<h2 id="扩展阅读">扩展阅读</h2>
<ul>
<li><a href="http://blog.mimvp.com/2015/01/python-import-mechanism-details/">Python import 机制详解</a></li>
<li><a href="http://www.diveintopython.net/file_handling/more_on_modules.html">Using sys.modules</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>七月浑浑又噩噩，打着呵欠写代码</title>
    <url>/2016/07/29/%E4%B8%83%E6%9C%88%E6%B5%91%E6%B5%91%E5%8F%88%E5%99%A9%E5%99%A9%EF%BC%8C%E6%89%93%E7%9D%80%E5%91%B5%E6%AC%A0%E5%86%99%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>由于这个月大部分时间都在查日志，查日志，查日志，因此大致扫了一眼sed，又扫了一眼awk，酷壳的简明教程真真是个好东西！</p>
<p>幸运的是，之前虽然花了大力气在部署自动化上，花了老长老长的时间学用ansible，但关键时候，就显现出它的好来。磨刀不误砍柴工，古训不欺我。</p>
<p>这个月的增进甚微，而且磨磨蹭蹭才整理两篇代码阅读笔记。实在惭愧。不过好歹写出来了，写的过程中又去翻了一遍代码，温故知新。pssh也是最近用的频率top 10的工具之一，相较于ansible，它更加小但轻。有时间的话，可以好好写写。</p>
<p>这个月过得着实有点累。地铁时光只想发呆，连拿kindle出来的意愿都没有。但人在高压下，要么死掉，要么顽强抵抗长得更快。虽不至为高压，但工作上的熟稔和增进速度，就数这个月来最快了。也是惭愧，之前太过放任自己。另外，不看书的话，发现几个有意思的技术podcast，给眼睛放假，让耳朵代班。有时也会想，要不我也做个播客玩玩？！哈哈，谁知道呢~</p>
<p>最近也有一些事做得不好，处理得不够妥当。其实略为低落。但脑海中突然蹦出一句话，想要不犯错只有什么事都不做。失败是成功的妈妈，错误是正确的爸爸。默默在心中读了三遍(&gt;_&lt;)</p>
<p>回头又仔仔细细的看了写的东西，发现七月份过得真是平淡呢。希望下个月会有点新鲜和惊喜。</p>
<p>所以下面就是TODO啦~~~</p>
<ul>
<li><a href="#">PyCon 2016</a>。这算是python的一大盛事吧。某日休息，好奇点开，觉得甚是不错。所以，每天看一点，看一点，权当开阔视野</li>
<li><a href="https://book.douban.com/subject/10555435/">七周七语言</a>。某天提到要弄个专题，写N个语言的Hello World。后来又想到有此书，以此了解各种编程思想，open mind，也不错。（是哒，就是如此发散漫无目的！！）</li>
<li>地铁书：<a href="https://book.douban.com/subject/26351257/">算法的乐趣</a></li>
<li>10pm：<a href="https://book.douban.com/subject/25942191/">第一行代码</a>。说好的下半年开启Android之旅。就从这本书开始吧。</li>
<li>至于nginx：C忘得七七八八，所以涉及到nginx代码的时候甚是痛苦。进展缓慢，所幸没给自己设deadline。那就还是，每天看一点，看一点。哦，有时间要补补C~</li>
</ul>
<blockquote>
<p>P.S. 突然发现有三本书是有纸质书的，lucky~~</p>
</blockquote>
<p>Fighting and Happy Coding O(∩_∩)O~</p>
]]></content>
      <categories>
        <category>这就是生活</category>
      </categories>
      <tags>
        <tag>Ele在思考</tag>
      </tags>
  </entry>
  <entry>
    <title>九大排序算法及其Python实现之堆排序</title>
    <url>/2015/12/07/%E4%B9%9D%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6Python%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>输入：n个数的一个序列&lt;a1,a2,...,an&gt; (A[1..n]) 输出：输入序列的一个排序&lt;b1,b2,...,bn&gt;，满足b1≤b2≤...≤bn。</p>
<h1 id="思想">思想</h1>
<p>参考：<a href="https://zh.wikipedia.org/zh/%E5%A0%86%E6%8E%92%E5%BA%8F">Wiki百科：堆排序</a> ## 堆 表示堆的数组A包括两个属性：A.length给出数组元素的个数，A.heap-size表示有多少个堆元素存储在该数组中。也就是说，虽然A[1..A.length]可能都存有数据，但只有A[1..A.heap-size]中存放的是堆的有效元素。这里, 0 ≤ A.heap-size ≤ A.length。</p>
<p>（二叉）堆数组A是一个近似的完全二叉树，树的根结点是A[1]，这样，给定一个结点的下标i，它的父节点、左孩子和右孩子的下标： <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">PARENT</span><span class="params">(i)</span></span> : return i/<span class="number">2</span> <span class="comment">// i&gt;&gt;1</span></span><br><span class="line"><span class="function"><span class="title">LEFT</span><span class="params">(i)</span></span> : return <span class="number">2</span>i <span class="comment">// i&lt;&lt;1</span></span><br><span class="line"><span class="function"><span class="title">RIGHT</span><span class="params">(i)</span></span> : return <span class="number">2</span>i+<span class="number">1</span> <span class="comment">// i&lt;&lt;1 + 1</span></span><br></pre></td></tr></table></figure> 1. 最大堆：堆的最大元素存放在根结点中。并且，在任一子树中，该子树所包含的所有结点的值都不大于该子树根结点的值。即：<code>A[PARENT(i) ≥ A[i]</code>。堆排序使用最大堆。 2. 最小堆：堆的最小元素存放在根结点中。并且，在任一子树中，该子树所包含的所有结点的值都不小于该子树根结点的值。即：<code>A[PARENT(i) ≤ A[i]</code>。最小堆常用来构造优先队列。</p>
<p>堆中结点的高度：该结点到叶结点最长简单路径上边的数目。 堆的高度：根结点的高度。O(lgn)。其中，n为堆中元素个数。</p>
<h1 id="实现">实现</h1>
<p>伪代码 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"># 时间复杂度：<span class="constructor">O(<span class="params">lgn</span>)</span>，维护最大堆性质的关键，假设根结点为<span class="constructor">LEFT(I)</span>和<span class="constructor">RIGHT(<span class="params">i</span>)</span>的二叉树都是最大堆</span><br><span class="line"># 通过让A<span class="literal">[<span class="identifier">i</span>]</span>的值在最大堆中“逐级下降”，从而使得下标i为根结点的子树重新遵循最大堆的性质</span><br><span class="line">MAX-<span class="constructor">HEAPIFY(A, <span class="params">i</span>)</span></span><br><span class="line">    l = <span class="constructor">LEFT(<span class="params">i</span>)</span></span><br><span class="line">    r = <span class="constructor">RIGHT(<span class="params">i</span>)</span></span><br><span class="line">    # 找到i，i的左子树的根结点，i的右子树的根结点中值最大的结点</span><br><span class="line">    <span class="keyword">if</span> l &lt;= <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>heap-size <span class="keyword">and</span> A<span class="literal">[<span class="identifier">l</span>]</span> &gt; A<span class="literal">[<span class="identifier">i</span>]</span></span><br><span class="line">        largest = l</span><br><span class="line">    <span class="keyword">else</span> largest = i</span><br><span class="line">    <span class="keyword">if</span> r &lt;= <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>heap-size <span class="keyword">and</span> A<span class="literal">[<span class="identifier">r</span>]</span> &gt; A<span class="literal">[<span class="identifier">largest</span>]</span></span><br><span class="line">        largest = r</span><br><span class="line">    # 若值最大的结点不是i，则把最大的值跟i指定的值交换。</span><br><span class="line">    # 然后继续对原值最大的结点递归进行MAX-HEAPIFY操作</span><br><span class="line">    # 若值最大的结点就是i，说明以i为根结点的子树已是最大堆，函数结束</span><br><span class="line">    <span class="keyword">if</span> largest != i</span><br><span class="line">        exchange A<span class="literal">[<span class="identifier">i</span>]</span> <span class="keyword">with</span> A<span class="literal">[<span class="identifier">largest</span>]</span></span><br><span class="line">        MAX-<span class="constructor">HEAPIFY(A, <span class="params">largest</span>)</span></span><br><span class="line"># 线性时间复杂度，从无序的输入数据数组中构造一个最大堆</span><br><span class="line">BUILD-MAX-<span class="constructor">HEAP(A)</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>heap-size = <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>length</span><br><span class="line">    <span class="keyword">for</span> i = <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>length/<span class="number">2</span> <span class="keyword">downto</span> <span class="number">1</span> #自底向上</span><br><span class="line">        MAX-<span class="constructor">HEAPIFY(A, <span class="params">i</span>)</span></span><br><span class="line"># 时间复杂度：<span class="constructor">O(<span class="params">nlgn</span>)</span>，对一个数组进行原址排序(升序)</span><br><span class="line"><span class="constructor">HEAPSORT(A)</span></span><br><span class="line">    # 利用BUILD-MAX-HEAP将输入数组建成最大堆</span><br><span class="line">    BUILD-MAX-<span class="constructor">HEAP(A)</span> # 最大元素总是在根结点A<span class="literal">[<span class="number">1</span>]</span>中</span><br><span class="line">    <span class="keyword">for</span> i = <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>length <span class="keyword">downto</span> <span class="number">2</span></span><br><span class="line">        exchange A<span class="literal">[<span class="number">1</span>]</span> <span class="keyword">with</span> A<span class="literal">[<span class="identifier">i</span>]</span> # 将最大元素往后放在正确的位置i上</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>heap-size = <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>heap-size - <span class="number">1</span> # 去掉结点n</span><br><span class="line">        MAX-<span class="constructor">HEAPIFY(A, 1)</span> # 维护，以保证去掉结点n后的堆还是最大堆</span><br></pre></td></tr></table></figure> 1. Python实现（升序） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heap_size = <span class="number">0</span></span><br><span class="line">LEFT = <span class="keyword">lambda</span> i: <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">RIGHT = <span class="keyword">lambda</span> i: <span class="number">2</span>*i+<span class="number">2</span> </span><br><span class="line"><span class="comment"># 维护最大堆</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAPIFY</span>(<span class="params">A, i</span>):</span></span><br><span class="line">    l, r = LEFT(i), RIGHT(i)</span><br><span class="line">    largest = l <span class="keyword">if</span> l &lt; heap_size <span class="keyword">and</span> A[l] &gt; A[i] <span class="keyword">else</span> i <span class="comment"># 最小堆则改为 A[l] &lt; A[i]</span></span><br><span class="line">    largest = r <span class="keyword">if</span> r &lt; heap_size <span class="keyword">and</span> A[r] &gt; A[largest] <span class="keyword">else</span> largest <span class="comment"># 最小堆则改为A[r] &lt; A[largest]</span></span><br><span class="line">    <span class="keyword">if</span> i != largest:</span><br><span class="line">        A[i], A[largest] = A[largest], A[i]</span><br><span class="line">        HEAPIFY(A,largest)</span><br><span class="line"><span class="comment"># 构建最大堆</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BUILD_MAX_HEAP</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">global</span> heap_size</span><br><span class="line">    heap_size = <span class="built_in">len</span>(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)//<span class="number">2</span>-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        HEAPIFY(A,i)</span><br><span class="line"><span class="comment"># 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAPSORT</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">global</span> heap_size</span><br><span class="line">    BUILD_MAX_HEAP(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        A[i], A[<span class="number">0</span>] = A[<span class="number">0</span>], A[i]</span><br><span class="line">        heap_size -= <span class="number">1</span></span><br><span class="line">        HEAPIFY(A,<span class="number">0</span>)</span><br></pre></td></tr></table></figure> 注：降序排序仅需修改HEAPIFY中的比较，维护最小堆即可。</p>
<p>附： 维护最大堆时进行的是尾部递归，这是一种比较低效的做法。修改为循环结构如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAPIFY</span>(<span class="params">A, i</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        l, r = LEFT(i), RIGHT(i)</span><br><span class="line">        largest = l <span class="keyword">if</span> l &lt; heap_size <span class="keyword">and</span> A[l] &gt; A[i] <span class="keyword">else</span> i</span><br><span class="line">        largest = r <span class="keyword">if</span> r &lt; heap_size <span class="keyword">and</span> A[r] &gt; A[largest] <span class="keyword">else</span> largest</span><br><span class="line">        <span class="keyword">if</span> i == largest: <span class="keyword">break</span></span><br><span class="line">        A[i], A[largest] = A[largest], A[i]</span><br><span class="line">        i = largest</span><br></pre></td></tr></table></figure> # 图片说明 <img src="http://images.cnitblog.com/blog/644588/201409/191258266122505.jpg" /> ## 复杂度 1. 空间复杂度：O(1), in-place排序 2. 最差/平均/最优时间复杂度：O(nlgn)</p>
<h1 id="注意">注意</h1>
<ol type="1">
<li>维护堆的时候注意，表示左子树和右子树的下标都不能超出堆的大小。</li>
<li>堆排序时，注意调整堆的大小。</li>
</ol>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>九大排序算法及其Python实现之快速排序</title>
    <url>/2015/12/08/%E4%B9%9D%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6Python%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>输入：n个数的一个序列&lt;a1,a2,...,an&gt; (A[1..n]) 输出：输入序列的一个排序&lt;b1,b2,...,bn&gt;，满足b1≤b2≤...≤bn。</p>
<h1 id="思想">思想</h1>
<p>分治法： 1. 分解：数组A[p..r]被划分为两个（可能为空）子数组A[p..q-1]和A[q+1..r]，使得A[p..q-1]中的每一个元素都小于等于A[q]，而A[q]也小于等于A[q+1..r]中的每个元素。其中，计算下标q也是划分过程的一部分(PARTITION(A, p, r)) 2. 解决：通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]进行排序 3. 合并：因为子数组都是原址排序，所以不需要合并操作。即，数组A[p..r]已经有序</p>
<p>参考：<a href="https://zh.wikipedia.org/zh/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">Wiki百科：快速排序</a></p>
<h1 id="实现">实现</h1>
<p>伪代码 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"># 初识调用：<span class="constructor">QUICKSORT(A, 1, A.<span class="params">length</span>)</span></span><br><span class="line"><span class="constructor">QUICKSORT(A, <span class="params">p</span>, <span class="params">r</span>)</span></span><br><span class="line">    <span class="keyword">if</span> p &lt; r</span><br><span class="line">        q = <span class="constructor">PARTITION(A, <span class="params">p</span>, <span class="params">r</span>)</span></span><br><span class="line">        <span class="constructor">QUICKSORT(A, <span class="params">p</span>, <span class="params">q</span>-1)</span></span><br><span class="line">        <span class="constructor">QUICKSORT(A, <span class="params">q</span>+1, <span class="params">r</span>)</span></span><br><span class="line"># 对子数组A<span class="literal">[<span class="identifier">p</span>..<span class="identifier">r</span>]</span>进行原址重排。<span class="constructor">O(<span class="params">n</span>)</span>, n=r-p+<span class="number">1</span></span><br><span class="line"><span class="constructor">PARTITION(A, <span class="params">p</span>, <span class="params">r</span>)</span></span><br><span class="line">    x = A<span class="literal">[<span class="identifier">r</span>]</span> # 选择最后一个元素作为pivot</span><br><span class="line">    i = p - <span class="number">1</span> # i表示比pivot小的值的最大下标，即A<span class="literal">[<span class="identifier">p</span>..<span class="identifier">i</span>]</span>都不大于pivot值</span><br><span class="line">    <span class="keyword">for</span> j = p <span class="keyword">to</span> r-<span class="number">1</span> # 从头开始扫描数组。A<span class="literal">[<span class="identifier">i</span>+<span class="number">1</span>, <span class="identifier">j</span>-<span class="number">1</span>]</span>都大于pivot值</span><br><span class="line">        <span class="keyword">if</span> A<span class="literal">[<span class="identifier">j</span>]</span> &lt;= x # 若当前元素不大于pivot的值，则把其与A<span class="literal">[<span class="identifier">i</span>+<span class="number">1</span>]</span>交换</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            exhange A<span class="literal">[<span class="identifier">i</span>]</span> <span class="keyword">with</span> A<span class="literal">[<span class="identifier">j</span>]</span></span><br><span class="line">    exhange A<span class="literal">[<span class="identifier">i</span>+<span class="number">1</span>]</span> <span class="keyword">with</span> A<span class="literal">[<span class="identifier">r</span>]</span></span><br><span class="line">    return i+<span class="number">1</span></span><br></pre></td></tr></table></figure> 1. Python实现（升序） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARTITION</span>(<span class="params">A, p, r</span>):</span></span><br><span class="line">    x = A[r]</span><br><span class="line">    i = p - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(p,r):</span><br><span class="line">        <span class="keyword">if</span> A[j]&lt;=x: <span class="comment"># 如果将这里修改为A[j] &gt; x，则为降序排列</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            A[i],A[j] = A[j], A[i]</span><br><span class="line">    A[i+<span class="number">1</span>], A[r] = A[r], A[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">QUICKSORT_ASC</span>(<span class="params">A, p, r</span>):</span></span><br><span class="line">    <span class="keyword">if</span> p &lt; r:</span><br><span class="line">        q = PARTITION(A, p, r) <span class="comment"># 此时下标为q的值已经确定了，后面的排序应该排除它</span></span><br><span class="line">        QUICKSORT_ASC(A, p, q-<span class="number">1</span>)</span><br><span class="line">        QUICKSORT_ASC(A, q+<span class="number">1</span>, r)</span><br></pre></td></tr></table></figure> # 图片说明 <img src="/img/201512081202.jpg" /> ## 复杂度 1. 空间复杂度：O(1), in-place排序 2. 最差时间复杂度：O(n^2), 平均/最优时间复杂度：O(nlgn) 最差时间复杂度出现在每次划分都包含了n-1个元素和0个元素；最优时间复杂度出现在每次划分都包含了n/2个元素和n/2个元素</p>
<h1 id="注意">注意</h1>
<ol type="1">
<li>改进：使用随机抽样确定pivot，然后再与最后一个元素交换 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">RANDOMIZED-<span class="constructor">PARTITION(A, <span class="params">p</span>, <span class="params">r</span>)</span></span><br><span class="line">    i = <span class="constructor">RANDOM(<span class="params">p</span>, <span class="params">r</span>)</span></span><br><span class="line">    exchange A<span class="literal">[<span class="identifier">i</span>]</span> <span class="keyword">and</span> A<span class="literal">[<span class="identifier">r</span>]</span></span><br><span class="line">    return <span class="constructor">PARTITION(A, <span class="params">p</span>, <span class="params">r</span>)</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>九月团团圆圆平平淡淡，啃着糕点写代码</title>
    <url>/2016/09/30/%E4%B9%9D%E6%9C%88%E5%9B%A2%E5%9B%A2%E5%9C%86%E5%9C%86%E5%B9%B3%E5%B9%B3%E6%B7%A1%E6%B7%A1%EF%BC%8C%E5%95%83%E7%9D%80%E7%B3%95%E7%82%B9%E5%86%99%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>因为罗胖子的推荐，加之碰巧能拿到实体书，因此这个月有幸看了吴军老师的<a href="https://book.douban.com/subject/26838557/">智能时代</a>。机器学习和数据科学在python weekly总是占有不少的分量。这在侧面也看出了机器学习和数据科学（也可以说是书中提到的智能）在当下确实不容小觑。好吧，我不知道我会不会是书里的那2%，也许有一天时代的发展使得西乔漫画中的那只cat成为可能，那个时候，除了写代码，我还能做什么呢？或许在这之前，把自己的尾巴拖得尽可能长点，会是另一种自救之道？</p>
<p>这个月最大的成就，应该是看完了<a href="https://book.douban.com/subject/26581184/">Docker源码分析</a>这本书了。书写得很浅显，作者考虑到了我这种go零基础的受众，算得上手把手的教你看代码了。我没用过docker，嗯，但是，此书之后，我想docker也不会让我太迷惑了。这本书算是我老老实实从头到尾看完的一本技术书（也许是因为它薄？）。我总是很贪心，mark了一堆想看的书，然而常常看到某处，就看不下去。浮躁也好，那时的状态不对也罢。这种问题，是我看书，特别是技术书，需要克服的最大的障碍了。</p>
<p>最近翻pw总是很任性。有时候一句话，英文的意思我懂，但是转成中文却觉得甚是别扭。有时，我都觉得自己没法好好讲话了。之前求的是尽量保存作者的原字原意，因为好些领域其实我也不懂，故而担心弄错了误人子弟那么多不好。现在任性了。看到一句老长老长的话，用中文逐字逐句打不出来，那么久闭上眼睛，想想怎么意译。意达为主，尽量字达。</p>
<p>想想自新工作以来，看的东西不少，但都是浅浅而过，会用（copy and paste from StackOverflow），顶多算得上知道，连熟悉都够不上。也就是说，技能树开得不少，但大多是到此一游。这在出问题的时候，就看出其局限性了（不过感觉这是个悖论，如果没有出问题这个机缘，又怎么让你有动力更进一步呢？）。所以要说到这个月我工作的重点之一，就是各种优化~ 抓包、debug之类的个中滋味不提也罢。再算算今年也快完了，因此觉得自己应该收收心。那么，收心从温故而知新开始吧，温故的话，那就看源码好啦O(∩_∩)O~</p>
<p>于是乎，有了下面的十月计划~</p>
<ul>
<li>GO （跟同事要了<a href="https://book.douban.com/subject/11577300/">Go语言编程</a>）</li>
<li>uwsgi源码阅读</li>
<li>准备做几个小东西
<ol type="1">
<li>今年生日的时候，朋友送了我一个香蕉派的camera module。一直放着不知道该用来做什么。最近短期记忆有点问题，时常出门了会突然想到自己家的门有没有锁（我觉得我一定不是一个人！！），所以，嗯……</li>
<li>Android教程看不下去了（除了因为手机没法做测试机以及电脑问题，真的不是因为懒癌犯了吗？！！），所以觉得应该开始做个小app来激发下我的热情（不过听说微信上了个小程序……anyway~）</li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>这就是生活</category>
      </categories>
      <tags>
        <tag>Ele在思考</tag>
      </tags>
  </entry>
  <entry>
    <title>五月不定阴晴暴雨时时至，不如静坐写代码</title>
    <url>/2016/05/22/%E4%BA%94%E6%9C%88%E4%B8%8D%E5%AE%9A%E9%98%B4%E6%99%B4%E6%9A%B4%E9%9B%A8%E6%97%B6%E6%97%B6%E8%87%B3%EF%BC%8C%E4%B8%8D%E5%A6%82%E9%9D%99%E5%9D%90%E5%86%99%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>前两天写了篇文，发的时候一看，离上一篇文章的创建时间竟有两个多月之远。</p>
<p>虽说当初写点什么，有为了找工作的意味在里头。但是在记录所思所想所学的那些个日子里，确实也感受到了回归记录整理的重要性。因此，是不能用着工作忙的借口就此荒废偷懒。特别是过去的两个月中，自己面对着一大堆的新东西要学，这种情况下，做整理总结，再是重要不过了。</p>
<p>因此，先把这两天思考过后的决定放在这里，再继续说说其他事：决定呢，也就是自己每月都要写一篇这样的总结，关于本月的思考，关于对下个月的期望，也可以是碎碎叨叨之类的。</p>
<p>有字为证，不准反悔哦~</p>
<p>打开<a href="http://ictar.github.io/2016/03/01/2016%E5%B9%B4%E7%82%B9%E4%BA%AE%E6%8A%80%E8%83%BD%E6%A0%91%E7%9A%84%E6%9F%90%E4%B8%AA%E6%9E%9D%E6%A1%A0/">2016年点亮技能树的某个枝桠</a>看了看，想看看过去快三个月了，2016年也过去近5个月了，我对自己的期许究竟完成了多少。</p>
<p>首先是把Python带到工作中。嗯，找了一份Python开发的工作，算是真的在感受它如何用于现实。所以这一项，算是完成了吧。而Python进阶呢，则是进度缓慢，更可以说是止步不前。大抵有新工作的因素在里头，要了解各种数据库，了解工作中用到的软件、框架等等等等。虽说因此占据了我绝大的时间，但是也算是今年计划外的收获吧。</p>
<p>接着呢，是翻译。订了python weekly。某天突发奇想，想把每周短短的python weekly也给翻一下，也算是回报社会吧。虽然近来精力不足，而翻译这种事又是一种劳心费力的活，因此翻译的速度也越来越慢。常常每周决定好要翻的pycoder weekly上的文，保存下来，却没法及时的完成翻译。把自己折腾的有点累。另外，近来较为关注的便是数据分析的那一块，因此也翻了不少。接下来，python weekly当然是要继续的，但是可能会较之从前少翻一点数据分析的内容。其实，我倒是挺想多看点物联网硬件之类的文章的。</p>
<p>至于android和安全，估计要放在下半年了。那个时候，工作的事情估计也比较从容，才能开始新的主线任务呀。</p>
<p>不过对于shell，倒是慢慢的在上手中。因工作所需，编程环境真的就搬到了Linux下。也开始学着用vim敲代码，慢慢的发现了vim其实真特么的好用，只是为了让它更好用，快捷键神马的，还是要更加熟练才行。哦，对了，某天看了看awk，算是对其入了门吧。好吧，新学的东西，好多都是只知其皮毛，远没达到熟练的程度。只是更加感受到了，语言其实就是工具，而我需要学习的，是如何最恰当的使用工具。就比如说，虽然Python很可爱，但是如果我只是想看看目录下大小非零的文件有哪些，awk就很有用啦~</p>
<p>看，learning by doing，真是非常非常的有道理呀！</p>
<p>五月份差不多就要在这随机不定的暴雨中结束了。是哒，真是阴晴不定暴雨时时会至呀，但是在这暴雨声中敲敲代码，却有一种别样的舒适。</p>
<p>好了，提前说说六月份的打算吧。</p>
<ul>
<li><p>六月份要把Eva的个人网站加上xadmin (这也是最近玩得最多的package呀！！！)，修整一下，差不多可以给它买个域名买个空间了。</p></li>
<li><p>前段时间看到某个博客上有个menu叫做"exchange"，是博主用来挂他看过的书并且希望换书的。我觉得这种想法相当的好！可惜当时没收藏，已经找不到是哪位的了。但是，Ele计划借鉴一下，也在自己的博客新增一个menu，放自己看过的书并且希望有人可以跟我换书看。</p></li>
<li><p>如果有时间的话，看看nginx。</p></li>
</ul>
]]></content>
      <categories>
        <category>这就是生活</category>
      </categories>
      <tags>
        <tag>Ele在思考</tag>
      </tags>
  </entry>
  <entry>
    <title>九大排序算法及其Python实现之简单排序</title>
    <url>/2015/12/01/%E4%B9%9D%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6Python%E5%AE%9E%E7%8E%B0%E4%B9%8B%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>输入：n个数的一个序列&lt;a1,a2,...,an&gt; (A[1..n]) 输出：输入序列的一个排序&lt;b1,b2,...,bn&gt;，满足b1≤b2≤...≤bn。</p>
<h1 id="插入排序">插入排序</h1>
<h2 id="思想">思想</h2>
<p>扫描数组，每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。 参考：<a href="https://zh.wikipedia.org/zh/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">Wiki百科：插入排序</a></p>
<h2 id="实现">实现</h2>
<p>伪代码 <figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">INSERTION-SORT(<span class="keyword">A</span>) </span><br><span class="line">    for j = <span class="number">2</span> to <span class="keyword">A</span>.length</span><br><span class="line">        key = <span class="keyword">A</span>[j]</span><br><span class="line">        //将<span class="keyword">A</span>[j]插入到已排序序列<span class="keyword">A</span>[<span class="number">1</span>..j-<span class="number">1</span>]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        while i &gt; <span class="number">0</span> and <span class="keyword">A</span>[i] &gt; key</span><br><span class="line">            <span class="keyword">A</span>[i+<span class="number">1</span>] = <span class="keyword">A</span>[i]</span><br><span class="line">            i = i -<span class="number">1</span></span><br><span class="line">        <span class="keyword">A</span>[i+<span class="number">1</span>] = key</span><br></pre></td></tr></table></figure> 1. Python实现（升序） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">INSERTION_SORT_ASC</span>(<span class="params">A</span>):</span></span><br><span class="line">    n= <span class="built_in">len</span>(A) <span class="comment">#A的长度</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n): <span class="comment"># 从第二个元素开始，遍历数组</span></span><br><span class="line">        key, i = A[j], j <span class="comment"># 保存当前元素的值key</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> A[i-<span class="number">1</span>]&gt;key: <span class="comment">#当前元素前面的序列是已经排序好的数组</span></span><br><span class="line">            A[i] = A[i-<span class="number">1</span>] <span class="comment"># 将较大的数后移</span></span><br><span class="line">            i -=<span class="number">1</span> <span class="comment"># 继续往前找</span></span><br><span class="line">        A[i] = key <span class="comment"># i为当前元素的插入位置</span></span><br></pre></td></tr></table></figure> 2. Python实现（降序） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">INSERTION_SORT_DESC</span>(<span class="params">A</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(A)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">        key, i = A[j], j</span><br><span class="line">        <span class="keyword">while</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> A[i-<span class="number">1</span>]&lt;key:</span><br><span class="line">            A[i] = A[i-<span class="number">1</span>]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        A[i] = key</span><br></pre></td></tr></table></figure> ## 图片说明 <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0f/Insertion-sort-example-300px.gif/220px-Insertion-sort-example-300px.gif" /> ## 复杂度 1. 空间复杂度：O(1), in-place排序 2. 时间复杂度：O(n^2)</p>
<h2 id="注意">注意</h2>
<ol type="1">
<li>只要循环到一个小于或等于key值的数就说明找到key值的位置了。此时需要结束循环</li>
<li>用key值去比较，而不是用相邻的两个值做比较</li>
<li>当n很小的时候效率较高，当n很大的时候，不适用</li>
<li>一种稳定的算法</li>
</ol>
<table style="width:6%;">
<colgroup>
<col style="width: 5%" />
</colgroup>
<tbody>
<tr class="odd">
<td># 选择排序 ## 思想 为每个位置选择当前元素最小的。即，首先找出A中的最小元素并将其与A[0]中的元素进行交换。接着，找出A中次最小元素并将其与A[1]中的元素进行交换。对A中前n-1个元素按该方式继续。 参考：<a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">Wiki百科：选择排序</a></td>
</tr>
<tr class="even">
<td>## 实现 伪代码： <figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">SELECTION_SORT(A)</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> <span class="built_in">to</span> A.<span class="built_in">length</span><span class="number">-1</span></span><br><span class="line">        <span class="built_in">min</span> = i</span><br><span class="line">        <span class="keyword">for</span> j=i+<span class="number">1</span> <span class="built_in">to</span> A.<span class="built_in">length</span><span class="comment"> //找出当前位置最小的</span></span><br><span class="line">            <span class="keyword">if</span> A[j] &lt; A[<span class="built_in">min</span>]</span><br><span class="line">                <span class="built_in">min</span> = j</span><br><span class="line">        exchange A[i] <span class="keyword">with</span> A[<span class="built_in">min</span>]</span><br></pre></td></tr></table></figure> 1. Python实现（升序） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SELECTION_SORT_ASC</span>(<span class="params">A</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n-<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">min</span> = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n): <span class="comment">#找出当前位置最小的</span></span><br><span class="line">            <span class="keyword">if</span> A[j]&lt;A[<span class="built_in">min</span>]: <span class="built_in">min</span>=j</span><br><span class="line">        <span class="keyword">if</span> i!=<span class="built_in">min</span>: A[i],A[<span class="built_in">min</span>] = A[<span class="built_in">min</span>],A[i]</span><br></pre></td></tr></table></figure> 2. Python实现（降序） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SELECTION_SORT_DESC</span>(<span class="params">A</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n-<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">max</span> = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n): <span class="comment">#找出当前位置最大的</span></span><br><span class="line">            <span class="keyword">if</span> A[j]&gt;A[<span class="built_in">max</span>]: <span class="built_in">max</span>=j</span><br><span class="line">        <span class="keyword">if</span> i!=<span class="built_in">max</span>: A[i],A[<span class="built_in">max</span>] = A[<span class="built_in">max</span>],A[i]</span><br></pre></td></tr></table></figure> ## 图片说明 <img src="http://images.cnitblog.com/i/497634/201403/130003333397123.jpg" /> ## 复杂度 1. 空间复杂度：O(1), in-place排序 2. 时间复杂度：O(n^2)</td>
</tr>
<tr class="odd">
<td>## 注意 1. 记录最小/大那个元素的下标，而不是值。 2. 相同元素的前后顺序可能改变，因此是不稳定的排序算法</td>
</tr>
</tbody>
</table>
<h1 id="冒泡排序">冒泡排序</h1>
<h2 id="思想-1">思想</h2>
<p>反复交换相邻的未按次序排列的元素。即把小的元素往前调，或者把大的元素往后调 参考：<a href="https://zh.wikipedia.org/zh/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">Wiki百科：冒泡排序</a> ## 实现 伪代码： <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">BUBBLESORT(A)</span></span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span> <span class="keyword">to</span> <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>length-<span class="number">1</span> <span class="comment">//从前往后扫描数组</span></span><br><span class="line">        <span class="keyword">for</span> j=<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>length <span class="keyword">downto</span> i+<span class="number">1</span> <span class="comment">//从后开始，不断把小的元素往前推</span></span><br><span class="line">            <span class="keyword">if</span> A<span class="literal">[<span class="identifier">j</span>]</span> &lt; A<span class="literal">[<span class="identifier">j</span>-<span class="number">1</span>]</span></span><br><span class="line">                exchange A<span class="literal">[<span class="identifier">j</span>]</span> <span class="keyword">with</span> A<span class="literal">[<span class="identifier">j</span>-<span class="number">1</span>]</span></span><br></pre></td></tr></table></figure> 1. Python实现（升序） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BUBBLE_SORT_ASC</span>(<span class="params">A</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n)[::-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> A[j] &lt; A[j-<span class="number">1</span>]: A[j], A[j-<span class="number">1</span>] = A[j-<span class="number">1</span>], A[j]</span><br></pre></td></tr></table></figure> 2. Python实现（降序） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BUBBLE_SORT_DESC</span>(<span class="params">A</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n)[::-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> A[j] &gt; A[j-<span class="number">1</span>]: A[j], A[j-<span class="number">1</span>] = A[j-<span class="number">1</span>], A[j]</span><br></pre></td></tr></table></figure> ## 图片说明 <img src="http://img.blog.csdn.net/20130609182235937" /> ## 复杂度 1. 空间复杂度：O(1), in-place排序 2. 最差/平均/最优时间复杂度：O(n^2) ## 注意 1. 相同元素的前后顺序不会改变，因此是一种稳定的排序算法。 2. 低效的简单排序算法</p>
<hr />
<h1 id="归并排序">归并排序</h1>
<h2 id="思想分而治之">思想：分而治之</h2>
<ol type="1">
<li>分解：分解待排序的n个元素的序列成各具n/2个元素的两个子序列</li>
<li>解决：使用归并排序递归地排序两个子序列</li>
<li>合并(MERGE)：合并两个已排序的子序列以产生已排序的答案 参考：<a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">Wiki百科：归并排序</a></li>
</ol>
<h2 id="实现-1">实现</h2>
<p>伪代码： <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并操作</span></span><br><span class="line"><span class="comment">// p, q, r是数组的下标，满足p≤q&lt;r</span></span><br><span class="line"><span class="comment">// 假设子序列A[p..q]和A[q+1..r]已排好序</span></span><br><span class="line"><span class="comment">// 此过程合并这两个子数组形成单一的已排好序的子数组并代替当前的子数组A[p..r]</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n), n=r-p+1</span></span><br><span class="line"><span class="comment">// 哨兵的设置：避免检查堆为空，只需要执行r-p+1个基本步骤，算法就可以停止</span></span><br><span class="line"><span class="constructor">MERGE(A, <span class="params">p</span>, <span class="params">q</span>, <span class="params">r</span>)</span></span><br><span class="line">    n1 = q - p + <span class="number">1</span> <span class="comment">//A[p..q]的元素个数</span></span><br><span class="line">    n2 = r - q <span class="comment">//A[q+1..r]的元素个数</span></span><br><span class="line">    <span class="keyword">let</span> L<span class="literal">[<span class="number">1.</span>.<span class="identifier">n1</span>+<span class="number">1</span>]</span> <span class="keyword">and</span> R<span class="literal">[<span class="number">1.</span>.<span class="identifier">n2</span>+<span class="number">1</span>]</span> be <span class="keyword">new</span> arrays</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span> <span class="keyword">to</span> n1</span><br><span class="line">        L<span class="literal">[<span class="identifier">i</span>]</span> = A<span class="literal">[<span class="identifier">p</span>+<span class="identifier">i</span>-<span class="number">1</span>]</span></span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span> <span class="keyword">to</span> n2</span><br><span class="line">        R<span class="literal">[<span class="identifier">j</span>]</span> = A<span class="literal">[<span class="identifier">q</span>+<span class="identifier">j</span>]</span></span><br><span class="line">    L<span class="literal">[<span class="identifier">n1</span>+<span class="number">1</span>]</span> = ∞ <span class="comment">//哨兵</span></span><br><span class="line">    R<span class="literal">[<span class="identifier">n2</span>+<span class="number">1</span>]</span> = ∞</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k=p <span class="keyword">to</span> r</span><br><span class="line">        <span class="keyword">if</span> L<span class="literal">[<span class="identifier">i</span>]</span> ≤ R<span class="literal">[<span class="identifier">j</span>]</span></span><br><span class="line">            A<span class="literal">[<span class="identifier">k</span>]</span> = L<span class="literal">[<span class="identifier">i</span>]</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> A<span class="literal">[<span class="identifier">k</span>]</span> = R<span class="literal">[<span class="identifier">j</span>]</span></span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line"><span class="comment">// 排序子数组A[p..r]</span></span><br><span class="line"><span class="comment">// 初始调用：MERGE_SORT(A, 1, A.length)</span></span><br><span class="line"><span class="constructor">MERGE_SORT(A, <span class="params">p</span>, <span class="params">r</span>)</span>:</span><br><span class="line">    <span class="keyword">if</span> p &lt; r: <span class="comment">//若p≥r，则该数组最多有一个元素，所以已经排好序</span></span><br><span class="line">        q = (p+r)/<span class="number">2</span> <span class="comment">//这里表示整除，分解</span></span><br><span class="line">        <span class="constructor">MERGE_SORT(A, <span class="params">p</span>, <span class="params">q</span>)</span> <span class="comment">// 左子数组排序</span></span><br><span class="line">        <span class="constructor">MERGE_SORT(A, <span class="params">q</span>+1, <span class="params">r</span>)</span> <span class="comment">// 右子数组排序</span></span><br><span class="line">        <span class="constructor">MERGE(A, <span class="params">p</span>, <span class="params">q</span>, <span class="params">r</span>)</span> <span class="comment">//合并</span></span><br></pre></td></tr></table></figure> 1. Python实现 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 升序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MERGE</span>(<span class="params">A, p, q, r</span>):</span></span><br><span class="line">    L,R = A[p:q+<span class="number">1</span>],A[q+<span class="number">1</span>:r+<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 增加哨兵值，float(&#x27;inf&#x27;)在Python中表示无穷大</span></span><br><span class="line">    L.append(<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)) <span class="comment"># 若降序，则需要修改为L.append(float(&#x27;-inf&#x27;))</span></span><br><span class="line">    R.append(<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)) <span class="comment"># 同上</span></span><br><span class="line">    i, j, k = <span class="number">0</span>, <span class="number">0</span>, p</span><br><span class="line">    <span class="keyword">while</span> k &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> L[i] &lt; R[j]: <span class="comment"># 若降序，则需要修改成L[i] &gt; R[j]</span></span><br><span class="line">            A[k] = L[i]</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A[k] = R[j]</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        k+=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MERGE_SORT</span>(<span class="params">A, p, r</span>):</span></span><br><span class="line">    <span class="keyword">if</span> p &lt; r:</span><br><span class="line">        q = (p+r)//<span class="number">2</span></span><br><span class="line">        MERGE_SORT(A,p,q)</span><br><span class="line">        MERGE_SORT(A,q+<span class="number">1</span>,r)</span><br><span class="line">        MERGE(A,p,q,r)</span><br></pre></td></tr></table></figure> ## 图片说明 <img src="http://img.my.csdn.net/uploads/201301/26/1359204305_2056.png" /> ## 复杂度 1. 最差/平均时间复杂度：O(nlogn)；最优时间复杂度：O(n) 2. 最差空间复杂度：O(n)</p>
<h2 id="注意-1">注意</h2>
<ol type="1">
<li>归并的时候，计算出来的n1, n2是真实的L数组和R数组的长度。如果使用哨兵，申请L数组和R数组的时候，需要给哨兵申请一个位置，也就是说，需要申请的长度比实际上多1，即n1+1, n2+1</li>
<li>归并的时候，将左右数组的元素放到目标（也是源）数组排序后的位置时，循环用目标数组的位置作为继续条件。也就是说，只要目标数组的位置占满了，就可以退出比较循环。</li>
<li>归并的时候，若不使用哨兵，注意主循环结束的条件是，左数组、右数组或者目标数组有一个到达了数组的最后一个元素。</li>
<li>这种排序方法比较占用内存，却是一种效率高且稳定的算法</li>
</ol>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>九大排序算法及其Python实现之线性排序</title>
    <url>/2015/12/01/%E4%B9%9D%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6Python%E5%AE%9E%E7%8E%B0%E4%B9%8B%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>输入：n个数的一个序列&lt;a1,a2,...,an&gt; (A[1..n]) 输出：输入序列的一个排序&lt;b1,b2,...,bn&gt;，满足b1≤b2≤...≤bn。</p>
<h1 id="计数排序">计数排序</h1>
<h2 id="思想">思想</h2>
<p>假设n个输入元素中的每一个都是在0到k区间内的一个整数，其中k为某个整数。 对每一个输入元素x，确定小于x的元素个数，利用这一信息，就可以直接把x放到它在输出数组中的位置上了。 &gt;注:当有几个元素相同时，要略微修改此方案。</p>
<p>参考：<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">Wiki百科：计数排序</a> ## 实现 伪代码： <figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"># B<span class="comment">[1..n]</span> 存放排序的输出</span><br><span class="line"># C<span class="comment">[0..k]</span> 提供临时存储空间</span><br><span class="line">COUNTING-SORT(A, B, k)</span><br><span class="line">    let C<span class="comment">[0..k]</span> be a new array</span><br><span class="line">    for i = 0 to k # 将数组C的值置为0</span><br><span class="line">        C<span class="comment">[i]</span> = 0</span><br><span class="line">    for j = 1 to A.length</span><br><span class="line">        C<span class="comment">[A<span class="comment">[j]</span>]</span> = C<span class="comment">[A<span class="comment">[j]</span>]</span> + 1</span><br><span class="line">    # C<span class="comment">[i]</span>现在包含值为i的元素的个数</span><br><span class="line">    for i = 1 to k</span><br><span class="line">        C<span class="comment">[i]</span> = C<span class="comment">[i]</span> + C<span class="comment">[i-1]</span></span><br><span class="line">    # C<span class="comment">[i]</span>现在包含值不大于i的元素的个数</span><br><span class="line">    # 从后往前遍历原数组以排序是保证排序算法稳定性的关键</span><br><span class="line">    for j = A.length downto 1 </span><br><span class="line">        B<span class="comment">[C<span class="comment">[A<span class="comment">[j]</span>]</span>]</span> = A<span class="comment">[j]</span></span><br><span class="line">        C<span class="comment">[A<span class="comment">[j]</span>]</span> = C<span class="comment">[A<span class="comment">[j]</span>]</span> - 1</span><br></pre></td></tr></table></figure> 1. Python实现（升序） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">COUNTING_SORT_ASC</span>(<span class="params">A, B, k</span>):</span></span><br><span class="line">    C = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,k+<span class="number">1</span>)] <span class="comment"># 初始化C</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(A)): <span class="comment"># 计数</span></span><br><span class="line">        C[A[i]] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">        C[i] = C[i]+C[i-<span class="number">1</span>] <span class="comment"># 计算最大位置</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>): <span class="comment"># 把元素放在正确的位置上</span></span><br><span class="line">        B[C[A[i]]-<span class="number">1</span>] = A[i]</span><br><span class="line">        C[A[i]] -= <span class="number">1</span></span><br></pre></td></tr></table></figure> 2. Python实现（降序） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">COUNTING_SORT_DESC</span>(<span class="params">A, B, k</span>):</span></span><br><span class="line">    C = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,k+<span class="number">1</span>)] <span class="comment"># 初始化C</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(A)): <span class="comment"># 计数</span></span><br><span class="line">        C[A[i]] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>): <span class="comment"># 此处是与升序最大的不同</span></span><br><span class="line">        C[i] = C[i]+C[i+<span class="number">1</span>] <span class="comment"># 计算最大位置</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        B[C[A[i]]-<span class="number">1</span>] = A[i]</span><br><span class="line">        C[A[i]] -= <span class="number">1</span></span><br></pre></td></tr></table></figure> ## 图片说明 <img src="http://img.blog.csdn.net/20130730163013171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGVuZ3dlaXR3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" /> ## 复杂度 1. 空间复杂度：O(k+n) 2. 最差/平均/最优时间复杂度：O(k+n)</p>
<h2 id="注意">注意</h2>
<ol type="1">
<li>稳定的线性时间排序</li>
<li>常用作基数排序算法的一个子过程</li>
<li>由于下标是从0开始的，因此在实际实现过程中，最后的排序步骤需要把下标减一</li>
</ol>
<h1 id="基数排序">基数排序</h1>
<h2 id="思想-1">思想</h2>
<p>先按最低有效位进行排序。</p>
<p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<p>参考：<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">Wiki百科：基数排序</a></p>
<h2 id="实现">实现</h2>
<p>伪代码： <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"># 第<span class="number">1</span>位是最低位，第d位师最高位</span><br><span class="line">RADIX-<span class="constructor">SORT(A, <span class="params">d</span>)</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> d</span><br><span class="line">        use a stable sort <span class="keyword">to</span> sort <span class="built_in">array</span> A on digit i</span><br><span class="line"># 常用计数排序来对A中元素的i位进行排序。算法修改如下</span><br><span class="line"># k为单位数字最大值</span><br><span class="line">RADIX-<span class="constructor">SORT(A, <span class="params">d</span>, <span class="params">k</span>)</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> d</span><br><span class="line">        COUNTING-<span class="constructor">SORT(A, <span class="params">i</span>, <span class="params">k</span>)</span></span><br><span class="line">COUNTING-<span class="constructor">SORT(A, <span class="params">h</span>, <span class="params">k</span>)</span></span><br><span class="line">    <span class="keyword">let</span> C<span class="literal">[<span class="number">0.</span>.<span class="identifier">k</span>]</span> be a <span class="keyword">new</span> <span class="built_in">array</span></span><br><span class="line">    <span class="keyword">let</span> B<span class="literal">[<span class="number">1.</span>.<span class="identifier">n</span>]</span> be a <span class="keyword">new</span> <span class="built_in">array</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> <span class="keyword">to</span> k #初始化C</span><br><span class="line">        C<span class="literal">[<span class="identifier">i</span>]</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span> <span class="keyword">to</span> <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>length # 计算A<span class="literal">[<span class="identifier">j</span>]</span>出现的次数，将结果保存在C<span class="literal">[A[<span class="identifier">j</span>]</span>]中</span><br><span class="line">        ivalue = (A<span class="literal">[<span class="identifier">j</span>]</span>%(<span class="number">10</span>^h))/(<span class="number">10</span>^(h-<span class="number">1</span>)) # 计算A<span class="literal">[<span class="identifier">j</span>]</span>第h位的值</span><br><span class="line">        C<span class="literal">[<span class="identifier">ivalue</span>]</span> = C<span class="literal">[<span class="identifier">ivalue</span>]</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> k # C<span class="literal">[<span class="identifier">i</span>]</span>包含小于或等于i的元素个数</span><br><span class="line">        C<span class="literal">[<span class="identifier">i</span>]</span> = C<span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span></span><br><span class="line">    <span class="keyword">for</span> j = <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>length <span class="keyword">downto</span> <span class="number">1</span></span><br><span class="line">        ivalue = (A<span class="literal">[<span class="identifier">j</span>]</span>%(<span class="number">10</span>^h))/(<span class="number">10</span>^(h-<span class="number">1</span>)) # 计算A<span class="literal">[<span class="identifier">j</span>]</span>第h位的值</span><br><span class="line">        B<span class="literal">[C[<span class="identifier">ivalue</span>]</span>] = A<span class="literal">[<span class="identifier">j</span>]</span></span><br><span class="line">        C<span class="literal">[<span class="identifier">ivalue</span>]</span> = C<span class="literal">[<span class="identifier">ivalue</span>]</span> - <span class="number">1</span></span><br><span class="line">    copy B <span class="keyword">to</span> A</span><br></pre></td></tr></table></figure> 1. Python实现（升序） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RADIX_SORT_ASC</span>(<span class="params">A, d, k</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,d+<span class="number">1</span>):</span><br><span class="line">        COUNTING_SORT_ASC(A,i,k)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">COUNTING_SORT_ASC</span>(<span class="params">A,h,k</span>):</span></span><br><span class="line">    B = A[:]</span><br><span class="line">    C = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,k+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(A)):</span><br><span class="line">        ivalue = (A[j]%(<span class="number">10</span>**h))/(<span class="number">10</span>**(h-<span class="number">1</span>)) <span class="comment">#此处可以用lambda写个匿名函数</span></span><br><span class="line">        C[ivalue] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k+<span class="number">1</span>): C[i] += C[i-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        ivalue = (A[j]%(<span class="number">10</span>**h))/(<span class="number">10</span>**(h-<span class="number">1</span>))</span><br><span class="line">        B[C[ivalue]-<span class="number">1</span>] = A[j] <span class="comment">#下标从0开始，因此需要-1，否则会下标越界</span></span><br><span class="line">        C[ivalue] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(A)): A[j] = B[j]</span><br></pre></td></tr></table></figure> 2. Python实现（降序） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RADIX_SORT_DESC</span>(<span class="params">A, d, k</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,d+<span class="number">1</span>):</span><br><span class="line">        COUNTING_SORT_DESC(A,i,k)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">COUNTING_SORT_DESC</span>(<span class="params">A,h,k</span>):</span></span><br><span class="line">    B = A[:]</span><br><span class="line">    C = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,k+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(A)):</span><br><span class="line">        ivalue = (A[j]%(<span class="number">10</span>**h))/(<span class="number">10</span>**(h-<span class="number">1</span>))</span><br><span class="line">        C[ivalue] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>): C[i] += C[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        ivalue = (A[j]%(<span class="number">10</span>**h))/(<span class="number">10</span>**(h-<span class="number">1</span>))</span><br><span class="line">        B[C[ivalue]-<span class="number">1</span>] = A[j] <span class="comment">#下标从0开始，因此需要-1，否则会下标越界</span></span><br><span class="line">        C[ivalue] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(A)): A[j] = B[j]</span><br></pre></td></tr></table></figure> ## 图片说明 <img src="http://images.cnitblog.com/blog/92063/201401/231957299298.jpg" /> ## 复杂度 1. 空间复杂度：O(k+n) , n是排序元素个数，k是单位数字最大值 2. 空间复杂度：O(d*n), n是排序元素个数，d是数字位数</p>
<h2 id="注意-1">注意</h2>
<ol type="1">
<li>此算法还可以用于字符串排序</li>
</ol>
<h1 id="桶排序">桶排序</h1>
<h2 id="思想-2">思想</h2>
<p>假设输入是由一个随机过程产生，该过程将元素均与、独立地分布在[0,m)区间上</p>
<ol type="1">
<li>将[0,m)区间划分为BUCKET_NUM个相同大小的子区间（桶）</li>
<li>将n个输入数分别放到各个桶中</li>
<li>对每个桶中的数进行排序</li>
<li>遍历每个桶，按照次序把各个桶中的元素列出即可</li>
</ol>
<p>参考：<a href="https://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F">Wiki百科：基数排序</a></p>
<h2 id="实现-1">实现</h2>
<p>伪代码： <figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入的每个元素A[i]满足0≤A[i]x&lt;1</span></span><br><span class="line"><span class="comment"># 临时数组B[0..BUCKET_NUM-1]存放链表（桶）</span></span><br><span class="line"><span class="keyword">BUCKET-SORT(A)</span></span><br><span class="line"><span class="keyword"> </span>   let <span class="keyword">B[0..BUCKET_NUM-1] </span><span class="keyword">be </span>a new array</span><br><span class="line">    for i = <span class="number">0</span> to <span class="keyword">BUCKET_NUM-1</span></span><br><span class="line"><span class="keyword"> </span>       make <span class="keyword">B[i] </span>an empty list</span><br><span class="line">    for i = <span class="number">1</span> to A.length <span class="comment"># 将输入数放到各个桶中</span></span><br><span class="line">        <span class="keyword">insert </span>A[i] into list <span class="keyword">B[int(BUCKET_NUM*A[i])]</span></span><br><span class="line"><span class="keyword"> </span>   for i = <span class="number">0</span> to <span class="keyword">BUCKET_NUM-1 </span><span class="comment"># 对每个桶进行排序</span></span><br><span class="line">        sort list <span class="keyword">B[i] </span>with <span class="keyword">insertion </span>sort</span><br><span class="line">    concatenate the lists <span class="keyword">B[0], </span><span class="keyword">B[1], </span>..., <span class="keyword">B[BUCKET_NUM-1] </span>together in <span class="keyword">order</span></span><br></pre></td></tr></table></figure> 1. Python实现（升序） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BUCKET_NUM = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BUCKET_SORT_ASC</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">global</span> BUCKET_NUM</span><br><span class="line">    B = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,BUCKET_NUM)] <span class="comment"># 创建BUCKET_NUM个空桶</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(A)): <span class="comment"># 将元素放到各自的桶中</span></span><br><span class="line">        B[<span class="built_in">int</span>(BUCKET_NUM*A[i])].append(A[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,BUCKET_NUM):<span class="comment"># 对桶中的数据进行排序</span></span><br><span class="line">        <span class="comment">#INSERTION_SORT_ASC(B[i])</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(B[i])):</span><br><span class="line">            key,q = B[i][p],p-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> q&gt;=<span class="number">0</span> <span class="keyword">and</span> B[i][q] &gt; key:</span><br><span class="line">                B[i][q+<span class="number">1</span>] = B[i][q]</span><br><span class="line">                q -=<span class="number">1</span></span><br><span class="line">            B[i][q+<span class="number">1</span>] = key</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> a,b:a+b,B) <span class="comment">#将桶里的数据连接在一起</span></span><br></pre></td></tr></table></figure> 2. Python实现（降序） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BUCKET_SORT_DESC</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">global</span> BUCKET_NUM</span><br><span class="line">    B = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,BUCKET_NUM)] <span class="comment"># 创建BUCKET_NUM个空桶</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(A)): <span class="comment"># 将元素放到各自的桶中</span></span><br><span class="line">        B[<span class="built_in">int</span>(BUCKET_NUM*A[i])].append(A[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,BUCKET_NUM):<span class="comment"># 对桶中的数据进行排序(降序)</span></span><br><span class="line">        <span class="comment">#INSERTION_SORT_DESC(B[i])</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(B[i])):</span><br><span class="line">            key,q = B[i][p],p-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> q&gt;=<span class="number">0</span> <span class="keyword">and</span> B[i][q]&lt;key:</span><br><span class="line">                B[i][q+<span class="number">1</span>] = B[i][q]</span><br><span class="line">                q -= <span class="number">1</span></span><br><span class="line">            B[i][q+<span class="number">1</span>] = key</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> a,b:a+b,B[::-<span class="number">1</span>]) <span class="comment">#将桶里的数据连接在一起（从后往前）</span></span><br></pre></td></tr></table></figure> ## 图片说明 <img src="http://img.my.csdn.net/uploads/201207/04/1341415051_4014.jpg" /> ## 复杂度 1. 空间复杂度：O(n*k) 2. 最差时间复杂度：O(n^2), 平均时间复杂度：O(n+k)</p>
<h2 id="注意-2">注意</h2>
<p>无</p>
<h1 id="总结">总结</h1>
<p>稳定性(来自wiki)：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。</p>
<table>
<thead>
<tr class="header">
<th>名称</th>
<th style="text-align: right;">稳定性</th>
<th style="text-align: right;">时间复杂度</th>
<th style="text-align: right;">空间复杂度</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>插入排序</td>
<td style="text-align: right;">Y</td>
<td style="text-align: right;"><span class="math display">\[O(n^2)\]</span></td>
<td style="text-align: right;"><span class="math display">\[O(1)\]</span></td>
<td style="text-align: center;">（有序区，无序区）从头到尾扫描数据，把无序区第一个数据插入到有序区</td>
</tr>
<tr class="even">
<td>选择排序</td>
<td style="text-align: right;">N</td>
<td style="text-align: right;"><span class="math display">\[O(n^2)\]</span></td>
<td style="text-align: right;"><span class="math display">\[O(1)\]</span></td>
<td style="text-align: center;">（有序区，无序区）从头到尾扫描数据，把无序区最小的数据插入到有序区后面</td>
</tr>
<tr class="odd">
<td>冒泡排序</td>
<td style="text-align: right;">Y</td>
<td style="text-align: right;"><span class="math display">\[O(n^2)\]</span></td>
<td style="text-align: right;"><span class="math display">\[O(1)\]</span></td>
<td style="text-align: center;">（有序区，无序区）从头到尾扫描数据，无序区中从后开始扫描，不断把小的元素往前推至（通过交换）有序区后面</td>
</tr>
<tr class="even">
<td>归并排序</td>
<td style="text-align: right;">Y</td>
<td style="text-align: right;"><span class="math display">\[O(nlogn)\]</span></td>
<td style="text-align: right;"><span class="math display">\[O(n)+O(logn)\]</span></td>
<td style="text-align: center;">分治法，递归将数列分成子数列，对子数列排序后合并</td>
</tr>
<tr class="odd">
<td>堆排序</td>
<td style="text-align: right;">N</td>
<td style="text-align: right;"><span class="math display">\[O(nlogn)\]</span></td>
<td style="text-align: right;"><span class="math display">\[O(1)\]</span></td>
<td style="text-align: center;">（有序区，无序区）构造二叉堆，将堆顶元素插入到有序区后面，然后再对新的无序区重建堆</td>
</tr>
<tr class="even">
<td>快速排序</td>
<td style="text-align: right;">N</td>
<td style="text-align: right;">平均：<span class="math display">\[O(nlogn)\]</span> 最坏：<span class="math display">\[O(n^2)\]</span></td>
<td style="text-align: right;"><span class="math display">\[O(logn)\]</span>,<span class="math display">\[O(n)\]</span></td>
<td style="text-align: center;">分治法。递归的将数列分成（小数，pivot，大数）</td>
</tr>
<tr class="odd">
<td>计数排序</td>
<td style="text-align: right;">Y</td>
<td style="text-align: right;"><span class="math display">\[O(n+m)\]</span></td>
<td style="text-align: right;"><span class="math display">\[O(n+m)\]</span></td>
<td style="text-align: center;">统计小于等于该元素的元素的个数i，该元素就放在目标数组的索引i位</td>
</tr>
<tr class="even">
<td>基数排序</td>
<td style="text-align: right;">Y</td>
<td style="text-align: right;">平均：<span class="math display">\[O(k*n)\]</span> 最坏：<span class="math display">\[O(n^2)\]</span></td>
<td style="text-align: right;">--</td>
<td style="text-align: center;">对元素的每一位进行单独排序，从低位开始，可以结合计数排序</td>
</tr>
<tr class="odd">
<td>桶排序</td>
<td style="text-align: right;">Y</td>
<td style="text-align: right;"><span class="math display">\[O(n)\]</span></td>
<td style="text-align: right;"><span class="math display">\[O(m)\]</span></td>
<td style="text-align: center;">把每个元素放在对应的桶中，对桶中元素进行排序后合并桶</td>
</tr>
</tbody>
</table>
<p>说明： 1. 升序排序 2. k表示数值中的数位的个数 3. n表示数据规模 4. m表示数据的最大值与最小值之差</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>八月早睡早起身体好，对着砖书写代码</title>
    <url>/2016/08/31/%E5%85%AB%E6%9C%88%E6%97%A9%E7%9D%A1%E6%97%A9%E8%B5%B7%E8%BA%AB%E4%BD%93%E5%A5%BD%EF%BC%8C%E5%AF%B9%E7%9D%80%E7%A0%96%E4%B9%A6%E5%86%99%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>先写写下个月的TO-DO吧：</p>
<ul>
<li>Docker（目测是<a href="https://book.douban.com/subject/26581184/">Docker源码分析</a>，但可能会中途弃，who knows~） + Go。</li>
<li>继续看<a href="https://book.douban.com/subject/25942191/">第一行代码</a>和<a href="https://book.douban.com/subject/10555435/">七周七语言</a></li>
<li>整理完DjangoCon US 2016 / PyCon Australia 2016 / PyCon 2016的Video List。</li>
</ul>
<p>八月初的某一天晚上，心里异常的平静。于是淡定的打开了Android Studio。开始了Android的学习之旅。那天，我知道这个与之前无数次打开Android教程不同，是真的已经到了那个point，正如去年沉下心来看web一样。</p>
<p>我觉得学习这种事情，培训班是一种方式，视频教程是一种方式，但对我来说，或许看书以及learn by doing是最适合的。而对于入门而言，找到一本书，然后跟着书中的代码一字一字的敲，死板，但是有效。每次时间不宜过长（对付多动症儿童只能这样），但须持之以恒，趁胜追击。所以每晚看一点Android（从公司小图书馆借的书只有两个月之期，按我这种磨磨蹭蹭的性子，不知道能否看完），每天看一天的七周七。回想起来，还是有所长进的。</p>
<p>说到七周七，真是很有意思。以前学C，学python，写Java，思维一套就够用了。但是看了Io，特别是看到Prolog，才发现原来语言还能这样。Io还能跟OO类比，但Prolog就真真是三段论了。特别是看到几行Prolog代码解决四色问题，更加体会到了语言这东西，只是工具，重要的是要学会使用最适合的工具。（P.S. Python仍旧是我的宠妃~~）。七周七里面还有四门语言，如无意外，九月份应该就会看完的。到时候应该会把笔记整理到个人wiki上。</p>
<p>提到个人wiki，其实就是gitbook上的一个repo。前段时间看完了一本书<a href="https://book.douban.com/subject/5372651/">Pragmatic Thinking and Learning - Refactor Your Wetware</a>，里面就有讲到个人wiki的好处。此书还介绍了不少干货，例如思维导图。然后在不知道哪本书里面提到了做总任务清单和日计划清单，在有道云笔记上实现了几周，感觉每天都较之从前充实（当然，也有可能是因为最近看的书多）。跑偏了，其实我是想说，如果可以的话，会在博客上面放一个目录，专门记录干货，比如下个月想整理的pycon之类的视频集、读书笔记等等。</p>
<p>翻了一下豆瓣的我读，发现这个月居然看了十本书，直接完成了年度阅读计划的1/6，而且其中小说比例非常之低，难得书香气了一回。其中有一本是涂先生写的<a href="https://book.douban.com/subject/25871778/">数据之巅</a>。他用数据的角度，把美国历史缓缓道来，让我时时有所触动。再者，工作之中常需要从数据中获取到一些什么，因此，那本被我搁置吃灰的书，要重新拿出来翻翻了。这里mark下。</p>
<p>这个月发生了一件令我有所触动的小事。工作上使用了python的一个库，但有些功能它并不具备，因此写了一些shell script来做辅助，算是外部对功能进行扩展吧。后来发现这样做要填补的坑是在太多了，而且坑中有坑，不知何处还有坑。搞得头发又掉了好几百根。再后来觉得不行，决定破釜沉舟，从内部解决。于是好好分析了下那个库的代码，做了类继承，重写了一些功能。幸好那个库是可以扩展的，也幸好代码逻辑简单，花的功夫竟然比纠结的时间还少。这件事告诉我，不要觉得重写很麻烦，也不要害怕替换，虽然本质上是对自己的及其不信任。但是做总比不做来得强，更何况很多时候，那些困难不过是自己想出来吓唬自己的，要有所增进，不就是要打败一只只挡在路上的大大小小的真/假纸老虎吗？</p>
]]></content>
      <categories>
        <category>这就是生活</category>
      </categories>
      <tags>
        <tag>Ele在思考</tag>
      </tags>
  </entry>
  <entry>
    <title>六月艳日夏愈显，吹着风扇写代码</title>
    <url>/2016/06/24/%E5%85%AD%E6%9C%88%E8%89%B3%E6%97%A5%E5%A4%8F%E6%84%88%E6%98%BE%EF%BC%8C%E5%90%B9%E7%9D%80%E9%A3%8E%E6%89%87%E5%86%99%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>最近从无到有研究自动化上线。 流程大致有了，却在实现上发散思维收不过来。有时隐约感觉就差一点点便要融会贯通，但是总有某处似乎被封印了，死活打不通任督二脉得以精进。</p>
<p>后来一日，决定静心从头开始看入门书，看实现代码。那些说不清道不明的东西，就在攻略书中得以解答。</p>
<p><strong>故总结，沉下心很重要，一本好书很重要。代码是最好的文档诚不我欺。</strong></p>
<p>作为回馈整理，应该会写一写关于ansible等工具的代码阅读整理。还可以写写walle的实现分析。这里记一下。</p>
<p>某天下班回家，突然有点感慨。当年在HW的时候，几乎事事有计划，事事有流程，你不用想太多，跟着大伙的步骤，跟着既定的框架走便是。凡事有先例，有人可问，有人带着你一步一步做好。于是很少主动去做些什么，偶尔主动做点什么事，也是从排得满满的偷点空，花长长的时间琢磨。琢磨出了，兴许皆大欢喜，琢磨不出，也无人责备。</p>
<p>而今在JG，却是大有不同。很多事要主动去想，去研究，去几乎自己从无到有。于是一天从早到晚，除了上班理所应当的要想之外，其他空闲，也忍不住要思考如何如何才合理，怎样怎样才比较好。</p>
<p>其实这与高中和大学有几分相似。其实没有什么好坏之分。只不过若长长久久的在一种状态却是极为不妥的。</p>
<p>后来，听了一集逻辑思维，才发现，原来这是被动型和主动型之分呀。</p>
<p>日前，有人给我留言，对pythondocument表示赞赏和支持。自从开始在app里面分享这个repo我觉得比较好玩的文之后，没事就会去刷刷star数。每当看到这个数字up时，总会很开心。翻不下去的时候，它能给我继续下去的理由。</p>
<p>很羞愧的看了下原六月的计划，发现基本无进展呀。计划赶不上变化。Eva最近很忙，没空理她的网站，我也就厚颜无耻的先suspend了。exchange那个我倒是想弄，只是在整理书的时候才惊觉原来我看的大多数是电子书！好吧，等我手头上的书累计到一定程度再说吧（听起来怎么辣么像借口(⊙o⊙)…）。而作为可选项的nginx，真心没时间开篇，╮(╯▽╰)╭</p>
<p>于是乎，七月份，要干嘛呢？</p>
<ul>
<li>nginx，必选，<a href="https://book.douban.com/subject/22793675/">深入理解Nginx</a></li>
<li>继续Eva的个人网站</li>
<li>整理前段时间看过代码的package</li>
</ul>
]]></content>
      <categories>
        <category>这就是生活</category>
      </categories>
      <tags>
        <tag>Ele在思考</tag>
      </tags>
  </entry>
  <entry>
    <title>发生了什么|Ansible之命令ansible开箱指南</title>
    <url>/2016/07/14/%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-Ansible%E4%B9%8B%E5%91%BD%E4%BB%A4ansible%E5%BC%80%E7%AE%B1%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p>基于Ansible 1.9.6。<a href="https://github.com/ansible/ansible/tree/stable-1.9">Github</a></p>
</blockquote>
<h1 id="概述">概述</h1>
<p><code>ansible</code>是ansible用于实现ad-hoc的命令行工具。而<code>ansible</code>位于<code>ansible/bin/</code>下。</p>
<h1 id="开箱了">开箱了</h1>
<h2 id="主流程__mian__">主流程：<code>__mian__</code></h2>
<ol type="1">
<li>新建Cli()实例， 命名为<code>cli</code></li>
<li>调用<code>cli.parse()</code>解析命令行参数及其值</li>
<li>调用<code>cli.run</code>进行某项操作。←_←这个是核心</li>
<li>解析并展示结果。对返回结果中的<code>results['contacted']</code>的每一项，若有<code>failed</code>值或者，<code>rc</code>键值不为0，表示该操作失败；若<code>results['dark']</code>不为空，则表示执行该操作的主机有问题，死掉之类的。</li>
</ol>
<h2 id="一窥cli类">一窥<code>Cli</code>类</h2>
<blockquote>
<p>该类定义于<code>ansible/bin/ansible</code>中</p>
</blockquote>
<h3 id="初始化">初始化</h3>
<ol type="1">
<li>声明两个属性：
<ul>
<li><code>stats</code>：类型为<code>ansible.callbacks.AggregateStats</code>。该类型主要用于对<code>ansible.runner.Runner.run</code>的返回结果进行统计（这个有机会会提到）。但是实际上，在<code>ansible</code>这个命令中，并未用到。</li>
<li><code>callbacks</code>：类型为<code>ansible.callbacks.CliRunnerCallbacks</code>。该类型专门用于ansible这个cli。主要作用是<code>ansible.runner.Runner.run</code>运行后各种返回状态的处理操作（这个有机会也会提到）</li>
</ul></li>
<li>一项操作 检查配置文件中的<code>bin_ansible_callbacks</code>项或者环境变量<code>ANSIBLE_LOAD_CALLBACK_PLUGINS</code>是否为<code>True</code>。是则调用<code>ansible.callbacks.load_callback_plugins</code>来加载回调插件</li>
</ol>
<h3 id="解析命令行参数及其值parse">解析命令行参数及其值：<code>parse()</code></h3>
<blockquote>
<p>使用包<code>optparse</code></p>
</blockquote>
<ol type="1">
<li><p>创建一个基本的选项解析器：（以下备忘及凑字数）</p>
<blockquote>
<p>说明：下面所说的<code>constants</code>指的是<code>ansible.constants</code></p>
</blockquote>
<ul>
<li><code>-v</code>/<code>--verbose</code>：冗余模式（-vvv 打印更多信息；-vvvv 启用连接调试），默认值：False</li>
<li><code>-f</code>/<code>--forks</code>：指定并行处理数，默认值：由<code>constants.DEFAULT_FORKS</code>指定</li>
<li><code>-i</code>/<code>--inventory-file</code>：指定inventory主机文件，默认值：由<code>constants.DEFAULT_HOST_LIST</code>指定</li>
<li><code>-e</code>/<code>--extra-vars</code>：设置额外的变量，格式为key=value或者YAML/JSON，默认值：[]</li>
<li><code>-u</code>/<code>--user</code>：指定连接的用户，默认值：由<code>constants.DEFAULT_REMOTE_USER</code>指定</li>
<li><code>-k</code>/<code>--ask-pass</code>：询问SSH密码，默认值：False</li>
<li><code>--private-key</code>：使用该文件来验证连接，默认值：由<code>constants.DEFAULT_PRIVATE_KEY_FILE</code>指定</li>
<li><code>--ask-vault-pass</code>：询问vault密码，默认值：False</li>
<li><code>--vault-password-file</code>：vault密码文件，默认值：由<code>constants.DEFAULT_VAULT_PASSWORD_FILE</code>指定</li>
<li><code>--list-hosts</code>：输出匹配主机列表；不执行任何其他操作</li>
<li><code>-M</code>/<code>--module-path</code>：指定module库的路径（可多个），默认值：None</li>
<li><code>-l</code>/<code>--limit</code>：进一步用额外的pattern限制所选的主机，默认值：由<code>constants.DEFAULT_SUBSET</code>指定</li>
<li><code>-T</code>/<code>--timeout</code>：覆盖SSH超时时间，以秒为单位，默认值：由<code>constants.DEFAULT_TIMEOUT</code>指定</li>
<li><code>-o</code>/<code>--one-line</code>：精简输出</li>
<li><code>-t</code>/<code>--tree</code>：将输出保存到该目录中，默认值：None</li>
<li><code>-K</code>/<code>--ask-sudo-pass</code>：询问sudo密码（已弃用，使用become），默认值：由<code>constants.DEFAULT_ASK_SUDO_PASS</code>指定</li>
<li><code>--ask-su-pass</code>：询问su密码（已弃用，使用become），默认值：由<code>constants.DEFAULT_ASK_SU_PASS</code>指定</li>
<li><code>-s</code>/<code>--sudo</code>：使用sudo（无密码）运行操作（已弃用，使用become），默认值：由<code>constants.DEFAULT_SUDO</code>指定</li>
<li><code>-U</code>/<code>--sudo-user</code>：所需sudo用户（已弃用，使用become），默认值：root、</li>
<li><code>-S</code>/<code>--su</code>：使用su（无密码）运行操作（已弃用，使用become），默认值：由<code>constants.DEFAULT_SU</code>指定</li>
<li><code>-R</code>/<code>--su-user</code>：所需su用户（已弃用，使用become），默认值：None</li>
<li><code>-b</code>/<code>--become</code>：使用become运行操作（无密码），默认值：由<code>constants.DEFAULT_BECOME</code>指定</li>
<li><code>--become-method</code>：所使用的升级特权的方法，可选值由<code>constants.DEFAULT_BECOME_METHOD</code>和<code>constants.BECOME_METHODS</code>指定，默认值：由<code>constants.DEFAULT_BECOME_METHOD</code>指定</li>
<li><code>--become-user</code>：使用该用户运行操作，默认值：由<code>constants.DEFAULT_BECOME_USER</code>指定</li>
<li><code>--ask-become-pass</code>：询问升级特权的密码，默认值：False</li>
<li><code>-c</code>/<code>--connection</code>：使用的连接类型，默认值：由<code>constants.DEFAULT_TRANSPORT</code>指定</li>
<li><code>-P</code>/<code>--poll</code>：如果使用<code>-B</code>选项，则用该选项设置poll间隔，默认值：由<code>constants.DEFAULT_POLL_INTERVAL</code>指定</li>
<li><code>-B</code>/<code>--background</code>：异步运行，在X秒后失败，默认值：0</li>
<li><code>-C</code>/<code>--check</code>：不进行任何改动；而是用来预测可能会发生的一些改动，默认值：False</li>
</ul></li>
<li><p>添加额外的命令行参数</p>
<ul>
<li><code>-a</code>/<code>--args</code>：模块参数</li>
<li><code>-m</code>/<code>--module-name</code>：模块名</li>
</ul></li>
<li><p>返回解析出来的选项和参数值</p></li>
</ol>
<h3 id="运行操作runoptions-args">运行操作：<code>run(options, args)</code></h3>
<blockquote>
<p>这里的两个参数就是<code>parse()</code>返回的两个值</p>
</blockquote>
<ol type="1">
<li>做准备
<ul>
<li>若选项<code>-c</code>/<code>--connection</code>为"local"，表明是在本地运行，因此<code>ask_pass</code>不用设置。</li>
<li>进行一系列的密码prompt工作，以获得<code>sshpass</code>/<code>becomepass</code>/<code>vault_pass</code>这三个分别用于登录到远程主机的密码/在远程主机上切换用户所需的密码/加密的文件密码</li>
<li>需要的情况下，从文件中读取<code>vault_pass</code></li>
<li>调用<code>ansible.utils.parse_extra_vars</code>来解析额外的变量（即通过<code>-e</code>/<code>--extra-vars</code>传过来的变量）</li>
<li>使用<code>-i</code>/<code>--inventory-file</code>传过来的inventory文件路径与上面得到的<code>vault_pass</code>来初始化<code>ansible.inventory.Inventory</code>实例</li>
<li>使用<code>-l</code>/<code>--limit</code>来缩小inventory中主机的范围</li>
</ul></li>
<li>除了实际做点什么……
<ul>
<li>检查实际操作的主机数，若为0，则输出提示，退出程序</li>
<li>设置了<code>--list-hosts</code>，则直接将所有要操作的主机都列出来，然后还是退出程序</li>
<li>（特殊判定）<code>-m</code>/<code>--module-name</code>参数值为command或者shell，并且参数<code>-a</code>/<code>--args</code>无值，则输出提示，退出程序</li>
<li>若设置了<code>-t</code>/<code>--tree</code>，则确保指定的目录存在且可写，为日志输出做准备</li>
</ul></li>
<li>核心的核心：<code>ansible.runner.Runner</code>
<ul>
<li>实例化一个<code>ansible.runner.Runner</code>对象runner</li>
<li>如果设置了<code>-B</code>/<code>--background</code>，表示异步运行，并在设置的值那么多时间后超时。此时，使用<code>runner.run_async()</code>，异步运行操作</li>
<li>否则，使用<code>runner.run()</code>直接运行。</li>
</ul></li>
</ol>
<h1 id="总结一下">总结一下</h1>
<p>ansible命令其实只是提供了一条直接到<code>ansible.runner.Runner</code>的路。后面等提到ansible-playbook的时候就可以看到，整个ansible工具的核心其实就在于<code>ansible.runner.Runner</code>。OK，鉴于ansible命令相对比较简单，一次执行实现一项操作，因此开箱到此为止。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>读代码</tag>
        <tag>自动化</tag>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>十月秋风扫落叶，啃着文档写代码</title>
    <url>/2016/10/31/%E5%8D%81%E6%9C%88%E7%A7%8B%E9%A3%8E%E6%89%AB%E8%90%BD%E5%8F%B6%EF%BC%8C%E5%95%83%E7%9D%80%E6%96%87%E6%A1%A3%E5%86%99%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>要是最初我知道会如此深入你，那一开始，我估计还是会那样漫不经心。</p>
<p>上个月呀，信誓旦旦的要看uwsgi代码。于是某日，真的沐浴更衣，准备潜心阅读。但一看到它长长的一下子拉不到底的uwsgi_sever结构，嗯，我怂了。为了不误入歧途，索性准备换一下，潜心看uwsgi官方文档。</p>
<p>所以看代码这种事，果然不能说得那么随意轻巧。为了舒适有效正确地阅读源代码，没有点对工具应用里里外外的了解，真的容易走火入魔。</p>
<p>于是做了个决定，今年内要把uwsgi中文版弄出来，当做是送给自己的跨2017礼物之一。这样一来，觉得uwsgi那一两百页文档，也可爱起来了。虽然进展缓慢，但是拌着文档看代码，似乎代码也没那么多难懂了(ฅ&gt;ω&lt;*ฅ)</p>
<p>这个月倒是把go给入门了(用的就是上个月说的那本书)。虽然还是小白，但至少觉得即使现在让我用go来写点什么，也不会那么虚了。不过发现，py写多了，常常忘了括号花括号冒号什么的。</p>
<p>在得到上面订了一年的硅谷来信。大概是因为花了钱，慢慢的可以坚持看下去。在一个地方待久了，人容易变成井底之蛙，安于一隅，不知道外面发生什么。所以需要听听别人，听听这个世界我不知道的地方在发生些什么。</p>
<p>攒的积分因为没有机械键盘可以换了，于是随意换了本书。还没到。到了的话，那本书就是我下个月的目标好了。</p>
<p>说到下个月的目标： * 想重新看看数学了。别问我为什么，我只是觉得当时当下，学学数学，是一种能让人静下来的方式。 * 会继续uwsgi doc zh，以及衍生系列 * <a href="https://book.douban.com/subject/25779298/">利用Python进行数据分析</a>。动力是，统计分析工作中遇到的问题规律呀！！！</p>
<p>借了一本书，花了四五天的夜读和地铁时光居然也把它看完了。书中提到的技术与艺术的合二为一，提到的Quality，加诸于coding上，我想是完全适用。借用书里的一句话来结束这篇流水账似的月末小结：</p>
<blockquote>
<p>当你做某件事的时候，一旦想要求快，就表示你再也不关心它，而想去做别的事。</p>
</blockquote>
]]></content>
      <categories>
        <category>这就是生活</category>
      </categories>
      <tags>
        <tag>Ele在思考</tag>
      </tags>
  </entry>
  <entry>
    <title>去吧去吧，2016</title>
    <url>/2017/01/27/%E5%8E%BB%E5%90%A7%E5%8E%BB%E5%90%A7%EF%BC%8C2016/</url>
    <content><![CDATA[<p>前几天拍视频，有个问题是，用一个词总结过去的一年。想了很久，给了三个字：<strong>刷副本</strong>。</p>
<p>从HW离开，到进入JG之间的几个月的时间内，狠狠地休息了一把。额外的bonus之一是，完全没有把上一份工作的负面情绪带到新工作中。于是在做新手村任务的时候，虽然多而杂，但是却也心甘情愿，沉醉于其中。在这过程中，一次又一次地验证了LEARN BY DOING的指导思想是多么多么地正确。</p>
<p>知道了好多东西。nginx、uwsgi、couchbase、rbmq、redis……</p>
<p>而另外一个则是，DIVE BY ISSUE。虽然无BUG是一个程序员毕生的追求，但是没有BUG的世界也缺少了那么点动力。特别是对于懒癌常常发作的Ele而言更是如此。因为文档缺乏，会去看各种第三方库的源代码。因为某个问题，仔仔细细翻了uwsgi的文档（虽然最后最后还是没有解决，囧）。学会了用pdb和traceback来做调试，学会用awk和sed来快速搜索，甚至偶尔会借用pd来做统计分析。</p>
<p>自15年的gap month闲来无事开的pythondocument，断断续续会push几篇喜欢的文章。虽然到后来基本只更新python weekly了，但所幸一直没有放弃。看着stars数一直在增长，我怎么舍得放弃？也因为这个，认识了一些人，一些很可爱很可爱的人。所以说，有时候，不要想太多，坚持下去，就会发现不知不觉中，做成了某些“大事”。</p>
<p>然而还是有很多事情没有做。一年中的干货产出仅寥寥几篇。说好的深入python也被自己忽略掉。没好好给自己写个应用，github上开的几个坑隐隐约约有被弃的可能性。想玩的硬件没玩到，想玩的安全更是连开始都没开始。如此让人羞愧，我都已经写不下去了。唯有用计划赶不上变化为借口</p>
<p>好啦好啦，接下来是许愿的时候。</p>
<ul>
<li>go（工作所需，趁此机会刷新技能）
<ul>
<li>基础（<a href="http://study.163.com/course/introduction.htm?courseId=306002#/courseDetail">Go编程基础</a>）</li>
<li>网络编程（<a href="http://study.163.com/course/courseMain.htm?courseId=328001#/courseMain">Go Web基础</a>）</li>
<li>高级编程（<a href="http://study.163.com/course/courseMain.htm?courseId=510006#/courseMain">Go名库讲解</a>）</li>
</ul></li>
<li>C/C++ (某位同事跟我说，做开发的到最后都是C，无C无突破)
<ul>
<li><a href="https://book.douban.com/subject/25708312/">C++ Primer 中文版</a>（为读源码做准备）</li>
<li>nginx源码</li>
<li>uwsgi源码</li>
</ul></li>
<li>数据分析（用来自娱自乐，以及更好的分析问题）
<ul>
<li>np / pd</li>
</ul></li>
<li>树莓派
<ul>
<li>魔镜（谨以此，送给2017年又大了一岁的Ele）</li>
<li>兮兮（不愿意放弃我那三千小言！！）</li>
</ul></li>
<li>python
<ul>
<li>py3 (<a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html">python cookbook</a>)：py2拜拜啦，我要把我手上的坑都弄成py3~</li>
<li>类、协程等高级编程</li>
<li>tornado</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>这就是生活</category>
      </categories>
      <tags>
        <tag>Ele在思考</tag>
      </tags>
  </entry>
  <entry>
    <title>发生了什么|Ansible之故事的放映室：ansible-playbook</title>
    <url>/2016/07/26/%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F-Ansible%E4%B9%8B%E6%95%85%E4%BA%8B%E7%9A%84%E6%94%BE%E6%98%A0%E5%AE%A4%EF%BC%9Aansible-playbook/</url>
    <content><![CDATA[<blockquote>
<p>基于Ansible 1.9.6。<a href="https://github.com/ansible/ansible/tree/stable-1.9">Github</a></p>
</blockquote>
<h1 id="概述">概述</h1>
<p><strong>ansible-playbook</strong>是ansible用于执行playbook的命令行工具。而ansible-playbook位于ansible/bin/下。</p>
<h1 id="好戏开始了">好戏开始了</h1>
<h2 id="主流程mainargs">主流程：<code>main(args)</code></h2>
<ol type="1">
<li>创建CLI选项的解析器，对选项进行解析
<ul>
<li>ansible-playbook比ansible少的几个选项
<ul>
<li><code>-o</code>/<code>--one-line</code>：精简输出</li>
<li><code>-t</code>/<code>--tree</code>：将输出保存到该目录中，默认值：None</li>
<li><code>-P</code>/<code>--poll</code>：如果使用-B选项，则用该选项设置poll间隔，默认值：由constants.DEFAULT_POLL_INTERVAL指定</li>
<li><code>-B</code>/<code>--background</code>：异步运行，在X秒后失败，默认值：0</li>
</ul></li>
<li>ansible-playbook比ansible多的几个选项
<ul>
<li><code>-D</code>/<code>--diff</code>：当修改（小）文件和模板时，显示这些文件的不同；与<code>--check</code>选项一起服用更佳。默认值：False</li>
<li><code>-t</code>/<code>--tags</code>：只运行那些带有该选项指定值的标签的play和task。 默认值：'all'</li>
<li><code>--skip-tags</code>：只运行那些不带有该选项指定值的标签的play和task。</li>
<li><code>--syntax-check</code>：对该playbook进行语法检查，并且不对其进行执行。</li>
<li><code>--list-tasks</code>：列出所有要执行的task</li>
<li><code>--list-tags</code>：列出所有可用标签</li>
<li><code>--step</code>：一次执行一个步骤，在每个步骤运行之前进行确认</li>
<li><code>--start-at-task</code>：在匹配该选项指定的名字的那个task开始该playbook</li>
<li><code>--force-handlers</code>：即使task失败了，也要运行handler。默认值：由<code>C.DEFAULT_FORCE_HANDLERS</code>指定</li>
<li><code>--flush-cache</code>：清除fact缓存</li>
</ul></li>
</ul></li>
<li>一些准备工作
<ul>
<li>检查权限相关的选项是否冲突：
<ul>
<li>sudo相关选项、su相关选项和become相关选项相互排斥</li>
<li><code>--ask-vault-pass</code>和<code>--vault-password-file</code>相互排斥</li>
</ul></li>
<li>询问密码
<ul>
<li>如果是<code>--list-hosts</code> / <code>--syntax-check</code> / <code>--list-tags</code>，则按需询问vault password</li>
<li>否则，在不是本地操作的情况下，按需询问ssh password / become passowrd / vault password</li>
<li>在未指定<code>--ask-vault-pass</code>，并且指定了vault password file的情况下，读取文件中的vault password</li>
</ul></li>
<li>判断playbook是否存在，是否是一个文件</li>
<li>根据指定的inventory，初始化<code>ansible.inventory.Inventory</code>实例
<ul>
<li>判断提供的主机列表是否为空</li>
<li>根据<code>--limit</code>选项过滤掉不需要执行的主机，然后再一次判断过滤后的主机列表是否为空</li>
</ul></li>
</ul></li>
<li>运行命令行参数指定的所有playbook。对每个playbook，有
<ul>
<li>创建一个<code>ansible.callbacks.AggregateStats</code>实例，用来对playbook的运行结果进行整理统计</li>
<li>创建一个<code>ansible.callbacks.PlaybookCallbacks</code>实例</li>
<li>创建一个<code>ansible.callbacks.PlaybookRunnerCallbacks</code>实例</li>
<li>用playbook初始化一个<code>ansible.playbook.PlayBook</code>实例</li>
<li>除了实际做点什么……
<ul>
<li>设置了<code>--list-hosts</code>，则列出该playbook对应的主机列表</li>
<li>设置了<code>--list-tags</code>/<code>--list-tasks</code>，则列出该playbook中所有的tag/task</li>
<li>设置了<code>--syntax-check</code>，则在前面所有操作都运行完后没有任何错误，则表示语法正常，直接返回。</li>
</ul></li>
<li><strong>运行playbook</strong>：<code>ansible.playbook.PlayBook.run()</code></li>
<li>解析执行结果(此时，前面定义的AggregateStats实例派上用场)
<ul>
<li>计算failed（失败）或者unreachable（不可达）的主机，根据<code>C.RETRY_FILES_ENABLED</code>参数按需生成retry文件</li>
<li>对每个主机，展示执行结果：ok / changed / unreachable / failed</li>
<li>若failed的主机数大于0，则返回2</li>
<li>若unreachable的主机数大于0，则返回3</li>
<li>中途抛出任意异常，则返回1</li>
</ul></li>
</ul></li>
</ol>
<h2 id="边边角角的类及函数说明">边边角角的类及函数说明</h2>
<ol type="1">
<li><code>ansible.inventory.Inventory</code> ansible中用于解析inventory的类
<ul>
<li>初始化 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># host_list：默认值由ansible.constants.DEFAULT_HOST_LIST指定，可以是一个主机文件路径（字符串）、主机脚本路径（字符串）、host列表（列表）、由逗号分隔的主机列表（字符串）</span></span><br><span class="line"><span class="comment"># vault_password：vault password</span></span><br><span class="line">__init__(self, host_list=C.DEFAULT_HOST_LIST, vault_password=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></li>
<li>几个方法<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回所有主机名匹配参数pattern指定的值的主机，并且考虑所有的inventory限制或者应用的子集。</span></span><br><span class="line"><span class="comment"># pattern：可以是一个列表，或者由&quot;;&quot;/&quot;,&quot;/&quot;:&quot;分隔的字符串</span></span><br><span class="line">get_hosts(self, pattern=<span class="string">&quot;all&quot;</span>)</span><br><span class="line"><span class="comment"># 返回主机名匹配参数pattern指定值的主机名。若pattern取值为&quot;localhost&quot;/&quot;127.0.0.1&quot;，则返回值包含pattern</span></span><br><span class="line"><span class="comment"># pattern：同get_hosts</span></span><br><span class="line">list_hosts(self, pattern=<span class="string">&quot;all&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><code>ansible.callbacks.AggregateStats</code> 用以保存playbook运行期间的每一个主机活动。
<ul>
<li>几个属性 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下属性的类型皆为dict</span></span><br><span class="line"><span class="comment"># 保存每个主机处理过的操作数</span></span><br><span class="line">self.processed</span><br><span class="line"><span class="comment"># 保存每个主机执行失败的操作数</span></span><br><span class="line">self.failures</span><br><span class="line"><span class="comment"># 保存每个主机正常执行的操作数</span></span><br><span class="line">self.ok</span><br><span class="line"><span class="comment"># 保存每个主机不可达的操作数</span></span><br><span class="line">self.dark</span><br><span class="line"><span class="comment"># 保存每个主机有做修改的操作数</span></span><br><span class="line">self.changed</span><br><span class="line"><span class="comment"># 保存每个主机跳过的操作数</span></span><br><span class="line">self.skipped</span><br></pre></td></tr></table></figure></li>
<li>几个方法 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对执行结果进行计算，刷新统计信息</span></span><br><span class="line"><span class="comment"># runner_results为ansible.Runner.runner.run()方法的返回结果</span></span><br><span class="line">compute(self, runner_results, setup=<span class="literal">False</span>, poll=<span class="literal">False</span>, ignore_errors=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 返回由参数host指定的主机的统计信息</span></span><br><span class="line">summarize(self, host)</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><code>ansible.playbook.PlayBook</code> ansible中用于解析playbook的类
<ul>
<li>初始化 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下的C指的是ansible.constants</span></span><br><span class="line">__init__(self,</span><br><span class="line">    playbook         = <span class="literal">None</span>, <span class="comment"># 一个playbook文件的路径</span></span><br><span class="line">    host_list        = C.DEFAULT_HOST_LIST, <span class="comment"># 主机文件的路径，例如/etc/ansible/hosts</span></span><br><span class="line">    module_path      = <span class="literal">None</span>, <span class="comment"># ansible模块的路径，例如/usr/share/ansible/</span></span><br><span class="line">    forks            = C.DEFAULT_FORKS, <span class="comment"># 所需的并行级别</span></span><br><span class="line">    timeout          = C.DEFAULT_TIMEOUT, <span class="comment"># 连接超时时间</span></span><br><span class="line">    remote_user      = C.DEFAULT_REMOTE_USER, <span class="comment"># 如果一个play中没有指定运行用户的话，则用这个用户运行</span></span><br><span class="line">    remote_pass      = C.DEFAULT_REMOTE_PASS, </span><br><span class="line">    remote_port      = <span class="literal">None</span>,</span><br><span class="line">    transport        = C.DEFAULT_TRANSPORT,<span class="comment"># 如何连接到一个未指定传输的主机，(local, paramiko等等)</span></span><br><span class="line">    private_key_file = C.DEFAULT_PRIVATE_KEY_FILE,</span><br><span class="line">    callbacks        = <span class="literal">None</span>, <span class="comment"># 该playbook的输出回调</span></span><br><span class="line">    runner_callbacks = <span class="literal">None</span>, <span class="comment"># 用于runner API的回调</span></span><br><span class="line">    stats            = <span class="literal">None</span>, <span class="comment"># 保存每个主机运行事件的聚集信息，为ansible.callbacks.AggregateStats实例</span></span><br><span class="line">    extra_vars       = <span class="literal">None</span>,</span><br><span class="line">    only_tags        = <span class="literal">None</span>,</span><br><span class="line">    skip_tags        = <span class="literal">None</span>,</span><br><span class="line">    subset           = C.DEFAULT_SUBSET,</span><br><span class="line">    inventory        = <span class="literal">None</span>, <span class="comment"># 可以指定该参数以取代host_list，使用一个预先存在的ansible.inventory.Inventory实例</span></span><br><span class="line">    check            = <span class="literal">False</span>, <span class="comment"># 不进行任何实际操作，用来检测一些潜在的修改操作</span></span><br><span class="line">    diff             = <span class="literal">False</span>,</span><br><span class="line">    any_errors_fatal = <span class="literal">False</span>, <span class="comment"># 当其中一个主机执行失败的时候，立即结束整个执行过程</span></span><br><span class="line">    vault_password   = <span class="literal">False</span>,</span><br><span class="line">    force_handlers   = <span class="literal">False</span>, <span class="comment"># 即使一个task失败，也会继续通知并运行handler</span></span><br><span class="line">    <span class="comment"># privelege escalation</span></span><br><span class="line">    become           = C.DEFAULT_BECOME,</span><br><span class="line">    become_method    = C.DEFAULT_BECOME_METHOD,</span><br><span class="line">    become_user      = C.DEFAULT_BECOME_USER,</span><br><span class="line">    become_pass      = <span class="literal">None</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>几个方法 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行playbook</span></span><br><span class="line"><span class="comment"># 实际上会为playbook中的每个play创建ansible.playbook.play实例，然后调用类方法_run_play()运行每个play</span></span><br><span class="line">run()</span><br><span class="line"><span class="comment"># 实际的play运行方法。过程：获取过滤运行该play的主机列表 -&gt; 调用类的_do_setup_step方法获取主机的facts（作为变量用在play中） -&gt; 处理serial标签 -&gt; 进一步过滤运行的主机 -&gt; 运行该play中的每个task/handler -&gt; 对结果进行处理</span></span><br><span class="line">_run_play()</span><br><span class="line"><span class="comment"># 用以获取远程主机的facts。实际上是调用了setup模块</span></span><br><span class="line">_do_setup_step(play)</span><br></pre></td></tr></table></figure> # 观影心得 ansible-playbook是个非常强大的工具，你只需写好剧本（playbook），定下剧情（task），挑好主角（host），有时还需要一些变化(var)，就可以上演一出大戏。</li>
</ul></li>
</ol>
<p>ansible官网对其python API解释甚少。但是我们可以通过ansible-playbook的实现入手（ansible-playbook比ansible更复杂，更全面），了解ansible内部的python API的作用和使用方法。从而在需要的时候，参考其使用手法，在自己的app中借助ansible内部提供的方法，避免重复造轮子，打造自己的自动化工具。</p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>读代码</tag>
        <tag>自动化</tag>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>基于豆瓣的线上活动的关键字分析</title>
    <url>/2015/10/17/%E5%9F%BA%E4%BA%8E%E8%B1%86%E7%93%A3%E7%9A%84%E7%BA%BF%E4%B8%8A%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>最近在玩scrapy。 然后某一天逛豆瓣的时候，看到一个活动：<a href="http://www.douban.com/online/122763231/">#我的欲望清单</a>。突然很好奇大家的欲望清单都是怎么样的。于是决定放只爬虫出去，获取该活动的所有回复信息。然后计算关键词及词频生成词云。 代码已上传到<a href="https://github.com/ictar/doubanOnlineAnalyzer">doubanOnlineAnalyzer</a></p>
<h1 id="爬取活动回复信息">爬取活动回复信息</h1>
<h2 id="安装scrapy">安装scrapy</h2>
<p>首先，我们需要安装scrapy。 scrapy的安装这里就不赘述了，可以参考<a href="http://scrapy-chs.readthedocs.org/zh_CN/1.0/intro/install.html#intro-install-platform-notes">平台安装指南</a></p>
<h2 id="新建项目">新建项目</h2>
<p>接着，我们需要创建一个项目，进入到你想要放置这个项目的目录中，执行下列命令： <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">scrapy startproject doubanScrapy</span></span><br></pre></td></tr></table></figure> 此命令运行结束后，会创建包含下面内容的目录： <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">doubanScrapy</span>/</span><br><span class="line">    <span class="selector-tag">scrapy</span><span class="selector-class">.cfg</span></span><br><span class="line">    <span class="selector-tag">doubanScrapy</span>/</span><br><span class="line">        __<span class="selector-tag">init__</span><span class="selector-class">.py</span></span><br><span class="line">        <span class="selector-tag">items</span><span class="selector-class">.py</span></span><br><span class="line">        <span class="selector-tag">pipelines</span><span class="selector-class">.py</span></span><br><span class="line">        <span class="selector-tag">settings</span><span class="selector-class">.py</span></span><br><span class="line">        <span class="selector-tag">spiders</span>/</span><br><span class="line">            __<span class="selector-tag">init__</span><span class="selector-class">.py</span></span><br></pre></td></tr></table></figure> ## 定义Item 下面，我们来定义保存保存爬取到的数据的容器。(如果你玩django，会发现这里的Item和django的module很像) 编辑<code>doubanOnline/doubanOnline/items.py</code>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">doubanOnlineItem</span>(<span class="params">scrapy.Item</span>):</span></span><br><span class="line">	link = scrapy.Field() <span class="comment"># 回复的链接</span></span><br><span class="line">	content = scrapy.Field() <span class="comment"># 此回复的内容</span></span><br><span class="line">	author = scrapy.Field() <span class="comment"># 此回复的作者</span></span><br><span class="line">	date = scrapy.Field() <span class="comment"># 此回复的日期</span></span><br></pre></td></tr></table></figure> ## 编写爬虫 在<code>doubanScrapy/doubanScrapy/spiders/</code>下新建一个文件<code>doubanOnline.py</code>后编辑： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> doubanScrapy.items <span class="keyword">import</span> DoubanOnlineItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">doubanOnlineSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">	name = <span class="string">&quot;doubanOnline&quot;</span></span><br><span class="line">	allowed_domains = [<span class="string">&quot;douban.com&quot;</span>]</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, online1st=<span class="literal">None</span></span>):</span></span><br><span class="line">		self.start_urls = [online1st] <span class="comment"># start_urls通过命令行传参设定</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">		item = DoubanOnlineItem()</span><br><span class="line">		item[<span class="string">&#x27;link&#x27;</span>] = response.url <span class="comment">#使用xpath解析内容</span></span><br><span class="line">		item[<span class="string">&#x27;content&#x27;</span>] = response.xpath(<span class="string">&#x27;//blockquote[@class=&quot;photo-text&quot;]/p/text()&#x27;</span>).extract()</span><br><span class="line">		item[<span class="string">&#x27;author&#x27;</span>] = response.xpath(<span class="string">&#x27;//div[@class=&quot;photo-ft&quot;]/a/text()&#x27;</span>).extract()[<span class="number">0</span>].encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">		item[<span class="string">&#x27;date&#x27;</span>] = response.css(<span class="string">&#x27;div[class=&quot;photo-ft&quot;]::text&#x27;</span>).extract()[-<span class="number">1</span>].strip()[<span class="number">3</span>:].encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">		item[<span class="string">&#x27;content&#x27;</span>] = item[<span class="string">&#x27;content&#x27;</span>][<span class="number">0</span>].encode(<span class="string">&#x27;utf-8&#x27;</span>).strip() <span class="keyword">if</span> <span class="built_in">len</span>(item[<span class="string">&#x27;content&#x27;</span>])&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line">		<span class="keyword">yield</span> item</span><br><span class="line">		<span class="built_in">next</span> = response.xpath(<span class="string">&#x27;//a[@name=&quot;next_photo&quot;]/@href&#x27;</span>).extract()[<span class="number">0</span>]</span><br><span class="line">		total = response.xpath(<span class="string">&#x27;//span[@class=&quot;ll&quot;]/text()&#x27;</span>).extract()[<span class="number">0</span>]</span><br><span class="line">		cur, total = total.split(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">		<span class="built_in">print</span> <span class="string">&quot;total: %s, current: %s&quot;</span> % (total[<span class="number">1</span>:-<span class="number">1</span>],cur[<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line">		<span class="keyword">if</span> cur[<span class="number">1</span>:-<span class="number">1</span>] == total[<span class="number">1</span>:-<span class="number">1</span>]: <span class="comment"># 爬到最后一页，结束</span></span><br><span class="line">			<span class="keyword">raise</span> CloseSpider(<span class="string">&#x27;------------------ End Search! ------------------&#x27;</span>)</span><br><span class="line">		<span class="keyword">yield</span> scrapy.Request(<span class="built_in">next</span>, callback=self.parse)</span><br></pre></td></tr></table></figure> ## 修改配置项 由于有些网站做了防爬虫处理，因此，我们需要修改爬虫的配置项，将其伪装成普通浏览器。 将<code>doubanOnline/doubanOnline/settings.py</code>修改为： <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">USER_AGENT</span> = &#x27;Mozilla/<span class="number">5</span>.<span class="number">0</span> (Macintosh; Intel Mac OS X <span class="number">10</span>_<span class="number">8</span>_<span class="number">3</span>) AppleWebKit/<span class="number">536</span>.<span class="number">5</span> (KHTML, like Gecko) Chrome/<span class="number">19</span>.<span class="number">0</span>.<span class="number">1084</span>.<span class="number">54</span> Safari/<span class="number">536</span>.<span class="number">5</span>&#x27;</span><br><span class="line"><span class="attribute">DOWNLOAD_DELAY</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure> ## 执行爬虫 运行爬虫很简单，只要cd到项目路径下，运行下面这个命令即可： <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">scrapy</span> crawl doubanOnline -a online<span class="number">1</span>st=[豆瓣线上活动首页] -o onlineac.json</span><br></pre></td></tr></table></figure> 注： * 这里的<code>doubanOnline</code>即在爬虫中定义的<code>name</code> * <code>-a</code>可以指定传给爬虫的参数。这里，我们需要指定某个线上活动的首页 * <code>-o</code>使用feed export，指定生成的json文件的名称。这样就不必使用Pipline，直接将爬虫中<code>yield item</code>保存为json格式。</p>
<h2 id="小笔记">小笔记</h2>
<ol type="1">
<li>python的json.dumps方法默认会输出成这种格式""。要输出中文需要指定ensure_ascii参数为False，如下代码片段： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">json.dumps(&#123;<span class="string">&#x27;text&#x27;</span>:<span class="string">&quot;中文&quot;</span>&#125;,ensure_ascii=<span class="literal">False</span>,indent=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li>使用scrapy的feed export生成的json文件如果包含了中文，会变成unicode的形式。可以参考<a href="http://exitna.github.io/">解决Scrapy中feed export为json格式时中文显示为</a>对scrapy源码进行修改。</li>
</ol>
<h1 id="关键词可视化">关键词可视化</h1>
<p>过程如下：分词 -&gt; 词频计算 -&gt; 词云生成</p>
<h2 id="分词">分词</h2>
<p>大部分的第三方分词模块都是针对英文分词的。而对于中文，我们需要祭出神器：<a href="https://github.com/fxsjy/jieba">jieba</a>。</p>
<p>安装<a href="https://github.com/fxsjy/jieba">jieba</a>只需要：<code>pip install jieba</code> 而其使用也很简单。<a href="https://github.com/fxsjy/jieba">jieba</a>支持三种模式的分词：全模式，精确模式，搜索引擎模式。这里我们使用全模式，使用方式如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linewc = jieba.cut(resp[<span class="string">&quot;content&quot;</span>], cut_all=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure> ## 词频计算 由于我们前面已经保存了每一个回复对应的内容，因此我们只需要统计分词后的结果，生成一个以单词为键，出现次数为值的字典即可。 因此，总结第一和第二步，可以得出代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_genWordCount</span>(<span class="params">filename, nonsense=[]</span>):</span></span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27; this method is used to abstract the words from the text</span></span><br><span class="line"><span class="string">		and calculate the count of text</span></span><br><span class="line"><span class="string">		filename - file&#x27;s name which generated through scrapy.</span></span><br><span class="line"><span class="string">		nonsense - words&#x27; list which contains the words we&#x27;ll exclude.</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">	wc = &#123;&#125;  <span class="comment"># 一个以单词为键，出现次数为值的字典</span></span><br><span class="line">	<span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">		<span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">			resp = json.loads(line) <span class="comment"># 以json格式解析</span></span><br><span class="line">			linewc = jieba.cut(resp[<span class="string">&quot;content&quot;</span>], cut_all=<span class="literal">True</span>) <span class="comment"># 分词</span></span><br><span class="line">			<span class="keyword">for</span> item <span class="keyword">in</span> linewc:</span><br><span class="line">				<span class="keyword">if</span> item <span class="keyword">in</span> nonsense: <span class="comment"># 排除nonsense中的单词，不统计</span></span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				<span class="keyword">if</span> item.strip():</span><br><span class="line">					wc.setdefault(item,<span class="number">0</span>)</span><br><span class="line">					wc[item] +=<span class="number">1</span> <span class="comment"># 计数</span></span><br><span class="line">	<span class="keyword">return</span> wc</span><br></pre></td></tr></table></figure> ## 词云生成 <a href="https://github.com/atizo/PyTagCloud">PyTagCloud</a>可以帮助我们生成词云。 首先，安装<a href="https://github.com/atizo/PyTagCloud">PyTagCloud</a> <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> pytagcloud</span><br></pre></td></tr></table></figure> * 注意，这里可能需要安装simplejson</p>
<p>由于我们一般只关心出现频率最高的单词，因此需要对词频字典进行排序，然后取其出现频率最高的前top个词及其频率进行展示。</p>
<p>另外，pytagcloud本身是不带中文字库的。这样会导致中文无法展示出来。因此我们需要下载一个中文字体文件（随便你喜欢什么中文字体，这里我选择了微软华文雅黑，文件名为<code>yahei.tff</code>）。将此字体文件放在python的安装目录的<code>Lib\site-packages\pytagcloud\fonts</code>下，然后在此目录下的<code>fonts.json</code>文件中添加一条记录。 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;MSyh&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;ttf&quot;</span>: <span class="string">&quot;yahei.ttf&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;web&quot;</span>: <span class="string">&quot;none&quot;</span></span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure> 这样，我们就可以正常显示中文了。 完整的词云图像生成代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pytagcloud <span class="keyword">import</span> create_tag_image, make_tags</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="comment">#import random</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genWdCloud</span>(<span class="params">wc,top=<span class="number">50</span>,SIZE1=<span class="number">1</span>,SIZE2=<span class="number">100</span>, pngname=<span class="string">&#x27;doubanOnlineActivity.png&#x27;</span></span>):</span></span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27; this method is used to generate words cloud according to the words&#x27; frequency</span></span><br><span class="line"><span class="string">		wc - the dictionary which describes the words and corresponding frequency</span></span><br><span class="line"><span class="string">		top - display top max frequency</span></span><br><span class="line"><span class="string">		SIZE1 - minsize of words</span></span><br><span class="line"><span class="string">		SIZE2 - maxsize of words</span></span><br><span class="line"><span class="string">		pngname - the name of the generated image</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">	swc = <span class="built_in">sorted</span>(wc.iteritems(), key=itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>) <span class="comment"># 根据字典键对应的值排序，逆序</span></span><br><span class="line">	<span class="comment">#print swc</span></span><br><span class="line">	tags = make_tags(swc[:top], <span class="comment"># 只取出现频率最高的top个词</span></span><br><span class="line">					minsize=SIZE1,</span><br><span class="line">					maxsize=SIZE2,</span><br><span class="line">					<span class="comment">#colors=random.choice(COOR_SCHEMES.values())</span></span><br><span class="line">					)</span><br><span class="line">	create_tag_image(tags,</span><br><span class="line">					 pngname, </span><br><span class="line">					 background=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),</span><br><span class="line">					 size=(<span class="number">900</span>,<span class="number">600</span>),</span><br><span class="line">					 fontname=<span class="string">&quot;MSyh&quot;</span>)</span><br></pre></td></tr></table></figure> 你将在当前目录下发现一个名为pngname所指定的名字的图像。</p>
<h1 id="后续">后续</h1>
<ol type="1">
<li>pytagcloud的HTML形式</li>
<li>如何扩展呢？</li>
</ol>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="http://www.cnblogs.com/stubborn412/p/3818423.html">python中json.dumps使用的坑以及字符编码</a></li>
<li><a href="http://reverland.org/python/2014/01/12/python/">Python中文标签云之pytagcloud</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自动化</tag>
        <tag>数据可视化</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>堆、栈、队列及其Python的简单实现</title>
    <url>/2015/12/15/%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%8F%8A%E5%85%B6Python%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="栈">栈</h1>
<p>LIFO: last-in, first-out 后进先出 可以用一个数组S[1..n]来实现一个最多可容纳n个元素的栈。该数组有一个属性S.top， 指向最新插入的元素。栈中包含的元素为S[1..S.top]，其中S[1]是栈底元素，S[S.top]是栈顶元素。</p>
<p>两种操作： 1. PUSH：压入，栈上的INSERT操作，时间复杂度O(1) 2. POP：弹出，栈上的DELETE操作，时间复杂度O(1)</p>
<p>两种错误： 1. 栈下溢(underflow)：试图对一个空栈执行弹出操作 2. 栈上溢(overflow)：试图对一个已满的栈执行压入操作</p>
<h2 id="python实现">python实现</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UNDERFLOW</span>(<span class="params">Exception</span>):</span><span class="keyword">pass</span> <span class="comment"># 下溢</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OVERFLOW</span>(<span class="params">Exception</span>):</span><span class="keyword">pass</span> <span class="comment"># 上溢</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size</span>):</span></span><br><span class="line">        self.top = -<span class="number">1</span> <span class="comment">#指向最新插入的元素</span></span><br><span class="line">        self.S = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,size)]</span><br><span class="line">        self.size = size</span><br><span class="line">    <span class="comment">#测试一个栈是否为空</span></span><br><span class="line">    STACK_EMPTY = <span class="keyword">lambda</span> self: self.top == -<span class="number">1</span></span><br><span class="line">    <span class="comment">#测试一个栈是否已满</span></span><br><span class="line">    STACK_FULL = <span class="keyword">lambda</span> self: self.top == self.size-<span class="number">1</span></span><br><span class="line">    <span class="comment">#插入元素到栈顶</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PUSH</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.STACK_FULL():</span><br><span class="line"> </span><br><span class="line">               <span class="keyword">raise</span> OVERFLOW(<span class="string">&quot;stack is full&quot;</span>)</span><br><span class="line">        self.top += <span class="number">1</span></span><br><span class="line">        self.S[self.top] = x</span><br><span class="line">    <span class="comment">#将栈顶元素返回并删除</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">POP</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.STACK_EMPTY():</span><br><span class="line">            <span class="keyword">raise</span> UNDERFLOW(<span class="string">&quot;stack is empty&quot;</span>)</span><br><span class="line">        x = self.S[self.top]</span><br><span class="line">        self.top -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明： 可以直接用python中的list来实现栈。PUSH操作相当于list.append(x)，POP操作相当于list.pop()</p>
</blockquote>
<h1 id="队列">队列</h1>
<p>FIFO: first-in, first-out 先进先出</p>
<p>队列有队头和队尾，当一个元素入队时，被放在队尾的位置；而出队的元素则总是在队头的那个。 利用数组Q[1..n]来实现含有n-1个元素队列（保留一位元素用来判断队列空或满）。该队列有一个属性Q.head指向对头元素，属性Q.tail指向下一个新元素将要插入的位置，队列中的元素存放在位置Q.head, Q.head+1, ..., Q.tail-1上。 初始时，Q.head = Q.tail = 1。当Q.head = Q.tail时， 队列为空。当Q.head=Q.tail+1时，队列是满的。</p>
<p>两种操作： 1. ENQUEUE：入队，队列上的INSERT操作，时间复杂度O(1) 2. DEQUEUE：出队，队列上的DELETE操作，时间复杂度O(1)</p>
<h2 id="python实现-1">python实现</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UNDERFLOW</span>(<span class="params">Exception</span>):</span><span class="keyword">pass</span> <span class="comment"># 下溢</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OVERFLOW</span>(<span class="params">Exception</span>):</span><span class="keyword">pass</span> <span class="comment"># 上溢</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,size</span>):</span></span><br><span class="line">        self.head = self.tail = <span class="number">0</span></span><br><span class="line">        self.S = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,size)]</span><br><span class="line">        self.size = size</span><br><span class="line">    <span class="comment"># 判断队列是否已满</span></span><br><span class="line">    QUEUE_FULL = <span class="keyword">lambda</span> self: self.head == (self.tail+<span class="number">1</span>)%self.size</span><br><span class="line">    <span class="comment"># 判断队列是否为空</span></span><br><span class="line">    QUEUE_EMPTY = <span class="keyword">lambda</span> self: self.head == self.tail</span><br><span class="line">    <span class="comment"># 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ENQUEUE</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.QUEUE_FULL(): <span class="keyword">raise</span> OVERFLOW(<span class="string">&quot;the queue is full&quot;</span>)</span><br><span class="line">        self.S[self.tail] = x</span><br><span class="line">        self.tail = (self.tail+<span class="number">1</span>) % self.size</span><br><span class="line">    <span class="comment"># 出队</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DEQUEUE</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.QUEUE_EMPTY(): <span class="keyword">raise</span> UNDERFLOW(<span class="string">&quot;the queue is empty&quot;</span>)</span><br><span class="line">        x = self.S[self.head]</span><br><span class="line">        self.head = (self.head+<span class="number">1</span>) % self.size</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： 可以使用python中的collections.deque来实现队列。ENQUEUE相当于deque.append(), DEQUEUE相当于deque.popleft()</p>
</blockquote>
<h1 id="堆">堆</h1>
<p>在<a href="/2015/12/07/九大排序算法及其Python实现之堆排序/">九大排序算法及其Python实现之堆排序</a>中已经基本讲述了堆的性质。 下面讲讲堆的应用之一：优先队列 优先队列是一种用来维护由一组元素构成的集合S的数据结构，其中的每一个元素都有一个相关的值，称为关键字(key)。 一个最大优先队列S支持以下操作： 1. INSERT(S, x)：把元素x插入集合S中。 2. MAXIMUM(S)：返回S中具有最大键值的元素 3. EXTRACT-MAX(S)：去掉并返回S中的具有最大键值的元素 4. INCREASE-KEY(S, x, k)：将元素x的关键字值增加到k，这里假设k的值不小于x的原关键字值。</p>
<h2 id="实现">实现</h2>
<p>伪代码： <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"># 时间复杂度：<span class="constructor">O(1)</span></span><br><span class="line">HEAP-<span class="constructor">MAXIMUM(S)</span></span><br><span class="line">    return S<span class="literal">[<span class="number">1</span>]</span></span><br><span class="line"># 时间复杂度：<span class="constructor">O(<span class="params">logn</span>)</span></span><br><span class="line">HEAP-EXTRACT-<span class="constructor">MAX(S)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="module-access"><span class="module"><span class="identifier">S</span>.</span></span>heap-size &lt; <span class="number">1</span></span><br><span class="line">        error <span class="string">&quot;heap underflow&quot;</span></span><br><span class="line">    max = S<span class="literal">[<span class="number">1</span>]</span></span><br><span class="line">    S<span class="literal">[<span class="number">1</span>]</span> = S<span class="literal">[S.<span class="identifier">heap</span>-<span class="identifier">size</span>]</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>heap-size = <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>heap-size - <span class="number">1</span></span><br><span class="line">    MAX-<span class="constructor">HEAPIFY(A, 1)</span></span><br><span class="line">    return max</span><br><span class="line"># i为x的下标</span><br><span class="line"># 时间复杂度：<span class="constructor">O(<span class="params">logn</span>)</span></span><br><span class="line">HEAP-INCREASE-<span class="constructor">KEY(S, <span class="params">i</span>, <span class="params">k</span>)</span></span><br><span class="line">    <span class="keyword">if</span> k &lt; S<span class="literal">[<span class="identifier">i</span>]</span></span><br><span class="line">        error <span class="string">&quot;new key is smaller than current key&quot;</span></span><br><span class="line">    A<span class="literal">[<span class="identifier">i</span>]</span> = key</span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">1</span> <span class="keyword">and</span> A<span class="literal">[PARENT(<span class="identifier">i</span>)]</span> &lt; A<span class="literal">[<span class="identifier">i</span>]</span> # 维护优先队列，即维护最大堆</span><br><span class="line">        exchange A<span class="literal">[<span class="identifier">i</span>]</span> <span class="keyword">with</span> A<span class="literal">[PARENT(<span class="identifier">i</span>)]</span></span><br><span class="line">        i = <span class="constructor">PARENT(<span class="params">i</span>)</span></span><br><span class="line"># key表示元素x的值</span><br><span class="line"># 时间复杂度：<span class="constructor">O(<span class="params">logn</span>)</span></span><br><span class="line">MAX-HEAP-<span class="constructor">INSERT(S, <span class="params">key</span>)</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>heap-size = <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>heap-size + <span class="number">1</span></span><br><span class="line">    A<span class="literal">[<span class="identifier">heap</span>-<span class="identifier">size</span>]</span> = -∞</span><br><span class="line">    HEAP-INCREASE-<span class="constructor">KEY(S, A.<span class="params">heap</span>-<span class="params">size</span>, <span class="params">key</span>)</span></span><br></pre></td></tr></table></figure> ## python实现 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UNDERFLOW</span>(<span class="params">Exception</span>):</span><span class="keyword">pass</span> <span class="comment"># 下溢</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OVERFLOW</span>(<span class="params">Exception</span>):</span><span class="keyword">pass</span> <span class="comment"># 上溢</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BADVALUE</span>(<span class="params">Exception</span>):</span> <span class="keyword">pass</span> <span class="comment">#错误的值</span></span><br><span class="line"><span class="comment"># 最大堆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        self.S = A[:]</span><br><span class="line">        self.size = self.heap_size = <span class="built_in">len</span>(A)</span><br><span class="line">        self._BUILD_MAX_HEAP()</span><br><span class="line">    </span><br><span class="line">    PARENT = <span class="keyword">lambda</span> self, i: i/<span class="number">2</span> <span class="comment">#获得i的父结点下标</span></span><br><span class="line">    LEFT = <span class="keyword">lambda</span> self, i: <span class="number">2</span>*i <span class="comment"># 获得i的左子树的根结点下标</span></span><br><span class="line">    RIGHT = <span class="keyword">lambda</span> self, i: <span class="number">2</span>*i+<span class="number">1</span> <span class="comment"># 获得i的右子树的根结点下标</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAPIFY</span>(<span class="params">self, i</span>):</span> <span class="comment"># 维护最大堆</span></span><br><span class="line">        left, right = self.LEFT(i), self.RIGHT(i)</span><br><span class="line">        largest = left <span class="keyword">if</span> left &lt; self.heap_size <span class="keyword">and</span> self.S[left] &gt; self.S[i] <span class="keyword">else</span> i</span><br><span class="line">        largest = right <span class="keyword">if</span> right &lt; self.heap_size <span class="keyword">and</span> self.S[right] &gt; self.S[largest] <span class="keyword">else</span> largest</span><br><span class="line">        <span class="keyword">if</span> largest != i:</span><br><span class="line">            self.S[i], self.S[largest] = self.S[largest], self.S[i]</span><br><span class="line">            self.MAX_HEAPIFY(largest)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_BUILD_MAX_HEAP</span>(<span class="params">self</span>):</span> <span class="comment"># 构建最大堆</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.PARENT(self.size-<span class="number">1</span>),-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            self.MAX_HEAPIFY(i)</span><br><span class="line">    <span class="comment"># 最大优先队列</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">INSERT</span>(<span class="params">self, key</span>):</span> <span class="comment"># 插入key到堆中</span></span><br><span class="line">        <span class="keyword">if</span> self.heap_size &gt;= self.size: <span class="keyword">raise</span> OVERFLOW(<span class="string">&quot;the heap is full&quot;</span>)</span><br><span class="line">        self.heap_size += <span class="number">1</span></span><br><span class="line">        self.S[self.heap_size-<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&#x27;-INF&#x27;</span>)</span><br><span class="line">        self.INCREASE_KEY(self.heap_size-<span class="number">1</span>, key)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MAXIMUM</span>(<span class="params">self</span>):</span> <span class="comment"># 获得堆中最大元素</span></span><br><span class="line">        <span class="keyword">return</span> self.S[<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EXTRACT_MAX</span>(<span class="params">self</span>):</span> <span class="comment"># 删除并返回堆中最大元素</span></span><br><span class="line">        <span class="keyword">if</span> self.heap_size &lt; <span class="number">1</span>: <span class="keyword">raise</span> UNDERFLOW(<span class="string">&quot;the heap is empty&quot;</span>)</span><br><span class="line">        <span class="built_in">max</span> = self.S[<span class="number">0</span>]</span><br><span class="line">        self.S[<span class="number">0</span>] = self.S[self.heap_size-<span class="number">1</span>]</span><br><span class="line">        self.heap_size -= <span class="number">1</span></span><br><span class="line">        self.MAX_HEAPIFY(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">INCREASE_KEY</span>(<span class="params">self, i, key</span>):</span> <span class="comment"># 将下标为i的值增加到key值，维护最大堆</span></span><br><span class="line">        <span class="keyword">if</span> self.S[i] &gt; key: <span class="keyword">raise</span> BADVALUE(<span class="string">&quot;new key is smaller than current key&quot;</span>)</span><br><span class="line">        self.S[i] = key</span><br><span class="line">        <span class="keyword">while</span> i&gt; <span class="number">0</span> <span class="keyword">and</span> self.S[i] &gt; self.S[self.PARENT(i)]:</span><br><span class="line">            self.S[i], self.S[self.PARENT(i)] = self.S[self.PARENT(i)], self.S[i]</span><br><span class="line">            i = self.PARENT(i)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>好物推荐|从HTML到markdown - html2text</title>
    <url>/2017/03/18/%E5%A5%BD%E7%89%A9%E6%8E%A8%E8%8D%90%EF%BC%9A%E4%BB%8EHTML%E5%88%B0markdown%20-%20html2text/</url>
    <content><![CDATA[<figure>
<img src="/img/599059083419276074.jpg" alt="西溪植物园饱满的蒲公英" /><figcaption aria-hidden="true">西溪植物园饱满的蒲公英</figcaption>
</figure>
<p>正题之前，先碎碎念几句。</p>
<p>Ele近来对系列文略感兴趣，因此准备开一个<code>好物推荐</code>的系列文，讲讲工作生活中用到的小而美的东东（可能是某些库，工具之类的）。算是雁过留痕，以备后续翻阅吧。</p>
<p>好啦，絮絮叨叨的话讲完了，我们进入正题吧。</p>
<p>话说这近一年来，Ele少数不多坚持下来的事情就是<a href="https://github.com/ictar/python-doc">python-doc</a>了。一开始仅仅是为了入门python顺便练练专业英语，虽然到后面有所懈怠，但是每周不翻一次<a href="http://us2.campaign-archive2.com/home/?u=e2e180baf855ac797ef407fc7&amp;id=9e26887fc5">Python Weekly</a>总觉得亏欠了谁什么似的。因为放在github上，所以当初选择了markdown作为文本格式。</p>
<p>但是，Ele翻的文章都是在网上找的，因此需要将HTML转成markdown。</p>
<p>一开始，Ele用的是在线的<a href="http://www.atool.org/html2markdown.php">HTML转MarkDown工具</a>。这个工具虽好，但是对我而言却有几个问题： * 每次都要打开文章，然后F12找到文章正文 * 对代码块的支持很差，转出来的markdown文本里面的代码块都是原生的HTML文本。所以转后还得对结果里面的代码块再一次进行处理 * 对每篇文章都得<strong>重复</strong>上面的过程</p>
<p>由于这个过程都是可重复的，因此，此时不自动化更待何时呢？本着造轮子之前先找找有没有轮子的精神，Ele在github上找到了库：<a href="https://github.com/aaronsw/html2text">aaronsw/html2text</a>。</p>
<p>这个库是用python写的，它可以把html文本转成干净易读的纯ASCII文本，并且文本是有效的markdown格式。</p>
<p>BINGO！！！github大法好~~</p>
<p>如果PyPi上搜<code>html2text</code>的话，找到的是另外一个库：<a href="https://github.com/Alir3z4/html2text/">Alir3z4/html2text</a>。这个库是从<a href="https://github.com/aaronsw/html2text">aaronsw/html2text</a> fork过来，并在此基础上对功能进行了扩展。因为Ele是直接用pip安装的，因此本文主要来讲讲这个库。</p>
<p>首先，进行安装： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install html2text</span><br></pre></td></tr></table></figure> ### 命令行方式使用<code>html2text</code></p>
<p>安装完后，就可以通过命令<code>html2text</code>进行一系列的操作了。</p>
<p><code>html2text</code>命令使用方式为：<code>html2text [(filename|url) [encoding]]</code>。通过<code>html2text -h</code>，我们可以查看该命令支持的选项：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--version</code></td>
<td>显示程序版本号并退出</td>
</tr>
<tr class="even">
<td><code>-h, --help</code></td>
<td>显示帮助信息并退出</td>
</tr>
<tr class="odd">
<td><code>--no-wrap-links</code></td>
<td>转换期间包装链接</td>
</tr>
<tr class="even">
<td><code>--ignore-emphasis</code></td>
<td>对于强调，不包含任何格式</td>
</tr>
<tr class="odd">
<td><code>--reference-links</code></td>
<td>使用参考样式的链接，而不是内联链接</td>
</tr>
<tr class="even">
<td><code>--ignore-links</code></td>
<td>对于链接，不包含任何格式</td>
</tr>
<tr class="odd">
<td><code>--protect-links</code></td>
<td>保护链接不换行，并用尖角括号将其围起来</td>
</tr>
<tr class="even">
<td><code>--ignore-images</code></td>
<td>对于图像，不包含任何格式</td>
</tr>
<tr class="odd">
<td><code>--images-to-alt</code></td>
<td>丢弃图像数据，只保留替换文本</td>
</tr>
<tr class="even">
<td><code>--images-with-size</code></td>
<td>将图像标签作为原生html，并带height和width属性，以保留维度</td>
</tr>
<tr class="odd">
<td><code>-g, --google-doc</code></td>
<td>转换一个被导出为html的谷歌文档</td>
</tr>
<tr class="even">
<td><code>-d, --dash-unordered-list</code></td>
<td>对于无序列表，使用破折号而不是星号</td>
</tr>
<tr class="odd">
<td><code>-e, --asterisk-emphasis</code></td>
<td>对于被强调文本，使用星号而不是下划线</td>
</tr>
<tr class="even">
<td><code>-b BODY_WIDTH, --body-width=BODY_WIDTH</code></td>
<td>每个输出行的字符数，0表示不自动换行</td>
</tr>
<tr class="odd">
<td><code>-i LIST_INDENT, --google-list-indent=LIST_INDENT</code></td>
<td>Google缩进嵌套列表的像素数</td>
</tr>
<tr class="even">
<td><code>-s, --hide-strikethrough</code></td>
<td>隐藏带删除线文本。只有当也指定-g的时候才有用</td>
</tr>
<tr class="odd">
<td><code>--escape-all</code></td>
<td>转义所有特殊字符。输出较为不可读，但是会避免极端情况下的格式化问题。</td>
</tr>
<tr class="even">
<td><code>--bypass-tables</code></td>
<td>以HTML格式格式化表单，而不是Markdown语法。</td>
</tr>
<tr class="odd">
<td><code>--single-line-break</code></td>
<td>在一个块元素后使用单个换行符，而不是两个换行符。注意：要求--body-width=0</td>
</tr>
<tr class="even">
<td><code>--unicode-snob</code></td>
<td>整个文档中都使用unicode</td>
</tr>
<tr class="odd">
<td><code>--no-automatic-links</code></td>
<td>在任何适用情况下，不要使用自动链接</td>
</tr>
<tr class="even">
<td><code>--no-skip-internal-links</code></td>
<td>不要跳过内部链接</td>
</tr>
<tr class="odd">
<td><code>--links-after-para</code></td>
<td>将链接置于每段之后而不是文档之后</td>
</tr>
<tr class="even">
<td><code>--mark-code</code></td>
<td>用[code]...[/code]将代码块标记出来</td>
</tr>
<tr class="odd">
<td><code>--decode-errors=DECODE_ERRORS</code></td>
<td>如何处理decode错误。接受值为'ignore', 'strict'和'replace'</td>
</tr>
</tbody>
</table>
<p>具体使用如下： <figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 传递url</span></span><br><span class="line">html2text http:<span class="comment">//eepurl.com/cK06Gn</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 传递文件名，编码方式设置为utf-8</span></span><br><span class="line">html2text test.html utf<span class="number">-8</span></span><br></pre></td></tr></table></figure> ### 脚本中使用<code>html2text</code> 除了直接通过命令行使用<code>html2text</code>外，我们还可以在脚本中将其作为库导入。</p>
<p>我们以以下html文本为例 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">html_content = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;span style=&quot;font-size:14px&quot;&gt;&lt;a href=&quot;http://blog.yhat.com/posts/visualize-nba-pipelines.html&quot; target=&quot;_blank&quot; style=&quot;color: #1173C7;text-decoration: underline;font-weight: bold;&quot;&gt;Data Wrangling 101: Using Python to Fetch, Manipulate &amp;amp; Visualize NBA Data&lt;/a&gt;&lt;/span&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">A tutorial using pandas and a few other packages to build a simple datapipe for getting NBA data. Even though this tutorial is done using NBA data, you don&#x27;t need to be an NBA fan to follow along. The same concepts and techniques can be applied to any project of your choosing.&lt;br&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure> 一句话转换html文本为Markdown格式的文本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> html2text</span><br><span class="line"><span class="built_in">print</span> html2text.html2text(html_content)</span><br></pre></td></tr></table></figure> 输出如下： <figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">[Data Wrangling <span class="number">101</span>: Using Python <span class="keyword">to</span> Fetch, Manipulate &amp;amp; Visualize NBA</span><br><span class="line">Data](http:<span class="comment">//blog.yhat.com/posts/visualize-nba-pipelines.html)  </span></span><br><span class="line">A tutorial using pandas <span class="keyword">and</span> a few other packages <span class="keyword">to</span> build a simple datapipe</span><br><span class="line"><span class="keyword">for</span> getting NBA data. Even though this tutorial is <span class="keyword">done</span> using NBA data, you</span><br><span class="line">don&#x27;t need <span class="keyword">to</span> be an NBA fan <span class="keyword">to</span> follow along. The same concepts <span class="keyword">and</span> techniques</span><br><span class="line">can be applied <span class="keyword">to</span> any project <span class="keyword">of</span> your choosing.  </span><br></pre></td></tr></table></figure> 另外，还可以使用上面的配置项： <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">import</span> html<span class="number">2</span>text</span><br><span class="line"><span class="attribute">h</span> = html<span class="number">2</span>text.HTML<span class="number">2</span>Text()</span><br><span class="line"><span class="attribute">print</span> h.handle(html_content) # 输出同上</span><br></pre></td></tr></table></figure> &gt; 注意：下面仅展示使用某个配置项时的输出，不使用某个配置项时使用默认值的输出（如无特殊说明）同上。</p>
<ul>
<li><p><code>--ignore-emphasis</code></p>
<ul>
<li>指定选项--ignore-emphasis <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h.ignore_emphasis = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span> h.handle(<span class="string">&quot;&lt;p&gt;hello, this is &lt;em&gt;Ele&lt;/em&gt;&lt;/p&gt;&quot;</span>)</span><br></pre></td></tr></table></figure> 输出为： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">hello, <span class="keyword">this</span> <span class="keyword">is</span> Ele </span><br></pre></td></tr></table></figure></li>
<li>不指定选项--ignore-emphasis <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h.ignore_emphasis = <span class="literal">False</span> <span class="comment"># 默认值</span></span><br><span class="line"><span class="built_in">print</span> h.handle(<span class="string">&quot;&lt;p&gt;hello, this is &lt;em&gt;Ele&lt;/em&gt;&lt;/p&gt;&quot;</span>)</span><br></pre></td></tr></table></figure> 输出为： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">hello, <span class="keyword">this</span> <span class="keyword">is</span> _Ele_</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><code>--reference-links</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h.inline_links = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span> h.handle(html_content)</span><br></pre></td></tr></table></figure> 输出为： <figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">[Data Wrangling <span class="number">101</span>: Using Python <span class="keyword">to</span> Fetch, Manipulate &amp;amp; Visualize NBA</span><br><span class="line">Data][<span class="number">16</span>]  </span><br><span class="line">A tutorial using pandas <span class="keyword">and</span> a few other packages <span class="keyword">to</span> build a simple datapipe</span><br><span class="line"><span class="keyword">for</span> getting NBA data. Even though this tutorial is <span class="keyword">done</span> using NBA data, you</span><br><span class="line">don&#x27;t need <span class="keyword">to</span> be an NBA fan <span class="keyword">to</span> follow along. The same concepts <span class="keyword">and</span> techniques</span><br><span class="line">can be applied <span class="keyword">to</span> any project <span class="keyword">of</span> your choosing.  </span><br><span class="line"></span><br><span class="line">   [<span class="number">16</span>]: http:<span class="comment">//blog.yhat.com/posts/visualize-nba-pipelines.html</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>--ignore-links</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h.ignore_links = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span> h.handle(html_content)</span><br></pre></td></tr></table></figure> 输出为： <figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">Data Wrangling <span class="number">101</span>: <span class="keyword">Using</span> Python <span class="keyword">to</span> Fetch, Manipulate &amp;amp; Visualize NBA Data  </span><br><span class="line">A tutorial <span class="keyword">using</span> pandas <span class="built_in">and</span> a few other packages <span class="keyword">to</span> build a simple datapipe</span><br><span class="line"><span class="keyword">for</span> getting NBA data. Even though this tutorial <span class="built_in">is</span> done <span class="keyword">using</span> NBA data, you</span><br><span class="line">don<span class="comment">&#x27;t need to be an NBA fan to follow along. The same concepts and techniques</span></span><br><span class="line">can be applied <span class="keyword">to</span> any project <span class="keyword">of</span> your choosing.  </span><br></pre></td></tr></table></figure></p></li>
<li><p><code>--protect-links</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h.protect_links = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span> h.handle(html_content)</span><br></pre></td></tr></table></figure> 输出为： <figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">[Data Wrangling <span class="number">101</span>: Using Python <span class="keyword">to</span> Fetch, Manipulate &amp;amp; Visualize NBA</span><br><span class="line">Data](&lt;http:<span class="comment">//blog.yhat.com/posts/visualize-nba-pipelines.html&gt;)  </span></span><br><span class="line">A tutorial using pandas <span class="keyword">and</span> a few other packages <span class="keyword">to</span> build a simple datapipe</span><br><span class="line"><span class="keyword">for</span> getting NBA data. Even though this tutorial is <span class="keyword">done</span> using NBA data, you</span><br><span class="line">don&#x27;t need <span class="keyword">to</span> be an NBA fan <span class="keyword">to</span> follow along. The same concepts <span class="keyword">and</span> techniques</span><br><span class="line">can be applied <span class="keyword">to</span> any project <span class="keyword">of</span> your choosing.  </span><br></pre></td></tr></table></figure></p></li>
<li><p><code>--ignore-images</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h.ignore_images = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span> h.handle(<span class="string">&#x27;&lt;p&gt;This is a img: &lt;img src=&quot;https://my.oschina.net/img/hot3.png&quot; style=&quot;max-height: 32px; max-width: 32px;&quot; alt=&quot;hot3&quot;&gt; ending ...&lt;/p&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure> 输出为： <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">This <span class="keyword">is</span> <span class="keyword">a</span> <span class="keyword">im</span><span class="variable">g:</span>  ending ...</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>--images-to-alt</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h.images_to_alt = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span> h.handle(<span class="string">&#x27;&lt;p&gt;This is a img: &lt;img src=&quot;https://my.oschina.net/img/hot3.png&quot; style=&quot;max-height: 32px; max-width: 32px;&quot; alt=&quot;hot3&quot;&gt; ending ...&lt;/p&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure> 输出为： <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">This <span class="keyword">is</span> <span class="keyword">a</span> <span class="keyword">im</span><span class="variable">g:</span> hot3 ending ...</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>--images-with-size</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h.images_with_size = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span> h.handle(<span class="string">&#x27;&lt;p&gt;This is a img: &lt;img src=&quot;https://my.oschina.net/img/hot3.png&quot; height=32px width=32px alt=&quot;hot3&quot;&gt; ending ...&lt;/p&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure> 输出为： <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">This is a img: &lt;img <span class="attribute">src</span>=<span class="string">&#x27;https://my.oschina.net/img/hot3.png&#x27;</span> <span class="attribute">width</span>=<span class="string">&#x27;32px&#x27;</span></span><br><span class="line"><span class="attribute">height</span>=<span class="string">&#x27;32px&#x27;</span> <span class="attribute">alt</span>=<span class="string">&#x27;hot3&#x27;</span> /&gt; ending <span class="built_in">..</span>.</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>--body-width</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h.body_width=<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span> h.handle(html_content)</span><br></pre></td></tr></table></figure> 输出为： <figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">[Data Wrangling <span class="number">101</span>: Using Python <span class="keyword">to</span> Fetch, Manipulate &amp;amp; Visualize NBA Data](http:<span class="comment">//blog.yhat.com/posts/visualize-nba-pipelines.html)  </span></span><br><span class="line">A tutorial using pandas <span class="keyword">and</span> a few other packages <span class="keyword">to</span> build a simple datapipe <span class="keyword">for</span> getting NBA data. Even though this tutorial is <span class="keyword">done</span> using NBA data, you don&#x27;t need <span class="keyword">to</span> be an NBA fan <span class="keyword">to</span> follow along. The same concepts <span class="keyword">and</span> techniques can be applied <span class="keyword">to</span> any project <span class="keyword">of</span> your choosing.  </span><br></pre></td></tr></table></figure></p></li>
<li><p><code>--mark-code</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h.mark_code=<span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span> h.handle(<span class="string">&#x27;&lt;pre class=&quot;hljs css&quot;&gt;&lt;code class=&quot;hljs css&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;rpm&lt;/span&gt;&lt;/span&gt;&amp;nbsp;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;-Uvh&lt;/span&gt;&lt;/span&gt;&amp;nbsp;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;erlang-solutions-1&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.0-1&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.noarch&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.rpm&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure> 输出为： <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[code]</span></span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">rpm</span> <span class="selector-tag">-Uvh</span> <span class="selector-tag">erlang-solutions-1</span>.0<span class="selector-tag">-1</span><span class="selector-class">.noarch</span><span class="selector-class">.rpm</span></span><br><span class="line"><span class="selector-attr">[/code]</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>通过这种方式，就可以以脚本的形式自定义HTML -&gt; MARKDOWN的自动化过程了。例子可参考<a href="https://github.com/ictar/Gadgets/blob/master/pw2md.py">pw2md</a>，这是一个每周跑一次的python weekly转markdown的脚本。</p>
<p>好啦，html2text就介绍到这里了。如果觉得它还不能满足你的要求，或者想添加更多的功能，可以fork并自行修改。</p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>好物推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>小爬虫之下载豆瓣文章</title>
    <url>/2013/10/14/%E5%B0%8F%E7%88%AC%E8%99%AB%E4%B9%8B%E4%B8%8B%E8%BD%BD%E8%B1%86%E7%93%A3%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>这个小东西来源于某一天我浏览豆瓣的一个养生帖子，然后突发奇想，想把所有养生的东西下载下来。于是想到了用python写个小爬虫</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取html页面内容</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHtml</span>(<span class="params">url</span>):</span></span><br><span class="line"></span><br><span class="line">    page = urllib.urlopen(url)</span><br><span class="line"></span><br><span class="line">    html = page.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将html中满足pattern的内容找出，写入filePath中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getContent</span>(<span class="params">html,pattern,filePath=<span class="string">&quot;1.txt&quot;</span></span>):</span></span><br><span class="line"></span><br><span class="line">    contentre = re.<span class="built_in">compile</span>(pattern)</span><br><span class="line"></span><br><span class="line">    contentList = re.findall(contentre,html)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> contentList:</span><br><span class="line"></span><br><span class="line">        i = i.replace(<span class="string">&quot;&lt;br/&gt;&quot;</span>, <span class="string">&quot;\n&quot;</span>) <span class="comment">#这里由于写入txt文件，所以要做个字符替换</span></span><br><span class="line"></span><br><span class="line">        i = i + <span class="string">&quot;\n\n***********************************************************\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#write into xx file</span></span><br><span class="line"></span><br><span class="line">        writeFile(i,filePath)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将content以追加的形式写入filePath</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeFile</span>(<span class="params">content, filePath</span>):</span></span><br><span class="line"></span><br><span class="line">    output = <span class="built_in">open</span>(filePath, <span class="string">&quot;a+&quot;</span>)</span><br><span class="line"></span><br><span class="line">    output.writelines(content)</span><br><span class="line"></span><br><span class="line">    output.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#要爬的内容不只一页哦，所以这个函数是从html中获取下一页的地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNext</span>(<span class="params">html,pattern</span>):</span></span><br><span class="line"></span><br><span class="line">    nre = re.<span class="built_in">compile</span>(pattern)</span><br><span class="line"></span><br><span class="line">    nt = re.findall(nre,html)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#这个url就是要爬的网址，可以替换成任意想要的网址</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.douban.com//group//topic//5480779//?author=1#sep&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这个pattern和nextPage都是查看网页源代码中发现的内容和下一页地址的格式，可以用正则表达式获取相应的内容</span></span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&#x27;&lt;p class=&quot;&quot;&gt;(.*?)&lt;/p&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">nextPage = <span class="string">r&#x27;&lt;link rel=&quot;next&quot; href=&quot;(.*?)&quot;/&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    html = getHtml(url)</span><br><span class="line"></span><br><span class="line">    getContent(html, pattern,<span class="string">&quot;forHealth.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    has = getNext(html,nextPage) <span class="comment">#若下一页地址为空，则记得退出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> == <span class="built_in">len</span>(has):</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Finish!&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    url = has[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>后面的话：其实这个东西可以扩展应用下，用来下载想要的图片呀，小说呀，视频神马的，只要查看网页源代码，找到所在内容的前后格式，用正则表达式抠出来就可以了。我比较懒，经常在没网络的地方玩，因此想下载点东西可以离线看看，所以这个小东西对我还是挺有用的……</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>我在华为的两三事(一)</title>
    <url>/2015/11/19/%E6%88%91%E5%9C%A8%E5%8D%8E%E4%B8%BA%E7%9A%84%E4%B8%A4%E4%B8%89%E4%BA%8B(%E4%B8%80)/</url>
    <content><![CDATA[<p>从2013年8月，到2015年11月，在华为也待了两年有余。</p>
<p>大队培训完就被分到了华为的电信软件部门。虽然自己对通信并不感冒，但也傻傻的不会要求调岗，便从0开始接触运营商相关的东西。</p>
<p>所在的产品中文名可以叫做服务开通，顾名思义就是为用户订购产品的一个中间件，做协议转换。上与CRM(Customer Relationship Management)、CBS等进行交互，接受用户信息变更及订购关系变更请求，细分业务逻辑，下发命令到core network(例如HLR, VMS等)进行相关操作。 产品又分为PDU和SDU。PDU负责平台开发，SDU负责业务定制，在平台的基础上进行二次开发。我呢，属于产品SDU团队的一员。因为产品不大，也相对已经成熟了，团队（包括印研所）五十多个人，负责海外近百个局点的调研、需求分析、开发、测试、交付上线及后期维护和需求承接。 此为背景。</p>
<p>接触的第一个局点是坦桑尼亚Z<em>平台版本升级带来的业务版本的全新开发。同时，还承接了沙特B</em>和马来M<em>产品的维护工作。于是，在熟悉产品开发模式、维护工作和间歇性解决问题的过程中，度过了我六个月的试用期。 回想那段时间，坦桑尼亚Z</em>的开发过程中有deadline转测试的压力，有因为不熟悉导致频频被测试诘问。维护沙特B<em>和马来M</em>的时候，有一段时间一看到英文邮件就头疼。在同事维护期间安静的像个乖小孩的沙特B<em>到了我负责的时候就变成了熊孩子，隔三差五要出个小问题。2014年春节前夕，因为马来M</em>突然异常差点回不了家过年。 但是呢，坦桑尼亚Z<em>在多方协商下终于在今年5月份上线成功。因为马来M</em>，我认识了一些可爱的人，频频邀请我到马来西亚玩。</p>
<p>转正没多久，由于负责需求分析的同事休产假，负责开发交付的同事跑到现场出差去了，我接下了在这两年多里占据极大位置的项目：埃塞俄比亚电信全网扩容项目。 那时真是年少不懂事，但是很多事真的就是在一念之间。 当时的我，对开发维护还一知半解，CRM/CBS/HLR是干什么还停留在认识缩写的阶段，更别说对整个电信业务流程的了解，大概LM觉得有压力才能更快的成长，而且有整个项目组那么多有经验的同事的加持不会出啥大问题。又或者是有经验的同事一眼看出了这个项目到处都是坑所以没人愿意接，只有我傻乎乎的往里面跳还不自知。总而言之，一下子，本来只想做做此项目的开发的我，一下子变成了它的需求分析和开发的负责人。突然发现，很多变化都是因为出生牛犊不怕虎敢于尝试带来的。</p>
<p>接下这个项目没多久，就碰到了一个问题。因为我们产品在这个项目中的位置是替换掉Z//的服务开通，而Z//的服务开通是需要跟Z//的CDMA网络进行交互的，意味着我们产品也需要跟Z//的CDMA网络中的三个产品进行交互。而由于某些原因，这三个产品只有两个产品有残缺对不上版本号的接口文档。加之项目组从未有与这三个产品交互的经验，因此，等到拿到Z//的服务开通和这三个产品的交互抓包信息的时候一看到都是非MML的socket交互的时候，大家都束手无措。 当时的我，内心是崩溃的。其他人可以说爱莫能助，因为项目不是他们负责的。但是我不行。虽然我也无能为力，但是直接跟上级说搞不定然后就不搞了这是不现实的。 因此，在某一天，我终于鼓起勇气打开了其中一个产品残缺的接口文档和对应的又臭又长的binary socket包。一看，接口文档里满篇的C结构和接口定义。幸好C的基础还没丢。于是我把所有的C结构和接口整理到VS中，用debug模式看结构信息，居然被我发现了如何解析交互信息。而另一个没有任何接口文档的产品呢，则是根据它偶尔出现的ASCII显示进行分割、计算、猜测和验证。现在说着轻巧简单，但是当时天天盯着一堆的十六进制着实苦不堪言。幸好，Ele是个幸运的小孩。 然后就是交互接口开发，闲暇的时候看看项目的总方案了解业务流程，跟调研的同事沟通内部逻辑。渐渐的，需求分析的工作也顺手起来。</p>
<p>后来，因为现场交付上线迫在眉睫，需要人去出差的时候，我虽有些许犹豫，最后还是决定同意去埃塞尔比亚。因为我想看看我的分析、我的开发是否正确。当然，也有私心，毕竟还木有出过国，虽然去的是大非洲，而当时埃博拉肆虐。 在埃塞尔比亚的那近三个月的时间，很累。天天上班，时常晚上工作到一两点，昼夜温差大所以一到晚上就冷的要死，风沙大而且空气不好。但是却收获颇丰。在那里，我终于了解了一整套电信流程，从一个用户到营业厅开户到订购套餐到扣费到其他停复机等操作，这么长的一段时间内我的工作终于找到了意义，跟现实接了轨。当我拿着一张只有IMSI的空卡开了户定了业务打通第一个电话的时候我是喜悦的。当我挨个挨个的尝试不同的业务，呼叫转移、停机、换卡、三方通话，等等等等，那些原来只存在文档中的冰冷的文字变得生动起来。当我尝试对接CDMA网络，看着返回成功的那一刻，我激动的想跳舞，这说明了那些一遍又一遍查看解析数据包的日子并不是徒劳无功。项目里的人都在一起，为了同一个目标在努力。那些日子，忙绿却相当充实。哦，我想我还会想念那里的strawberry juice和mixed，想念那里大大小小的中国餐厅，想念那里的咖啡和在tomoca悠闲的喝着咖啡的日子。 埃塞之后，再无埃塞。 我几乎包办了产品在这个项目的需求分析、开发、测试、交付和问题处理，以及偶尔的人力预算分析。经过那些日子的洗礼，那个一无所知的小女孩也可以在别人需要帮助的时候出现在旁边，那些对从前的我来说晦涩难懂的东西也变得开明易懂起来，跟别人沟通也不再是一件艰难的事。而我的眼界也慢慢的放开。</p>
<p>回国之后，可能是LM觉得我已经可以跳出单纯的coding工作。我开始接手新项目的调研，从无到有的写需求规格文档。</p>
<p>如果以后的以后，有机会到相关国家，一定要用自己做过的项目的运营商的移动电话卡，因为自己曾经，为此，做过努力。</p>
]]></content>
      <categories>
        <category>这就是生活</category>
      </categories>
      <tags>
        <tag>经历</tag>
      </tags>
  </entry>
  <entry>
    <title>再谈自动打卡之自动化浏览器操作小利器：splinter</title>
    <url>/2017/03/04/%E5%86%8D%E8%B0%88%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8F%E8%A7%88%E5%99%A8%E6%93%8D%E4%BD%9C%E5%B0%8F%E5%88%A9%E5%99%A8%EF%BC%9Asplinter/</url>
    <content><![CDATA[<p>去年Ele练手弄了一个<a href="https://github.com/ictar/daka">repo</a>，玩了几个网站的登录和打卡功能之后就把这个小东东扔到香蕉派上，一并加入cron套餐。之后就没再理之。</p>
<p>小东西好好地跑了几个月，之后的某一天登上去看日志，发现好几个网站的自动登录和打卡都error了，懵逼之下跑到那些个网站上一看，哎呀，改版变规则什么的，就是辣么任性/(ㄒoㄒ)/~~</p>
<p>所以只能重写了。但是重写并非分分钟的事情（过程见<a href="/2015/09/26/%5BPython%5D沪江部落自动登录打卡/">[Python]沪江部落自动登录打卡</a>)，懒癌犯了的Ele就暂时这样LET IT GO了。</p>
<p>之后这个repo居然陆陆续续有人star，这引发了Ele的羞耻心，毕竟，坑人是不对的不对的不对的！！！又后来，懒惰的Ele看到了selenium，再然后又看到了splinter，正如干柴遇上了烈火（貌似有什么不对的东西混进来了O__O "…）</p>
<p>此为前因。</p>
<p><a href="https://splinter.readthedocs.io/en/latest/">splinter</a>是Python系用来测试web应用的一个工具，允许你自动化浏览器操作，例如访问URL，与页面元素进行交互等。</p>
<p>因此，我们可以用它来模拟登陆过程（输入用户名密码，点击登陆）和打卡（直接访问URL或者点击打卡按钮）过程，而后面的JavaScript等一系列点击响应事件则交给splinter处理，而无需像之前那样操心网络层面与服务器端是如何交互的。</p>
<blockquote>
<p>为了和前面手解登录和打卡作对比，此次仍然以沪江部落为例</p>
</blockquote>
<h3 id="准备">准备</h3>
<ol type="1">
<li>使用pip安装splinter包： <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> splinter</span><br></pre></td></tr></table></figure></li>
<li>浏览器准备</li>
</ol>
<ul>
<li>如果使用firefox，则需要下载<a href="https://github.com/mozilla/geckodriver/releases">geckodriver</a>，并将其解压到PATH可以找到的目录中。否则，运行时会出现错误：<code>Selenium.common.exceptions.WebDriverException: Message: 'geckodriver' executable needs to be in PATH.</code></li>
<li>如果使用chrome，则除了要安装chrome浏览器外，还需要下载<a href="https://sites.google.com/a/chromium.org/chromedriver/downloads">chromedriver</a>并解压。我们这里以chrome为例，将chromedriver解压缩到<code>/Users/elexu/Downloads</code>下。</li>
</ul>
<p>准备好了，我们先来讲讲如何模拟登陆</p>
<h3 id="登陆">登陆</h3>
<p>我们先来看看一般手动登录过程。</p>
<p>从浏览器访问<code>http://www.hjenglish.com/</code>，可以看到右上角有个<strong>登录</strong>按钮。点击<strong>登录</strong>按钮后，在弹出的登录框里填入正确的用户名密码，点击绿色的登录按钮。等待片刻即可登录成功。</p>
<p>现在，我们来看看，如何使用splinter来实现这一过程。</p>
<p>首先，我们要初始化一个Browser实例： <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> splinter <span class="keyword">import</span> Browser</span><br><span class="line">b = Browser(driver_name = <span class="string">&quot;chrome&quot;</span>, executable_path = <span class="string">&quot;/Users/elexu/Downloads/chromedriver&quot;</span>)</span><br></pre></td></tr></table></figure> 此时，我们可以看到一个新的chrome窗口弹出。接下来，我们需要访问沪江部落，然后让登录框弹出。</p>
<p>打开chrome的开发者工具，审查<strong>登录</strong>按钮。</p>
<p><img src="/img/login_inspect_20170307.png" /></p>
<p>为了让登录框弹出，我们需要定位到这个元素，然后点击一下。splinter提供了多种查找元素的方法，例如，css, xpath, tag, id, name等。我们现在来看看如何根据上面的图来找到这个登录按钮，并完成点击操作：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 访问网站</span></span><br><span class="line">b.visit(<span class="string">&quot;http://www.hjenglish.com/&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">b.find_by_xpath(<span class="string">&#x27;//*[@id=&quot;passport_userinfo&quot;]/li[1]/a[1]&#x27;</span>).first.click()</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>这里有几点说明： - 这里需要sleep一段时间，使得页面可以完全加载完毕，否则有可能在查找元素的时候，想查找的元素还未加载出来，从而导致查找不到元素。同理，点击完后，也要有一定的时间供给页面加载 - 使用Browser实例哪一个find_by_xxx方法就看元素如何是如何写的。像上面用下标定位出来的，万一页面元素发生了变动，就会失效了。如果元素可以直接通过name/id来定位，首选find_by_name和find_by_id - find_by_xpath方法返回的是一个<code>splinter.element_list.ElementList</code>实例。我们可以直接在这个实例上调用<code>click</code>方法进行点击，也可以像上面代码那样，找到定位到的第一个元素，再调用<code>click</code>方法。</p>
<p>现在，从浏览器上可以看到，登录框已经弹出来了。接下来就是依葫芦画瓢找到用户名密码所在的输入框，填充值，然后点击登录按钮。 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">b.fill(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;ele&quot;</span>)</span><br><span class="line">b.fill(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;xxxxxx&quot;</span>)</span><br><span class="line">b.find_by_xpath(<span class="string">&#x27;//*[@id=&quot;hp-login-normal&quot;]/button&#x27;</span>).click()</span><br></pre></td></tr></table></figure> Browser()实例的<code>fill(name, value)</code>方法的作用是用参数<code>value</code>的内容填充由<code>name</code>标识的域。运行上面代码，我们可以在打开的浏览器上看到，用户名密码输入框中迅速地填充了我们指定的值，然后在click操作后，成功登录。一切都跟我们手工登录过程一毛一样。</p>
<h3 id="打卡">打卡</h3>
<p>打开部落个人home页面，然后审查右上角的打卡按钮 <img src="/img/2017-03-08_100223.jpg" /></p>
<p>我们要做的很简单，只要点击这个按钮即可</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">bulo_home = <span class="string">&quot;http://bulo.hujiang.com/home&quot;</span></span><br><span class="line">b.visit(bulo_home)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> b.is_element_present_by_id(<span class="string">&quot;btn_card_do&quot;</span>):</span><br><span class="line">    <span class="comment">#b.execute_script(&quot;$(btn_card_do).attr(&#x27;style&#x27;,&#x27;z-index:99999;display:block;position:absolute;&#x27;)&quot;)</span></span><br><span class="line">    b.find_by_id(<span class="string">&quot;btn_card_do&quot;</span>).first.click()</span><br></pre></td></tr></table></figure>
<p>代码很直观，但是有几点说明： - 供给页面加载时间还是需要的，这里我们选择了3s。其实可以不用那么长，这个可以自己调整 - Browser()实例也提供了多种is_element_present_by_xxx方法，可以来检测当前页面是否存在某个元素。这里我们需要检测下页面是否有打卡按钮，如果没有，就不用点了。</p>
<p>运行一下，程序抛异常： <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="attr">ElementNotVisibleException:</span> <span class="attr">Message:</span> element not visible</span><br></pre></td></tr></table></figure> 跑到页面上一看，才发现打卡按钮被大大的div遮住了。因此，我们需要通过一些手段将button展示出来。比方说修改元素的css。Browser()实例提供了execute_script()方法，可以用来执行javascript代码。将上面注释掉的那行代码的注释取消掉，再运行一下就发现OK了。</p>
<p>这是一种方法。当然，我们还可以利用<a href="/2015/09/26/%5BPython%5D沪江部落自动登录打卡/">[Python]沪江部落自动登录打卡</a>中找到的url，直接访问，进行打卡 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">SIGN_URL = <span class="string">&quot;http://bulo.hujiang.com/app/api/ajax_take_card.ashx?%.17f&quot;</span>%random.random()</span><br><span class="line">b.visit(SIGN_URL)</span><br></pre></td></tr></table></figure> ### 碎碎念 先来说说这种方法的优点。</p>
<p>通过splinter，实现模拟人与浏览器的互动，写代码的人完全就不用管底层是怎么跟对端服务器进行交互的。通过splinter封装的API，基本可以满足所需的浏览器操作。简直就是懒人常备小利器。</p>
<p>另外，很多时候，网站变更是隐藏在背后的，大多数让用户无感知。因此，不管底层逻辑怎么变更，只要打开看到的页面没有变动，这一套自动登录打卡便行之有效。免去了代码的频繁变更以适应新的网站逻辑。</p>
<p>于是，懒惰的Ele分分钟就把<a href="https://github.com/ictar/daka">daka</a>全部迁成splinter实现了~</p>
<p>当然，这种方法知其然而不知其所以然，一点都不geek。另外，对那些想要通过了解机制来学到点什么的小伙伴来说，最好还是跟自己死磕一下，老老实实抓包看代码吧。</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://splinter.readthedocs.io/en/latest/">splinter官方文档</a></li>
<li><a href="/2015/09/26/%5BPython%5D沪江部落自动登录打卡/">[Python]沪江部落自动登录打卡</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用 go 实现超时控制</title>
    <url>/2018/03/20/%E5%A6%82%E4%BD%95%E7%94%A8go%E5%AE%9E%E7%8E%B0%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>在实现一些服务的过程中，我们需要对内部处理时间进行控制，以防客户端一直在等待响应。</p>
<h3 id="select-case-实现的超时控制">select-case 实现的超时控制</h3>
<p>在 go 中，利用 select + case + time 包，就可以很轻松实现超时控制。我们修改<a href="https://gobyexample.com/timeouts">Go by Example: Timeouts</a>中的一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		fmt.Println(<span class="string">&quot;get result 1&quot;</span>)</span><br><span class="line">        c1 &lt;- <span class="string">&quot;result 1&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c1:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		fmt.Println(<span class="string">&quot;get result 2&quot;</span>)</span><br><span class="line">        c2 &lt;- <span class="string">&quot;result 2&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，从第 10 到第 22 行，我们创建了一个大小为 1 的 channel <code>c1</code>，然后创建一个 goroutine。在这个 goroutine 中，等待 2 秒后，打印日志，并发送一条消息到 channel <code>c1</code> 中。接着，我们利用 select-case 实现超时时间为 1 秒的超时控制。在第一个 <code>case</code> 中，等待来自 <code>c1</code> 的消息，并将此消息打印出来。在第二个 <code>case</code> 中，利用 <code>time</code> 包的 <code>After</code> 方法（这个方法在指定的时间间隔后，发送当前时间到返回的 channel 中），等待 1 秒后打印超时信息。</p>
<p>从第 24 到第 35 行，我们创建了另一个大小为 2 的 channel <code>c2</code>，然后创建另一个 goroutine。在这个 goroutine 中，同样等待 2 秒后打印日志，并发送一条消息到 channel <code>c2</code> 中。接着，利用另一个 select-case 实现超时时间为 3 秒的超时控制。在第一个 <code>case</code> 中，等待来自 <code>c1</code> 的消息，并将此消息打印出来。在第二个 <code>case</code> 中，利用 <code>time</code> 包的 <code>After</code> 方法，等待 3 秒后打印超时信息。</p>
<p><a href="https://play.golang.org/p/jBu2W6gBss0">运行</a>得到输出如下： <figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">timeout</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">get</span> <span class="literal">result</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">get</span> <span class="literal">result</span> <span class="number">2</span></span><br><span class="line"><span class="literal">result</span> <span class="number">2</span></span><br></pre></td></tr></table></figure> ### 超时传播 从上面的例子的输出，我们会发现，第一个 goroutine 并没有在 1 秒超时后结束，而是完整地执行了整个方法。这是不彻底的超时控制，有可能影响后续的处理。为了更清楚地看出这个问题，我们稍微修改下上面的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	mutex sync.Mutex</span><br><span class="line">	id    <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dosomething</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	id = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			dosomething(i)</span><br><span class="line">			done &lt;-<span class="literal">true</span></span><br><span class="line">		&#125;(i)</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> res := &lt;-done:</span><br><span class="line">			fmt.Println(time.Now(), res, id)</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(time.Duration(i) * time.Second):</span><br><span class="line">			fmt.Println(time.Now(), <span class="string">&quot;timeout &quot;</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，从第 10 到 13 行，我们声明了一个类型为 <code>Mutext</code> 的全局锁 <code>mutex</code> 和一个全局变量 <code>id</code>。前者用以解决后者的同步写冲突。接下来的第 15 到 21 行，定义了一个函数 <code>dosomething</code>，这个函数等待 1 秒后对变量 <code>id</code> 进行设值。</p>
<p>程序主入口处，我们依次创建 3 个 goroutine，每个 goroutine 都调用了 <code>dosomething</code> 函数进行设值。函数执行结束后，通过外部的 channel <code>done</code> 来通知调用者。接下来，在第 31 到 36 行，利用 select-case 进行超时控制，超时时间为当前索引指定的秒数。为了更清楚地看出耗时，我们在日志打印中加上了时间打印。</p>
<p><a href="https://play.golang.org/p/Aj8Y3kvJCHI">运行</a>会发现，第 2 个请求因为第 1 个请求尚未返回导致没有释放锁，从而超时。而接下来的第 3 个请求也因为同样的原因超时了： <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2009</span>-<span class="number">11</span>-<span class="number">10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> +<span class="number">0000</span> UTC m=+<span class="number">0</span>.<span class="number">000000001</span> timeout  <span class="number">0</span></span><br><span class="line"><span class="attribute">2009</span>-<span class="number">11</span>-<span class="number">10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">01</span> +<span class="number">0000</span> UTC m=+<span class="number">1</span>.<span class="number">000000001</span> timeout  <span class="number">1</span></span><br><span class="line"><span class="attribute">2009</span>-<span class="number">11</span>-<span class="number">10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">03</span> +<span class="number">0000</span> UTC m=+<span class="number">3</span>.<span class="number">000000001</span> timeout  <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="加上-context-如何">加上 <code>context</code> 如何？</h3>
<p>在上面的例子中，上次请求超时对下次请求，甚至是下下次请求会发生影响。而这种影响是可以减轻或者避免的。我们可以使用 <a href="https://golang.org/pkg/context/">context</a> 包来处理这种问题。</p>
<p><code>context</code> 中有两个方法： * <code>func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)</code>：返回参数 <code>parent</code> 的一个拷贝，并且调整该拷贝的截止时间至不超过 <code>d</code> 指定的时间。如果 <code>parent</code> 的截止时间比 <code>d</code> 早，那么该拷贝语义上等同于 <code>parent</code>。当截止时间过期时，或者调用了返回的 <code>CancelFunc</code>，又或者 <code>parent</code> 的 <code>Done</code> channel 被关闭了，这三种情况之一发生了，返回的 context 的 Done channel 就会被关闭。注意，关闭该 context 会释放其相关资源，因此，只要在这个 context 上的操作完成了，就必须立即调用 <code>CancelFunc</code>。 * <code>func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</code>：返回 <code>WithDeadline(parent, time.Now().Add(timeout))</code></p>
<p>现在，我们使用 <code>WithTimeout</code> 方法来改进上面的例子。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	mutex sync.Mutex</span><br><span class="line">	id    <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dosomething</span><span class="params">(ctx context.Context, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">		fmt.Println(time.Now(), <span class="string">&quot;op timeout&quot;</span>, val)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">//....</span></span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		id = val</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			ctx, cancel := context.WithTimeout(context.Background(), time.Duration(i) * time.Second)</span><br><span class="line">			<span class="keyword">defer</span> cancel()</span><br><span class="line">			dosomething(ctx, i)</span><br><span class="line">			done &lt;-<span class="literal">true</span></span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> res := &lt;-done:</span><br><span class="line">			fmt.Println(time.Now(), res, id)</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(time.Duration(i) * time.Second):</span><br><span class="line">			fmt.Println(time.Now(), <span class="string">&quot;timeout &quot;</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在第 15 行至 28 行，我们修改 <code>dosomething</code> 的函数签名，将 <code>context.Context</code> 类型的参数作为函数的第一个参数。然后，在该函数中，利用 select-case 和这个参数的 <code>Done</code> 方法来判断是否退出。在第 35 行到第 37 行，调用 <code>context.WithTimeout</code> 方法创建一个 <code>context.Context</code> 对象，超时时间为该 goroutine 的超时时间。然后将其传给 <code>dosomething</code> 函数。</p>
<p><a href="https://play.golang.org/p/GZbs7QCCCbQ">运行</a>得到以下输出： <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2009</span>-<span class="number">11</span>-<span class="number">10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> +<span class="number">0000</span> UTC m=+<span class="number">0</span>.<span class="number">000000001</span> timeout  <span class="number">0</span></span><br><span class="line"><span class="attribute">2009</span>-<span class="number">11</span>-<span class="number">10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">01</span> +<span class="number">0000</span> UTC m=+<span class="number">1</span>.<span class="number">000000001</span> timeout  <span class="number">1</span></span><br><span class="line"><span class="attribute">2009</span>-<span class="number">11</span>-<span class="number">10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">01</span> +<span class="number">0000</span> UTC m=+<span class="number">1</span>.<span class="number">000000001</span> op timeout <span class="number">1</span></span><br><span class="line"><span class="attribute">2009</span>-<span class="number">11</span>-<span class="number">10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">02</span> +<span class="number">0000</span> UTC m=+<span class="number">2</span>.<span class="number">000000001</span> true <span class="number">2</span></span><br></pre></td></tr></table></figure> 可以看到，虽然第 2 个请求超时了。但是，第 3 个请求能够快速恢复。</p>
<h3 id="总结">总结</h3>
<p>第一次在 go 中实现超时控制的时候，满篇的 select-case，粗糙地在超时的时候返回而不管尚在执行中的 goroutine 的死活。结果是，大批量调用受到几个调用超时的影响，一直超时无法恢复。</p>
<p><code>context</code> 这个包就在这种情况下出现在我的视线中。按惯例，<code>context.Context</code> 对象应该作为函数的第一个参数，并且不建议将其当成结构体的一个部分。此外，它还可以用来传递值等等。</p>
<p>但是，如果只是为了进行超时控制，而不得不把所有的函数方法都加上这个参数的话，总感觉不那么漂亮。希望未来 go 可以更好地更漂亮地解决超时退出下 goroutine 的退出问题。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>好物推荐|移动端app抓包的几种姿势</title>
    <url>/2017/07/11/%E5%A5%BD%E7%89%A9%E6%8E%A8%E8%8D%90%EF%BC%9A%E7%A7%BB%E5%8A%A8%E7%AB%AFapp%E6%8A%93%E5%8C%85%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF/</url>
    <content><![CDATA[<p>打开手机，日常使用的诸多app都是木有网页版的。故而有时候我们想看看这些app背后在做些什么就不能简单地打开浏览器或者使用tcpdump/wireshark等工具。移动的问题交给移动，下面我们就来看看几种移动端app抓包的姿势吧。</p>
<h3 id="姿势1以牙还牙">姿势1：以牙还牙</h3>
<p>难度：★</p>
<p>使用设备：手机x1</p>
<h4 id="使用android">使用Android……</h4>
<blockquote>
<p>无需root</p>
</blockquote>
<p>步骤： 1. 在手机上安装<a href="https://play.google.com/store/apps/details?id=app.greyshirts.sslcapture">Packet Capture</a> 2. 打开Packet Capture，并点击右上角绿色的三角符号开始抓包： <img src="/img/425454433.png" /> 3. 打开你要抓包的app（这里以“活法儿”为例），进行一系列操作…… 4. 切回到Packet Capture，暂停抓包。 <img src="/img/443543524532.png" /> 5. 点击已抓包列表，我们可以查看每个http请求以及响应信息。 <img src="/img/454542528.jpeg" /> <img src="/img/4341341314314326.jpeg" /></p>
<blockquote>
<p>官方是说可以支持ssl的，这个一开始需要导入证书。因为目前没需求，就留待以后吧^ _ ^</p>
</blockquote>
<h4 id="使用ios">使用Ios……</h4>
<p>目前没看到什么好的（免费好用无需越狱）的app，所以，可以直接跳到姿势2！</p>
<h3 id="姿势2找个外援">姿势2：找个外援</h3>
<p>难度：★ ★</p>
<p>使用设备：手机x1，计算机x1</p>
<p>这里的原理是在手机上配置代理，将手机的流量导到计算机上，然后利用计算机上的应用程序查看相关请求信息。</p>
<blockquote>
<p>由于下面提到的应用都支持多个平台，因此这里的截图示例则以iOS为例。</p>
</blockquote>
<h4 id="选择1.-使用charles">选择1. 使用<a href="https://www.charlesproxy.com/">Charles</a></h4>
<p>Charles是一个http代理／http监控器／反向代理，可以记录设备和网络之间的所有http和ssl/https流量，展示内容包括请求／响应以及包头，支持windows／iOS／Linux。具体使用方法可以参考<a href="http://www.jianshu.com/p/dbcf1ef87a63">OSX/iOS 抓包工具 Charles 入门</a>。但是这个软件只有30天的试用期哦～</p>
<h4 id="选择2.-使用rythem">选择2. 使用<a href="https://github.com/AlloyTeam/Rythem">Rythem</a></h4>
<p>Rythem是一个与Fiddler同类的软件，和Fiddler一样具有代理抓包/替换功能，与Fiddler最大的不同是Rythem是跨平台&amp;开源的。下面我们来看看如何使用： 1. 安装<a href="https://github.com/AlloyTeam/Rythem">Rythem</a> 2. 打开Rythem，找到代理信息，并配置手机上http代理： <img src="/img/201707181021.png" /> <img src="/img/201707181001.jpeg" /> 3. let's play！点击Rythem，然后任意打开手机上的应用，然后点击几下，就可以看到Rythem刷刷刷地出现一堆包了。 <img src="/img/201707181022.png" /> 4. Rythem支持会话保存、会话过滤等功能。最重要的是，这个应用是免费的哦！！</p>
<ul>
<li>参考<a href="http://www.alloyteam.com/2012/05/web-front-end-tool-rythem-1/">开源跨平台的Web抓包分析工具Rythem</a></li>
</ul>
<p>现在，数据在手，天下我有，（＾∇＾） <strong>Enjoy!!!</strong></p>
]]></content>
      <categories>
        <category>好物推荐</category>
      </categories>
      <tags>
        <tag>hack</tag>
        <tag>好物推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>我在华为的两三事(二)</title>
    <url>/2015/11/23/%E6%88%91%E5%9C%A8%E5%8D%8E%E4%B8%BA%E7%9A%84%E4%B8%A4%E4%B8%89%E4%BA%8B(%E4%BA%8C)/</url>
    <content><![CDATA[<p>有一件事，基本贯穿了我在华为的两年多。 当时刚到项目组不到一个月，负责产品版本管理的同事被通知到科特迪瓦出差，因此就把版本的事都交给了另一个同事。而本着每个角色都要有个backup的想法（这个想法其实是很不错的，可惜到后面慢慢的就没坚持下去了），LM把我们都叫过来问我们谁愿意当那个backup。在大家沉默不语的时候，我头脑一热，举起了手。后来的后来，每每提及此事，都感慨自己真是年轻呀~~ 好，那就当backup吧。反正主负责人在，也没我啥事。可惜没多久，主负责人也去出差了，接手的另一个同事也忙，事情就落在了我这个backup身上。</p>
<p>这里要提下版本流程。负责版本管理的人要在某个时间进行版本计划收集、确认，在计划时间点对版本进行转测试。版本测试结束后要将所有版本资料整理成规定形式，通知QA进行检查，跟踪版本流程，输出版本度量表。</p>
<p>其实这些都不难，只是事情相当繁琐，过程略复杂让人记不住而已。加之还要将印度团队的版本归入，每月两次的版本发布是我最为烦躁的时候。</p>
<p>就这样被折腾了一段时间，在某天项目清闲的时候，我终于忍不住，想对这个过程进行自动化。当然，全自动化是理想，半自动化却相对比较容易实现不是。这个决定大大提高了版本管理的效率，减缓了我的焦躁，以及奠定了我对python的喜爱。</p>
<p>先是用脚本统计N份文档中的代码量，然后将所有版本资料整理成规定形式，接着检查资料规范及完整性。随着对win32com这个python库进一步熟悉，还用它帮忙拷贝几十份文档的病毒扫描结果，提取相关信息以帮助输出版本度量表。从此，QA能挑出的毛病越来越少，我花在版本这件事上的时间也越来越少。而因为大大减少了文档的打开及复制粘贴，从此手也不酸了。直接跑个脚本，然后该干嘛干嘛。</p>
<p>人生苦短，我用python.</p>
<p>用脚本实现这些繁琐的工作，还有一个好处。中途因为出差，将版本这件事转交给另一个同事的时候，我只需要告诉他怎么使用这些脚本即可。</p>
<p>版本管理这个事情，是我在华为两年多的时间内做的最为完美的两件事之一。即使这个事情，无人关注，无人了解。在这个过程中，我认识了好几个可爱的QA（其中一个还生了一对双胞胎），认识了约好来SZ要找我玩的某CMO，认识了印度妹子P<strong>和S</strong>，S**在我因出差交接的时候每次每次都跟我说希望我回来还能继续做版本的事，在我走的时候还坚持要给我的领导写感谢信。 当然，也有遗憾。在离开前本来是想更进一步自动化的，但因为技能跟不上想法，加之跑去做项目组的产品知识库了。就此搁浅。</p>
<p>说到项目组的产品知识库，源于当时在学习django。与此同时，在处理问题的过程中迫切的需要知道是否有相同的案例及对应的解决方案和版本，加之平台每次发布版本就只有几个人知道有什么功能变动。learning by doing，确实是一个非常好的学习方式！</p>
<p>所以我用django+sqlite+bootstrap做了一个博客，用于平台功能改动点和案例共享，提供查询功能。我给每一篇文章添加标签，用于方便的查找某方面的信息。后来，我还增加了一个栏目，用于分享一些非官方的材料。我希望通过它，一些反反复复出现的问题一下子就可以根据从前的经验得到解决，我们可以很容易的知道产品有什么能力有什么不足。自从这个博客完成后，每当项目群里讨论某个问题的时候，有人甩出博客中的一个链接，我就觉得非常自豪。</p>
<p>每一个产品，都应该有一个属于它自己的博客，界面友好，易于查找。这个博客是服务于团队内部的。它的内容是这个产品有关的所有信息，即使是新手，也可以从中直接快速的学习到关于这个产品的方方面面，避免弯路。而界面往往会关系到人们是否会愿意使用，无法或很难进行搜索则直接影响到这个博客的可用性。 而做一个博客有多难呢？我一个人，从啥都不会到信息录入用了不到两周的时间。（说到这个信息录入，当时的我应该也来自动化一把的，╮(╯▽╰)╭）</p>
<p>经过了这些，我开始喜欢将一些繁琐的事情交给自动化。因为繁琐，所以常常有规则，有规则则可编程。这一方面，python帮了我很大的忙。 我一直相信，人类是可以从大量重复的工作中解放出来的，这样，更有时间去关注生活，关注自己。</p>
<p>在华为的这两年多的时间内，我做了很多事。协助过销售，调研分析过需求，做过开发，也在现网交付测试过，维护解决了很多问题，做过项目组的人力预算，管理过整个版本流程。在异国他乡行走过，视野也开阔起来。我遇到了很多很多的人，他们都对我很好很好。</p>
<p>我的能力还不够，但是我会学习会尝试。我时常有些想法，虽然不成熟，但是当一开始实现了总能让人激动。未来有无限的可能，只要你敢，你愿意。</p>
]]></content>
      <categories>
        <category>这就是生活</category>
      </categories>
      <tags>
        <tag>经历</tag>
      </tags>
  </entry>
  <entry>
    <title>新浪微博自动登录与微博发送</title>
    <url>/2016/01/28/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E4%B8%8E%E5%BE%AE%E5%8D%9A%E5%8F%91%E9%80%81/</url>
    <content><![CDATA[<p>话说Ele自从买了Kindle之后，阅读量蹭蹭的上去了。小K有个好处，就是可以摘录一些片段。然而，眼见着摘录越来越多，但是懒惰的Ele却从来没有打开回温一下，这是不对的！！于是乎，Ele决定把其推送到微博上，没事刷一刷。ε(┬┬﹏┬┬)3 为了战胜自己，也是够了！</p>
<h2 id="自动登录微博">自动登录微博</h2>
<p>虽然新浪微博提供了Python API可以直接接入。但是，本着不想暴露过多个人信息，最后还是决定模拟登录之。 如果要模拟PC端的登录，过程相当复杂。需要根据用户名密码算出多个值，其过程还涉及到各种加密运算。网上已经有很多相关的内容描述这整个过程。但由于Google上找到的大部分相关信息都是比较久远的，对当前不再适用。此时，祭出黑招： &gt; 移动端的登录通常比PC端登录简单很多很多，因此，登录解析可以从移动端入手。</p>
<p>怎么找到移动端呢？有一个简单粗暴的方法：拿出手机，登录到网站上，就会自动跳到移动端啦。这里，新浪微博的移动端是：http://m.weibo.cn/。 模拟的思路可以参考之前写过的<a href="/2015/09/26/%5BPython%5D沪江部落自动登录打卡/">沪江部落自动登录打卡</a>。 代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weibo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    新浪微博类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, username, password</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        借助移动端进行登录</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">#user,password用户名密码,使用自己注册的sina用户名密码</span></span><br><span class="line">        self.username = username</span><br><span class="line">        self.password = password</span><br><span class="line">        self.session = requests.Session()</span><br><span class="line">        self._login()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_login</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment">#登录地址</span></span><br><span class="line">        url_login = <span class="string">r&quot;https://passport.weibo.cn/sso/login&quot;</span> <span class="comment"># 是的，这就是移动端的登录地址</span></span><br><span class="line">        headers = &#123; <span class="comment"># 这个请求头一定要有，否则会失败</span></span><br><span class="line">            <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;passport.weibo.cn&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;keep-alive&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Origin&quot;</span>: <span class="string">&quot;https://passport.weibo.cn&quot;</span>,</span><br><span class="line">            <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;*/*&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.8&quot;</span>,&#125;</span><br><span class="line">        postdata = &#123;</span><br><span class="line">            <span class="string">&quot;username&quot;</span> : self.username,</span><br><span class="line">            <span class="string">&quot;password&quot;</span> : self.password,</span><br><span class="line">            <span class="string">&quot;savestate&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ec&quot;</span> : <span class="string">&quot;0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;pagerefer&quot;</span> : <span class="string">&quot;https%3A%2F%2Fpassport.weibo.cn%2Fsignin%2Fwelcome%3Fentry%3Dmweibo%26r%3Dhttp%253A%252F%252Fm.weibo.cn%252F%26wm%3D3349%26vt%3D4&quot;</span>,</span><br><span class="line">            <span class="string">&quot;entry&quot;</span> : <span class="string">&quot;mweibo&quot;</span>, <span class="comment">#我猜，这里是mobile weibo的意思，表明登录是来自移动端</span></span><br><span class="line">            <span class="string">&quot;wentry&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;loginfrom&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;client_id&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;code&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;qq&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;hff&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;hfp&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        resp = self.session.post(</span><br><span class="line">                url_login,</span><br><span class="line">                data=postdata,</span><br><span class="line">                headers=headers</span><br><span class="line">            ).json()</span><br><span class="line">        self.uid = resp[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;uid&#x27;</span>] <span class="comment">#保存用户id</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> resp[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;crossdomainlist&#x27;</span>].values(): <span class="comment"># 响应中返回的domainlist每个要请求一下，否则登录不完整</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> url.startswith(<span class="string">&quot;http:&quot;</span>) <span class="keyword">and</span> <span class="keyword">not</span> url.startswith(<span class="string">&quot;https:&quot;</span>): url = <span class="string">&quot;http:&quot;</span> + url</span><br><span class="line">            self.session.get(url)</span><br><span class="line">        self.session.get(<span class="string">&quot;http://m.weibo.cn/&quot;</span>) <span class="comment"># 最后这里如果能够正常看到响应结果，说明登录成功</span></span><br></pre></td></tr></table></figure>
<h2 id="微博发布">微博发布</h2>
<p>因为前面登录是在移动端登录的，所以下面的微博发布也需要在移动端进行。进入微博发布界面，打开Fiddler，随便发送一条微博，可以看到会POST新微博到http://m.weibo.cn/mblogDeal/addAMblog上。 代码如下： <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_new</span>(<span class="params">self, content</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    create a new weibo发布新微博方法</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    addurl = <span class="string">&quot;https://m.weibo.cn/mblogDeal/addAMblog&quot;</span></span><br><span class="line">    st = re.findall(<span class="string">r&#x27;&quot;st&quot;:&quot;(\w+)&quot;&#x27;</span>, self.session.get(<span class="string">r&quot;http://m.weibo.cn/mblog&quot;</span>).text)</span><br><span class="line"><span class="comment"># 如果发送数据中有一些值为数字字母等混合的长得像随机数的参数，</span></span><br><span class="line"><span class="comment"># 建议可以在页面源代码里找找，然后用正则表达式提取出来。就像这里的st</span></span><br><span class="line">    data = &#123;<span class="string">&#x27;content&#x27;</span>:content, <span class="string">&#x27;st&#x27;</span>:st[<span class="number">0</span>],&#125;</span><br><span class="line">    headers = &#123; <span class="comment"># headers也是必不可少的，否则会有什么安全问题导致发送失败</span></span><br><span class="line">        <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;m.weibo.cn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;keep-alive&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;application/json, text/javascript, */*; q=0.01&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Origin&quot;</span>: <span class="string">&quot;http://m.weibo.cn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;http://m.weibo.cn/mblog&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.8&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    respon = self.session.post(addurl, data, headers=headers).json()</span><br><span class="line">    <span class="keyword">return</span> respon.get(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;Unknow Error&quot;</span>) <span class="comment"># 这里的msg是发布结果</span></span><br></pre></td></tr></table></figure> ## 编写摘抄 小K上的摘录都保存在一个<code>My Clippings.txt</code>文件中。之前出于某种目的已经把它们整合到sqlite数据库app.db里的clipping表里了。直接操作此表既可以获得摘录信息。 另外，因为是希望把它加进香蕉派的定时任务中定时发送的，所以每次获得的摘录当然不能重复。因此会把获得的下一个摘录的id保存在<code>clipping_index</code>文件里。 代码如下： <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clipping</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	片段摘抄</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, db=<span class="string">r&quot;/home/ele/lab/myxixi/app.db&quot;</span></span>):</span></span><br><span class="line">		self.conn = sqlite3.connect(db)</span><br><span class="line">		self.conn.isolation_level = <span class="literal">None</span></span><br><span class="line">		<span class="comment"># 获得下一个摘录的id</span></span><br><span class="line">		tmp = os.popen(<span class="string">&quot;cat clipping_index&quot;</span>).read()</span><br><span class="line">		self.index = <span class="built_in">int</span>(tmp) <span class="keyword">if</span> tmp <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 保存最大的id值</span></span><br><span class="line">		self.max_index = <span class="built_in">int</span>(self.conn.execute(<span class="string">&quot;select max(id) from clipping&quot;</span>).fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">self, topic=<span class="string">u&quot;片段&quot;</span></span>):</span></span><br><span class="line">		<span class="keyword">while</span> self.index &lt;= self.max_index : <span class="comment"># 避免死循环</span></span><br><span class="line">			result = self.conn.execute(<span class="string">&quot;select * from clipping where id=%d&quot;</span>%self.index).fetchone()</span><br><span class="line">			self.index += <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> result: <span class="comment"># 若获得的结果不为空，则保存下一个摘录的id，然后返回内容</span></span><br><span class="line">				os.popen(<span class="string">&quot;echo %d &gt; clipping_index&quot;</span> % self.index)</span><br><span class="line">				<span class="keyword">return</span> <span class="string">u&quot;#&#123;&#125;##&#123;&#125;#&#123;&#125;&quot;</span>.<span class="built_in">format</span>(topic,result[<span class="number">1</span>],result[<span class="number">2</span>])</span><br></pre></td></tr></table></figure> ## 放在一起吧 现在，让我们把它们放在一起测试一下： <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	username = <span class="string">&#x27;*********&#x27;</span></span><br><span class="line">	password = <span class="string">&#x27;**********&#x27;</span></span><br><span class="line">	wb = Weibo(username, password)</span><br><span class="line">	cl = Clipping()</span><br><span class="line">	content = cl.get_one()</span><br><span class="line">	<span class="built_in">print</span> wb.add_new(content)</span><br></pre></td></tr></table></figure> ## 最后 设个定时任务，每30min给Ele的微博推送一条摘录。这样，就可以好好利用碎片时间温故而知新啦♪(<sup>∇</sup>*)</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>香蕉派</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>树及其Python的简单实现</title>
    <url>/2016/01/11/%E6%A0%91%E5%8F%8A%E5%85%B6Python%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="二叉树t">二叉树T</h1>
<p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91">维基百科：二叉树</a></p>
<h2 id="特性">特性</h2>
<ol type="1">
<li>每个树结点x含有一个关键字key</li>
<li>树结点x的属性p, left和right分别存放指向父结点、左孩子和右孩子的指针</li>
<li>如果x.p = NIL,则x是根结点</li>
<li>若结点x没有左孩子，则x.left = NIL；若结点x没有右孩子，则x.right = NIL</li>
<li>属性T.root指向整棵树T的根结点。若T.root = NIL，则该树为空。 <img src="/img/2015601111159.png" /></li>
</ol>
<h1 id="分支无限制的有根树t">分支无限制的有根树T</h1>
<p>对于每个结点的孩子数至多为常数k的任意类型的树，使用左孩子有兄弟表示法(left-child, right-sibling representation)： 1. 每个结点x都包含一个父结点指针p，T.root指向树T的根结点 2. 每个结点x只有两个指针： * x.left-child指向结点x最左边的孩子结点 * x.right-sibling指向x右侧相邻的兄弟结点 * 若结点x没有孩子结点，则x.left-child = NIL；若结点x是其父结点的最右孩子，则x.right-sibling = NIL。 <img src="/img/201601111200.png" /></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出 go slice</title>
    <url>/2018/10/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-go-slice/</url>
    <content><![CDATA[<p>这是【深入浅出 go xx】系列的第一篇。在该系列中，会对 go 的一些基本特性，从定义到源码进行整理和记录。</p>
<p>希望不要跳票。</p>
<h2 id="什么是-slice">什么是 slice？</h2>
<p>slice 是 Go 的一种基本的数据结构。它在数组之上做了一层封装，相当于动态数组。它持有对底层数组的引用。</p>
<p>因此： * 如果你将一个 slice 赋给另一个 slice，那么，这两个 slice 都会指向同一个数组。 * 如果一个函数的参数包含 slice，那么，对入参 slice 的元素的改动对于该函数的调用者是可见的。类似于传递一个指向底层数组的指针给函数。</p>
<p>每个 slice 都有两个属性：length 和 capacity。前者是 slice 的底层数组的元素个数，后者是底层数组的长度。length 会随着 slice 的元素改动在 capacity 的范围内发生改变。可以通过内置函数 <code>cap</code> 查看 slice 的 capacity，通过 <code>len</code> 查看 length。可以使用 <code>append</code> 方法将数据追加到 slice 之后。如果数据超过了 capacity，那么，会为 slice 重新分配空间，并返回最终的 slice。</p>
<blockquote>
<p>注意：对 <code>nil</code> slice 使用 <code>cap</code> 和 <code>len</code> 方法是合法的，此时会返回 0。</p>
</blockquote>
<h3 id="如何使用-slice">如何使用 slice</h3>
<p>可以使用内置函数 <code>make([]T, length, capacity)</code> 创建一个新的已初始化的类型为 <code>T</code> 的 slice。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建并初始化一个类型为 int，length 为 50，capacity 为 100 的 slice</span></span><br><span class="line">slc := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">50</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码等价于创建一个长度为 50 的数组，然后对其进行切片： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slc := ([<span class="number">100</span>]<span class="keyword">int</span>)[<span class="number">0</span>:<span class="number">50</span>]</span><br></pre></td></tr></table></figure> 此外，还可以使用字面量创建切片： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会创建一个 length 为 5，capacity 为 5 的 slice</span></span><br><span class="line"><span class="comment">// 注意：[] 里面不要写容量。否则创建的就是数组，而不是 slice 了。</span></span><br><span class="line">slc := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure> ## slice 的底层实现 &gt; 基于 go 1.11.1</p>
<h3 id="结构定义">结构定义</h3>
<p>可以在 <code>/src/runtime/slice.go</code> 中找到对 slice 的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer <span class="comment">// 指向一个数组的指针</span></span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">// 当前切片的长度</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">// 当前切片的容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建切片">创建切片</h3>
<p>使用以下方法创建切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">	<span class="comment">// 根据切片元素的类型，获取最大可创建元素个数</span></span><br><span class="line">	maxElements := maxSliceCap(et.size)</span><br><span class="line">	<span class="comment">// 判断要创建切片的长度：非零且不超过最大个数</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="keyword">uintptr</span>(<span class="built_in">len</span>) &gt; maxElements &#123;</span><br><span class="line">		panicmakeslicelen()</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 判断要创建切片的容量：非零且不超过最大个数</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &lt; <span class="built_in">len</span> || <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) &gt; maxElements &#123;</span><br><span class="line">		panicmakeslicecap()</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 根据容量申请所需内存</span></span><br><span class="line">	p := mallocgc(et.size*<span class="keyword">uintptr</span>(<span class="built_in">cap</span>), et, <span class="literal">true</span>)</span><br><span class="line">	<span class="comment">// 返回申请好内存的切片的首地址</span></span><br><span class="line">	<span class="keyword">return</span> slice&#123;p, <span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个针对大小和容量是 int64 的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice64</span><span class="params">(et *_type, len64, cap64 <span class="keyword">int64</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">    <span class="comment">// 长度和容量必须在 int 范围内</span></span><br><span class="line">	<span class="built_in">len</span> := <span class="keyword">int</span>(len64)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">int64</span>(<span class="built_in">len</span>) != len64 &#123;</span><br><span class="line">		panicmakeslicelen()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cap</span> := <span class="keyword">int</span>(cap64)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">int64</span>(<span class="built_in">cap</span>) != cap64 &#123;</span><br><span class="line">		panicmakeslicecap()</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 将长度和容量转换成 int 后，调用创建</span></span><br><span class="line">	<span class="keyword">return</span> makeslice(et, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="append"><code>append()</code></h3>
<p>golang 中有一个内置函数可以对 slice 进行追加。函数声明如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []Type, elems ...Type)</span> []<span class="title">Type</span></span></span><br></pre></td></tr></table></figure>
<p>该函数会将 <code>elems</code> 追加到 <code>slice</code> 之后。如果 <code>slice</code> 有足够的 capacity，那么直接追加。否则，会分配一个新的底层数组。</p>
<p>有三种使用方式： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice = <span class="built_in">append</span>(slice, elem1, elem2)</span><br><span class="line">slice = <span class="built_in">append</span>(slice, anotherSlice...)</span><br><span class="line">slice = <span class="built_in">append</span>([]<span class="keyword">byte</span>(<span class="string">&quot;hello &quot;</span>), <span class="string">&quot;world&quot;</span>...)</span><br></pre></td></tr></table></figure> ### 扩容 当一个切片满了，就需要扩容了。扩容动作是通过调用下面函数完成的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// growslice handles slice growth during append.</span></span><br><span class="line"><span class="comment">// 三个入参非别是：slice 元素类型，旧的 slice，以及所需的最小 capacity</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc()</span><br><span class="line">		racereadrangepc(old.array, <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>*<span class="keyword">int</span>(et.size)), callerpc, funcPC(growslice))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(old.array, <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>*<span class="keyword">int</span>(et.size)))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> et.size == <span class="number">0</span> &#123;</span><br><span class="line">	    <span class="comment">// 检查：申请的新 capacity 不能小于旧的</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// append should not create a slice with nil pointer but non-zero len.</span></span><br><span class="line">		<span class="comment">// We assume that append doesn&#x27;t need to preserve old.array in this case.</span></span><br><span class="line">		<span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), old.<span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定新的 slice 的 capacity。其初始值为旧的 slice 的 capacity</span></span><br><span class="line">	newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="comment">// 1. 如果所需要的最小 capacity 超过两倍的旧的 slice 的 capacity，</span></span><br><span class="line">	<span class="comment">// 那么将新的 slice 的 capacity 设置为所需要的最小 capacity</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123; </span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="comment">// 2. 否则，当旧的 slice 的 length 小于 1024 时，</span></span><br><span class="line">	    <span class="comment">// 将新的 slice 的 capacity 设置为两倍的旧的 slice 的 capacity</span></span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		    <span class="comment">// 3. 否则，不断地扩张新的 slice 的 capacity 直至它的值不小于所需的最小 capacity。每次扩张的值是当前 capacity 的 1/4（这里会检测这个 capacity 是否为正数，以防止溢出以及死循环）</span></span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 当新的 slice 的 capacity 溢出时，设置它的值为所需的最小 capacity。</span></span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 slice 的元素类型大小，调整新的 slice 的 capacity</span></span><br><span class="line">	<span class="keyword">var</span> overflow <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> lenmem, newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line">	<span class="comment">// 针对一些常见的元素类型大小（et.size）：</span></span><br><span class="line">	<span class="comment">// 1. 当大小为 1 时，无需进行任何乘除操作</span></span><br><span class="line">	<span class="comment">// 2. 当大小为 sys.PtrSize 时，编译器会将乘除操作优化为常量移位</span></span><br><span class="line">	<span class="comment">// 3. 当大小为 2 的幂时，使用变量移位</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> et.size == <span class="number">1</span>:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap))</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem)</span><br><span class="line">	<span class="keyword">case</span> et.size == sys.PtrSize:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * sys.PtrSize</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * sys.PtrSize</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * sys.PtrSize)</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem / sys.PtrSize)</span><br><span class="line">	<span class="keyword">case</span> isPowerOfTwo(et.size):</span><br><span class="line">		<span class="keyword">var</span> shift <span class="keyword">uintptr</span></span><br><span class="line">		<span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">			<span class="comment">// Mask shift for better code generation.</span></span><br><span class="line">			shift = <span class="keyword">uintptr</span>(sys.Ctz64(<span class="keyword">uint64</span>(et.size))) &amp; <span class="number">63</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			shift = <span class="keyword">uintptr</span>(sys.Ctz32(<span class="keyword">uint32</span>(et.size))) &amp; <span class="number">31</span></span><br><span class="line">		&#125;</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) &lt;&lt; shift</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) &lt;&lt; shift</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) &lt;&lt; shift)</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem &gt;&gt; shift)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">		capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * et.size)</span><br><span class="line">		overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxSliceCap(et.size)</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断异常情况：</span></span><br><span class="line">	<span class="comment">// 1. 缩容</span></span><br><span class="line">	<span class="comment">// 2. 申请的容量会导致溢出</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> || overflow || capmem &gt; maxAlloc &#123;</span><br><span class="line">		<span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> p unsafe.Pointer <span class="comment">// 新的 slice 的底层数组</span></span><br><span class="line">	<span class="keyword">if</span> et.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">	    <span class="comment">// 申请内存。此时并不进行初始化</span></span><br><span class="line">		p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">		<span class="comment">// 将旧的 slice 的底层数组中的元素拷贝到新的 slice 的底层数组中。</span></span><br><span class="line">		memmove(p, old.array, lenmem)</span><br><span class="line">		<span class="comment">// 调用该函数的 append() 方法将会重写底层数组中从 old.len 到 cap（将会成为新的 slice 新的 length）索引。</span></span><br><span class="line">		<span class="comment">// 因此，仅需初始化不会被重写的部分为零值。也就是 cap 之后的位置</span></span><br><span class="line">		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 重新申请内存，并初始化为零值</span></span><br><span class="line">		p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> !writeBarrier.enabled &#123;</span><br><span class="line">		    <span class="comment">// 如果不能打开写锁，那么把将旧的 slice 的底层数组中的元素拷贝到新的 slice 的底层数组中</span></span><br><span class="line">			memmove(p, old.array, lenmem)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		    <span class="comment">// 循环拷贝旧的 slice 的值</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; lenmem; i += et.size &#123;</span><br><span class="line">				typedmemmove(et, add(p, i), add(old.array, i))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 返回：一个新的 slice，</span></span><br><span class="line">    <span class="comment">// 这个 slice 的 capacity 的最小值为传入的 cap，并且会将旧的 slice 中的元素拷贝到这个新的 slice 中。</span></span><br><span class="line">    <span class="comment">// 这个 slice 的 length 会被设置成旧的 slice 的 length，而不是新的所需的 capacity。</span></span><br><span class="line">    <span class="comment">// 这样做的目的是出于代码生成的方便。而在 append 期间，这个 length 是会随着新元素的写入而发生变化的。</span></span><br><span class="line">	<span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝">拷贝</h3>
<p>golang 提供了一个内置函数 <code>copy</code> 来进行 slice 拷贝。函数定义如下： <figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">(dst, src []Type)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure> 这个函数会将源 slice <code>src</code> 中的元素拷贝到目标 slice <code>dst</code> 中（有一个特殊场景：它还会将一个字符串中的字节拷贝到一个 bytes slice 中）。源和目标可能会发生重叠。 该函数返回拷贝的元素个数，即 <strong>min(len(src), len(dst)</strong>。</p>
<p>slice 的拷贝是通过以下函数实现的： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(to, fm slice, width <span class="keyword">uintptr</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果源 slice 或者目标 slice 的 length 为 0，则无需拷贝，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> fm.<span class="built_in">len</span> == <span class="number">0</span> || to.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 记录源 slice 和目标 slice 之间最短的 length</span></span><br><span class="line">	n := fm.<span class="built_in">len</span></span><br><span class="line">	<span class="keyword">if</span> to.<span class="built_in">len</span> &lt; n &#123;</span><br><span class="line">		n = to.<span class="built_in">len</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123; <span class="comment">// 开启了竞争检测</span></span><br><span class="line">		callerpc := getcallerpc()</span><br><span class="line">		pc := funcPC(slicecopy)</span><br><span class="line">		racewriterangepc(to.array, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)), callerpc, pc)</span><br><span class="line">		racereadrangepc(fm.array, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)), callerpc, pc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123; <span class="comment">// 开启了 the memory sanitizer</span></span><br><span class="line">		msanwrite(to.array, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)))</span><br><span class="line">		msanread(fm.array, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	size := <span class="keyword">uintptr</span>(n) * width</span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">1</span> &#123; <span class="comment">// common case worth about 2x to do here</span></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> is this still worth it with new memmove impl?</span></span><br><span class="line">		*(*<span class="keyword">byte</span>)(to.array) = *(*<span class="keyword">byte</span>)(fm.array) <span class="comment">// known to be a byte pointer</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		memmove(to.array, fm.array, size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 还有一个函数 <code>func slicestringcopy(to []byte, fm string) int</code> 实现了上面提到的特殊场景。实现跟 <code>slicecopy</code> 相似，这里不再赘述。</p>
<h2 id="slice-使用注意事项">slice 使用注意事项</h2>
<h3 id="当-slice-作为函数参数并且在函数中进行修改时">当 slice 作为函数参数，并且在函数中进行修改时……</h3>
<p>来源：<a href="https://www.youtube.com/watch?v=zPd0Cxzsslk">GopherCon 2018: Jon Bodner - Go Says WAT</a></p>
<p>考虑以下例子： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">grow</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value: %v, length: %d, capacity: %d, addr: %p\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value: %v, length: %d, capacity: %d, addr: %p\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value: %v, length: %d, capacity: %d, addr: %p\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">	grow(s)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value: %v, length: %d, capacity: %d, addr: %p\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 运行输出 <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="attr">value:</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>], <span class="attr">length:</span> <span class="number">3</span>, <span class="attr">capacity:</span> <span class="number">3</span>, <span class="attr">addr:</span> <span class="number">0xc00000a460</span></span><br><span class="line"><span class="attr">value:</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>], <span class="attr">length:</span> <span class="number">3</span>, <span class="attr">capacity:</span> <span class="number">3</span>, <span class="attr">addr:</span> <span class="number">0xc00000a460</span></span><br><span class="line"><span class="attr">value:</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>], <span class="attr">length:</span> <span class="number">6</span>, <span class="attr">capacity:</span> <span class="number">6</span>, <span class="attr">addr:</span> <span class="number">0xc00000c330</span></span><br><span class="line"><span class="attr">value:</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>], <span class="attr">length:</span> <span class="number">3</span>, <span class="attr">capacity:</span> <span class="number">3</span>, <span class="attr">addr:</span> <span class="number">0xc00000a460</span></span><br></pre></td></tr></table></figure> 为什么调用 <code>grow()</code> 之后得到的 <code>s</code> 是 <code>[1 2 3]</code>，而不是 <code>[1 2 3 4 5 6]</code> 呢？</p>
<p>因为在 <code>append</code> 的时候，<code>s</code> 没有足够的容量。因此，会创建一个新的 slice。可以从上面的打印看到，在 <code>append</code> 调用前后，<code>s</code> 的容量和地址都发生了改变。因此，<code>append</code> 并不会对 <code>main</code> 函数中的 <code>s</code> 作出任何修改。</p>
<p>那么，如果我们给 <code>s</code> 设置了一个足够大的 capacity 呢？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">grow</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value: %v, length: %d, capacity: %d, addr: %p\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value: %v, length: %d, capacity: %d, addr: %p\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value: %v, length: %d, capacity: %d, addr: %p\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">	grow(s)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value: %v, length: %d, capacity: %d, addr: %p\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出： <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="attr">value:</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>], <span class="attr">length:</span> <span class="number">3</span>, <span class="attr">capacity:</span> <span class="number">10</span>, <span class="attr">addr:</span> <span class="number">0xc00007e0a0</span></span><br><span class="line"><span class="attr">value:</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>], <span class="attr">length:</span> <span class="number">3</span>, <span class="attr">capacity:</span> <span class="number">10</span>, <span class="attr">addr:</span> <span class="number">0xc00007e0a0</span></span><br><span class="line"><span class="attr">value:</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>], <span class="attr">length:</span> <span class="number">6</span>, <span class="attr">capacity:</span> <span class="number">10</span>, <span class="attr">addr:</span> <span class="number">0xc00007e0a0</span></span><br><span class="line"><span class="attr">value:</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>], <span class="attr">length:</span> <span class="number">3</span>, <span class="attr">capacity:</span> <span class="number">10</span>, <span class="attr">addr:</span> <span class="number">0xc00007e0a0</span></span><br></pre></td></tr></table></figure> 结果是，调用 <code>grow()</code> 之后得到的 <code>s</code> 还是 <code>[1 2 3]</code>！</p>
<p>这是因为，上面提到了，一个 slice 是由 <code>array</code>，<code>len</code> 和 <code>cap</code> 一起标识的，并且在作为入参时是按值传递的。因此，无论是在 <code>main</code> 函数，还是在 <code>grow</code> 函数，<code>s</code> 指向的都是同一个底层数组。但是，在 <code>grow</code> 函数中，<code>s</code> 的 <code>len</code> 值发生了改变，而在 <code>main</code> 中，<code>s</code> 的 <code>len</code> 值还是保持了原样。</p>
<p>另一方面，Go 使用 <code>reflect</code> 包的 <code>Value.Pointer</code> 来获取指针，此时，得到的是底层数组的指针，而不是 slice 的指针。因此，打印出来的指针是同一个。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://golang.org/doc/effective_go.html#slices">Effective go: slices</a></li>
<li><a href="https://golang.org/ref/spec#Slice_types">The Go Programming Language Specification: slice type</a></li>
<li><a href="https://halfrost.com/go_slice/">深入解析 Go 中 Slice 底层实现</a></li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>用python操纵Microsoft Office之Word</title>
    <url>/2015/11/06/%E7%94%A8python%E6%93%8D%E7%BA%B5Microsoft%20Office%E4%B9%8BWord/</url>
    <content><![CDATA[<p>前面说了怎么操作EXCEL，现在讲讲如何操作WORD。</p>
<p>当我还是个小菜鸟的时候，曾经每半个月就要将一份病毒扫描报告的内容复制粘贴到几十份文档中。个中心酸，无法言表。而网上关于使用<a href="http://sourceforge.net/projects/pywin32/files/">pywin32</a>这个模块操作WORD文档的信息都很初步。因此，虽然win32com很好用，但是还是无法用它来达成解放劳动力的目的。</p>
<p>在一番摸索下，终于明白了如何参考MSDN上Office相关的接口文档来使用win32com操作WORD文档。下面，就来讲讲如何结合MSDN的接口文档(<a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.word.aspx">Microsoft.Office.Interop.Word</a>)使用win32com操作WORD文档吧</p>
<h2 id="word基本操作">Word基本操作</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> win32com</span><br><span class="line"><span class="keyword">from</span> win32com.client <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 新建一个基于COM对象的应用</span></span><br><span class="line">docApp = win32com.client.Dispatch(<span class="string">&quot;Word.Application&quot;</span>)</span><br><span class="line"><span class="comment"># 设置应用可见</span></span><br><span class="line">docApp.Visible = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 新增一个文档</span></span><br><span class="line">doc = docApp.Documents.Add()</span><br><span class="line"><span class="comment"># 保存并关闭文档</span></span><br><span class="line">doc.SaveAs(<span class="string">&quot;E:\\text.doc&quot;</span>)</span><br><span class="line">doc.Close()</span><br><span class="line"><span class="comment"># 打开已有的应用</span></span><br><span class="line">doc = docApp.Documents.Open(<span class="string">&quot;E:\\text.doc&quot;</span>)</span><br><span class="line"><span class="comment"># 不保存，直接退出</span></span><br><span class="line">doc.Close(SaveChanges=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 关闭应用</span></span><br><span class="line">docApp.Quit()</span><br></pre></td></tr></table></figure>
<p>参考： * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.word.applicationclass_members.aspx">应用：Application</a> * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.word.applicationclass.visible.aspx">是否可见：Visible</a> * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.word.documents_members.aspx">文档：Documents</a></p>
<h2 id="selectiontable">Selection/Table</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># selection表示文档中的一个选中区域，或者光标所指的地方</span></span><br><span class="line">sel = docApp.Selection</span><br><span class="line"><span class="comment"># 在selection后插入</span></span><br><span class="line">sel.Range.InsertAfter(<span class="string">&quot;hello, ele&quot;</span>)</span><br><span class="line"><span class="comment"># 向下移动，MoveDown(Unit, Count, Extend)</span></span><br><span class="line">sel.MoveDown(<span class="number">5</span>,<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 表格操作</span></span><br><span class="line"><span class="comment"># 文档中表格个数</span></span><br><span class="line">tblcnt = doc.Tables.Count</span><br><span class="line"><span class="comment"># 表格的Index也是从0开始的</span></span><br><span class="line">doc.Tables[<span class="number">0</span>].Rows[<span class="number">0</span>].Cells[<span class="number">0</span>].Range.Text = <span class="string">&quot;hello, ele&quot;</span></span><br><span class="line"><span class="comment"># 复制粘贴</span></span><br><span class="line"><span class="comment"># 拷贝第2个表格到剪切板上</span></span><br><span class="line">doc.Tables[<span class="number">1</span>].Range.Copy()</span><br><span class="line"><span class="comment"># 粘贴到sel所在位置上</span></span><br><span class="line">sel.Range.Paste()</span><br></pre></td></tr></table></figure>
<p>参考： * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.word.selection_members.aspx">Selection</a> * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.word.range_members.aspx">Range</a> * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.word.tables_members.aspx">Tables</a></p>
<h2 id="其他">其他</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选中一大块区域</span></span><br><span class="line"><span class="built_in">range</span> = doc.Range(doc.Tables[<span class="number">0</span>].Range.Start, doc.Tables[<span class="number">2</span>].Range.End)</span><br><span class="line"><span class="comment"># 移动到某一个heading下</span></span><br><span class="line"><span class="keyword">from</span> win32com.client <span class="keyword">import</span> constants</span><br><span class="line"><span class="comment"># GoTo(What:WdGoToItem, Which:WdGoToDirection, Count, Name)</span></span><br><span class="line"><span class="comment"># 往下移动到第十个heading</span></span><br><span class="line">doc.ActiveWindow.Selection.GoTo(constants.wdGoToHeading, constants.wdGoToNext, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 往下移动一个heading</span></span><br><span class="line">sel = doc.ActiveWindow.Selection.GoToNext(constants.wdGoToHeading)</span><br><span class="line"><span class="comment"># 第一个段落的文字</span></span><br><span class="line">sel.Paragraphs[<span class="number">0</span>].Range.Text</span><br><span class="line"><span class="comment"># 刷新目录</span></span><br><span class="line">doc.TablesOfContents[<span class="number">0</span>].Update()</span><br></pre></td></tr></table></figure>
<p>参考： * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.word.applicationclass.activewindow.aspx">ActiveWindow</a> * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.word.wdgotoitem.aspx">constants: WdGoToItem</a> * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.word.wdgotodirection.aspx">constants: WdGoToDirection</a></p>
<p>珍爱生命，我用python。 学会了如何自动化操作word，大批量文档修改也不是一件令人烦心的事情了，O(∩_∩)O~</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MSOffice</tag>
      </tags>
  </entry>
  <entry>
    <title>用python操纵Microsoft Office之Excel</title>
    <url>/2015/11/06/%E7%94%A8python%E6%93%8D%E7%BA%B5Microsoft%20Office%E4%B9%8BExcel/</url>
    <content><![CDATA[<p>工作中通常会需要操作大量的excel文档，例如，统计数据，生成新的表单等等。此时，使用python帮我们自动化汇总和整理计算可以省去很多时间。</p>
<p>windows下的COM编程可以使用<a href="http://sourceforge.net/projects/pywin32/files/">pywin32</a>这个模块。这样的话，我们就可以直接参考MSDN上Office相关的接口文档来使用了。由于网上已经有了大量的win32com的初步介绍，这里对其就不多加赘述。下面主要是如何结合MSDN的接口文档(<a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.excel.aspx">Microsoft.Office.Interop.Excel</a>)来操作Excel文档</p>
<p>首先，讲解一些基本概念。 1. Application是应用。就是当我们打开Microsoft Excel的时候看到的东西。 2. Workbook是工作簿。有了应用我们还什么都不能做，还需要创建一个工作簿。 3. Worksheet是工作表，然后Cells指的是工作表中的一格一格的地方。 总结一下，就是首先我们要有Application，然后在上面创建Workbook。一个Application可以有多个Workbook。有了Workbook后，基本操作是在Workbook上的不同Worksheet中的Cell进行的。</p>
<h2 id="excel基本操作">Excel基本操作</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> win32com</span><br><span class="line"><span class="keyword">from</span> win32com.client <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 新建一个基于COM对象的应用</span></span><br><span class="line">xlApp = win32com.client.Dispatch(<span class="string">&quot;Excel.Application&quot;</span>)</span><br><span class="line"><span class="comment"># 设置应用可见</span></span><br><span class="line">xlApp.Visible = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 新增一个工作簿</span></span><br><span class="line">xlBook = xlApp.Workbooks.Add()</span><br><span class="line"><span class="comment"># 保存并关闭工作簿</span></span><br><span class="line">xlBook.SaveAs(<span class="string">&quot;E:\\text.xls&quot;</span>)</span><br><span class="line">xlBook.Close()</span><br><span class="line"><span class="comment"># 打开已有的应用</span></span><br><span class="line">xlBook = xlApp.Workbooks.Open(<span class="string">&quot;E:\\text.xls&quot;</span>)</span><br><span class="line"><span class="comment"># 不保存，直接退出</span></span><br><span class="line">xlBook.Close(SaveChanges=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 关闭应用</span></span><br><span class="line">xlApp.Quit()</span><br></pre></td></tr></table></figure>
<p>参考： * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.excel.applicationclass_members.aspx">应用：Application</a> * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.excel.applicationclass.visible.aspx?cs-save-lang=1&amp;cs-lang=vb#code-snippet-1">是否可见：Visible</a> * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.excel.workbooks_members.aspx">工作簿：Workbooks</a></p>
<h2 id="worksheet基本操作">WorkSheet基本操作</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择一个工作表</span></span><br><span class="line"><span class="comment"># 直接使用下标选择第index个工作表，第一个工作表是index=0</span></span><br><span class="line">sht = xlBook.Worksheets[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 也可以使用工作表名来选择工作表</span></span><br><span class="line"><span class="comment"># sht = xlBook.Worksheets(&quot;Sheet1&quot;)</span></span><br><span class="line"><span class="comment"># 操作单元格</span></span><br><span class="line"><span class="comment"># Cells(row, column), row和column都是从1开始的</span></span><br><span class="line"><span class="comment"># 设值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">    sht.Cells(i,<span class="number">1</span>).Value = i</span><br><span class="line">    sht.Cells(i,<span class="number">2</span>).Value = <span class="string">&quot;Odd&quot;</span> <span class="keyword">if</span> i%<span class="number">2</span> <span class="keyword">else</span> <span class="string">&quot;Even&quot;</span></span><br><span class="line"><span class="comment"># 修改样式</span></span><br><span class="line"><span class="comment"># 设置字体</span></span><br><span class="line">sht.Cells.Font.Name = <span class="string">&quot;Calibri&quot;</span></span><br><span class="line"><span class="comment"># 设置列宽</span></span><br><span class="line">sht.Columns(<span class="number">1</span>).Columnwidth = <span class="number">60</span></span><br><span class="line"><span class="comment"># 设置背景颜色</span></span><br><span class="line">sht.Cells(<span class="number">1</span>,<span class="number">1</span>).Interior.Color = <span class="number">0xc7ed87</span></span><br><span class="line"><span class="comment"># 合并单元格</span></span><br><span class="line">sht.Range(sht.Cells(<span class="number">4</span>,<span class="number">1</span>), sht.Cells(<span class="number">5</span>,<span class="number">1</span>)).Merge()</span><br></pre></td></tr></table></figure>
<p>参考： * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.excel.worksheet_members.aspx">Worksheet</a> * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.excel.worksheets_members.aspx">Worksheets</a> * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.excel._worksheet.cells.aspx">Cells</a> * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.excel._worksheet.columns.aspx">Columns</a> * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.excel.range_members.aspx">Range</a></p>
<h2 id="其他">其他</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算工作表页数（打印预览）</span></span><br><span class="line">cnt = sht.PageSetup.Pages.Count</span><br><span class="line"><span class="comment"># 使用函数</span></span><br><span class="line">result = xlApp.WorksheetFunction.CountIf(sht.Range(<span class="string">&quot;B:B&quot;</span>), <span class="string">&quot;Odd&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>参考： * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.excel.pagesetup_members.aspx">PageSetup</a> * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.excel.pages_members.aspx">Pages</a> * <a href="https://msdn.microsoft.com/EN-US/library/microsoft.office.interop.excel.worksheetfunction_members.aspx">WorksheetFunction</a></p>
<p>知道了怎么使用python操作excel，写好脚本，运行起来，你就可以起身喝杯水，等着看结果就好了♪(<sup>∇</sup>*)</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MSOffice</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次使用golang连接池遇到的坑</title>
    <url>/2017/08/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8golang%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>前段时间需要利用fastdfs来实现文件的上传操作。但是fastdfs官方并不提供golang客户端。但是github大法好呀。于是言小白屁颠屁颠地在github上找到了一个fastdfs的第三方实现golang客户端：<a href="https://github.com/tRavAsty/fdfs_client">tRavAsty/fdfs_client</a>。</p>
<p>一切开发就绪，但是在测试阶段总会偶然的出现在对fastdfs发起上传文件请求的时候hang住的情况。</p>
<p>在加了无数次debug日志，以及最后祭出gdb的情况下，终于将问题范围缩小到<a href="https://github.com/tRavAsty/fdfs_client/blob/master/connection.go">connection.go</a>中的相关实现上。</p>
<p>这个文件提供了连接池的相关操作。在此客户端中，一切与fastdfs的实际交互都会通过连接池中的连接进行。</p>
<h3 id="问题定位">问题定位</h3>
<p>下面是调试定位过程。</p>
<p>第一次夯住时借助gdb看到程序一直在<code>makeConn()</code>方法中。此方法的代码实现如下： <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ConnectionPool)</span> <span class="title">makeConn</span><span class="params">()</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n = rand.Intn(<span class="built_in">len</span>(this.hosts))</span><br><span class="line">		<span class="keyword">if</span> !this.busyConns[n] &#123;</span><br><span class="line">			this.busyConns[n] = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	host := this.hosts[n]</span><br><span class="line">	addr := fmt.Sprintf(<span class="string">&quot;%s:%d&quot;</span>, host, this.ports[n])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> net.DialTimeout(<span class="string">&quot;tcp&quot;</span>, addr, time.Minute)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 其中，busyConns是连接池的一个字段，用来记录连接是否有效。在该方法中，会随机挑选一个连接，只有在某个连接的有效性记录为<code>false</code>（无效）的情况下，才会将其标记为<code>true</code>(有效)，然后创建一个新的连接。</p>
<p>这里的<code>for</code>是个死循环，只有在找到一个无效连接的情况下才会退出此循环。因此一开始怀疑这里存在问题导致无法退出。即存在初始化后所有连接之后（即<code>busyConns</code>里面所有项的值都为true），再次调用<code>makeConns</code>获取新连接时陷入死循环。将其改为遍历： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">func (<span class="keyword">this</span> *ConnectionPool) makeConn() (net.Conn, error) &#123;</span><br><span class="line">	<span class="keyword">var</span> n int</span><br><span class="line">	<span class="keyword">var</span> busy, has bool</span><br><span class="line">	<span class="keyword">for</span> n, busy = range <span class="keyword">this</span>.busyConns &#123;</span><br><span class="line">		<span class="keyword">if</span> !busy &#123;</span><br><span class="line">			<span class="keyword">this</span>.busyConns[n] = <span class="literal">true</span></span><br><span class="line">			has = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !has &#123;</span><br><span class="line">		logger.Errorf(<span class="string">&quot;all hosts are busy: %v&quot;</span>, <span class="keyword">this</span>.busyConns)</span><br><span class="line">		<span class="keyword">return</span> nil, ErrAllConnBusy</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	host := <span class="keyword">this</span>.hosts[n]</span><br><span class="line">	addr := fmt.Sprintf(<span class="string">&quot;%s:%d&quot;</span>, host, <span class="keyword">this</span>.ports[n])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> net.DialTimeout(<span class="string">&quot;tcp&quot;</span>, addr, time.Minute)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> OK。继续测试。该问题一直没再重现。然而，等到要上线的前一天，它它它，它又㕛叒叕出现了/(ㄒoㄒ)/~~</p>
<p>因为这是偶发情况，找不到触发条件，因此只能按住案发现场不重启，然后好好看看这个库的逻辑： 1. 连接池库提供初始化连接池函数<code>NewConnectionPool</code>。在此函数中，调用<code>makeConn</code>方法创建指定数目的连接，然后扔到连接池中一个名为<code>conns</code>的channel中。 2. 每次向连接池获取连接的时候，会调用<code>Get()</code>方法。这个方法中，使用<code>for</code>+<code>select case</code>模式。 1. 如果能从<code>conns</code>这个channel中接收到一个连接，并且此连接不是nil，而且属于活跃连接（使用<code>activeConn</code>方法判定），那么返回该连接。否则退出此<code>select case</code>，进入下一次<code>select case</code> 2. 如果接收不到连接，则会在<code>default</code>子块中尝试通过<code>makeConn</code>方法来获得一个新的连接。然后将此连接发送到<code>conns</code>这个channel中。这样，在下一次<code>select case</code>中，就能够接收到一个有效的连接了。</p>
<p>于是，这里又存在一个死循环。如果一直收不到连接，而在<code>makeConn</code>中又创建不了有效连接的话，那么<code>select case</code>块就会一直跑到<code>default</code>子块中，而唯一退出<code>for</code>循环的条件位于<code>case</code>子块呀大人~~~</p>
<p>通过上面我们可以知道，只要<code>busyConns</code>的值都为true，那么就不会返回有效连接。但是，搜遍整个代码，都没有把<code>busyConns</code>中的值设为<code>false</code>的操作呀摔！</p>
<p>于是，改改改。</p>
<p>根据<code>busyConns</code>的语义，当连接无效的时候，我们就应该把其在<code>busyConns</code>上对应的值置为false。而我们会在将连接放回连接池的时候检查连接的有效性。故而，可以在连接池的<code>put</code>方法里，当检查连接无效的时候，将其在<code>busyConns</code>上置为false。（为了避免此文像裹脚布，这里代码我就不贴了。）</p>
<p>好了，这次，我们知道是因为连接的问题触发程序卡住了。那么，改完测试一下。</p>
<p>运行程序，拿出命令<code>tcpkill</code>把连接灭掉。</p>
<p>然而，不幸的是，程序，再一次卡住了卡住了卡住了！！！</p>
<p>万念俱灰的言小白知道，这不是因为自己之前改得不对，事实上从调试日志来看，程序根本就没走到<code>put</code>方法。所以还是回到<code>Get</code>方法上。然后，在某小可怜的提示下，终于发现还有一处不对。</p>
<p>我们回到上面说到的<code>Get</code>方法。当从channel中收到一个连接的时候，是会检查连接有效性的。但是，问题来了，当连接无效的时候，直接退出当前<code>select case</code>，进入下一个<code>select case</code>，而没有把此无效连接通过<code>put</code>方法放回连接池。此时，会导致此连接对应的<code>busyConns</code>中的值还是一直保持着<code>true</code>不变。这样，我们在<code>default</code>子块中就再次陷入了<code>makeConns</code>一直获取不到有效连接的困境中。修改后的<code>Get()</code>关键部分代码如下： <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case conn := &lt;-<span class="keyword">this</span>.conns:</span><br><span class="line">		<span class="keyword">if</span> conn == nil &#123;</span><br><span class="line">		    logger.Errorf(<span class="string">&quot;[GET] connection from channel is null&quot;</span>)</span><br><span class="line">			<span class="keyword">this</span>.put(conn, <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">			<span class="comment">//return nil, ErrClosed</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="keyword">this</span>.activeConn(conn); err != nil &#123;</span><br><span class="line">		    logger.Errorf(<span class="string">&quot;[GET] active connection error: %s&quot;</span>, err)</span><br><span class="line">			<span class="keyword">this</span>.put(conn, <span class="literal">true</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.wrapConn(conn), nil</span><br><span class="line">	default:</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">this</span>.Len() &gt;= <span class="keyword">this</span>.maxConns &#123;</span><br><span class="line">			errmsg := fmt.Sprintf(<span class="string">&quot;Too many connctions %d&quot;</span>, <span class="keyword">this</span>.Len())</span><br><span class="line">			<span class="keyword">return</span> nil, errors.New(errmsg)</span><br><span class="line">		&#125;</span><br><span class="line">		conn, n, err := <span class="keyword">this</span>.makeConn()</span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			<span class="keyword">return</span> nil, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.conns &lt;- conn</span><br><span class="line">		logger.Debugf(<span class="string">&quot;[GET] put connection for %s to channel, current channel size: %d&quot;</span>, <span class="keyword">this</span>.hosts[n], len(<span class="keyword">this</span>.conns))</span><br><span class="line">		<span class="comment">//put connection to pool and go next `for` loop</span></span><br><span class="line">		<span class="comment">//return this.wrapConn(conn), nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 至此，问题解决。</p>
<h3 id="总结">总结</h3>
<p>经过此次调试，有几点心得： 1. 关键位置的日志一定要给足！ 2. 善用gdb 3. 对可能造成死循环的情况一定要谨慎考虑*3。</p>
<p>人們往往根據內心已有的信念或情緒來對外部事物進行評判，以得出與內心一致的結論。這就是驗證性偏見。 —— <a href="https://book.douban.com/subject/27096799/">司馬懿心戰</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>译|Go 对象的生命周期</title>
    <url>/2018/06/23/%E8%AF%91-Go-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>原文：<a href="https://middlemost.com/object-lifecycle/">The Go Object Lifecycle</a></p>
<p>尽管 Go 是门如此简单的语言，Go 开发者还是发现了大量创建和使用对象的方法。在这篇文章中，我们将会看到对象管理的三步法：实例化、初始化和启动。我们还会将其与其他创建和使用对象的方法进行对比，并回顾每种方法的优缺点。</p>
<h2 id="目的">目的</h2>
<p>这似乎是个很蠢的问题，但是，我们在 Go 中创建和使用对象的目的是什么呢？为了与 Go 的风格保持一致，我优先考虑以下几点：</p>
<ol type="1">
<li>简单</li>
<li>灵活</li>
<li>文档友好</li>
</ol>
<p>此外，还应该说明哪些不是我们的目标。应该假设我们的最终用户具有基本的能力，因而不需要提供过多的防护。我们的代码用户可以 <a href="https://www.urbandictionary.com/define.php?term=RTFM">RTFM</a>（假设我们提供了质量“FM”）。我们还应该假设我们的代码用户不是敌对的 —— 例如，我们不需要保护我们的对象字段，因为我们认为开发者不会以其它方式恶意使用它们。</p>
<h2 id="过程">过程</h2>
<h3 id="实例化">实例化</h3>
<p>首先，需要为对象分配内存。Go 社区的一般建议是利用<a href="https://golang.org/ref/spec#The_zero_value">零值</a>。我觉得这对于那些原始构造函数（例如 <a href="https://golang.org/pkg/sync/#Mutex"><code>sync.Mutex</code></a> 或者 <a href="https://golang.org/pkg/bytes/#Buffer"><code>bytes.Buffer</code></a>，它们的 API 受限）而言是一个很好的建议：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> mu sync.Mutex</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    mu.Lock()</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// do things...</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    mu.Unlock()</span></code></pre></div>
<p>然而，对于大多数应用和库开发者而言，构造函数可以提高效率，并且防止未来可能会出现的错误。</p>
<h4 id="使用构造函数">使用构造函数</h4>
<p>Go 中的构造函数通常采用 <code>New</code> 后跟着类型名称的形式。我们可以在下面的代码中看到这样一个例子：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// DefaultClientTimeout is the default Client.Timeout.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> DefaultClientTimeout = <span class="dv">30</span> * time.Seconds</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Client represents a client to our server.</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Client <span class="kw">struct</span> &#123;</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        Host    <span class="dt">string</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        Timeout time.Duration</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// NewClient returns a new instance of Client with default settings.</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> NewClient(host <span class="dt">string</span>) *Client &#123;</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> &amp;Client&#123;</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            Host:    host,</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            Timeout: DefaultClientTimeout,</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    &#125;</span></code></pre></div>
<p>通过使用构造函数，可以获得几个好处。首先，每次使用时无需检查 <code>Timeout</code> 的零值，以判断我们是否应该使用默认值。因为它始终被设置为正确的值。</p>
<p>其次，如果将来需要初始化字段，那么可以提供无缝的升级体验。假设我们添加了一个需要在创建时初始化的缓存值 <code>map</code>：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Client <span class="kw">struct</span> &#123;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>        cache <span class="kw">map</span>[<span class="dt">string</span>]<span class="kw">interface</span>&#123;&#125;</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        Host    <span class="dt">string</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        Timeout time.Duration</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    &#125;</span></code></pre></div>
<p>如果我们在库的未来版本中添加了一个构造函数来初始化 <code>cache</code>，那么所有现有使用零值的 <code>Client</code> 对象都将崩溃。通过从一开始使用构造函数，并记录其用法，我们避免了需要破坏未来版本的风险。</p>
<h4 id="使用自然命名">使用自然命名</h4>
<p>另一个从构造函数获得的好处是，我们的配置字段名称不再需要受零值限制。也就是说，如果我们有一个默认情况下应该是“可编辑的”对象，那么，就不需要有一个名为 <code>NotEditable</code> 的布尔型字段来使之适配默认的零值（<code>false</code>）。我们可以简单使用自然名称，<code>Editable</code>，然后我们的构造函数可以将其设置为 <code>true</code>。</p>
<h3 id="初始化">初始化</h3>
<p>一旦分配了内存并设置了默认值，你就需要为你的特定使用场景配置对象了。这是我发现大多数的 Go 开发者会复杂化的地方，但是其实实践中非常简单。</p>
<h4 id="请只使用字段">请只使用字段</h4>
<p>一般来说，应该只对导出字段进行设置。在上面的 <code>Client</code> 示例中，通过 <code>Host</code> 和 <code>Timeout</code> 字段提供配置。</p>
<p>为了避免与其他 goroutine 的竞争条件，该配置字段应该只设置一次，因为其他函数（例如 <code>Open()</code> 或者 <code>Start()</code>）可能会启动额外的 goroutine。我们可以在结构文档上记录这个限制。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Client <span class="kw">struct</span> &#123;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Host and port of remote server. Must be set before Open().</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        Host <span class="dt">string</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Time until connection is cancelled. Must be set before Open().</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        Timeout time.Duration</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    &#125;</span></code></pre></div>
<p>此规则的一个例外是，在开始使用该对象后，有某些字段会被更新，并且需要同时改变相关的字段。在这种情况下，提供 getter &amp; setter 函数。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Client <span class="kw">struct</span> &#123;</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>        mu      sync.Mutex</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        timeout time.Duration</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Host and port of remote server. Must be set before Open().</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        Host <span class="dt">string</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Timeout returns the duration until connection is cancelled.</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> (c *Client) Timeout() time.Duration &#123;</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        c.mu.RLock()</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defer</span> c.mu.RUnlock()</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> c.timeout</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// SetTimeout sets the duration until connection is cancelled.</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> (c *Client) SetTimeout(d time.Duration) &#123;</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        c.mu.Lock()</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defer</span> c.mu.Unlock()</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        c.timeout = d</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    &#125;</span></code></pre></div>
<p>然而，我发现在使用期间更改配置项设置通常是一种代码异味，因此通常需要避免。此时，简单地停止对象，并使用新的实例重启，通常更简洁。</p>
<h3 id="启动">启动</h3>
<p>现在，我们已经分配了内存并配置了对象，接下来，让我们做一些有用的事情。此时，简单的对象通常已经准备好了，但是，对于像服务器这样更复杂的对象则需要启动。它们可能需要连接资源，或者启动后台 goroutine 来监控资源，例如 <a href="https://golang.org/pkg/net/#Listener"><code>net.Listener</code></a>。</p>
<p>在 Go 中，我们通常以 <code>Open()</code> 或者 <code>Start()</code> 函数的形状看到这种场景。我更喜欢 <code>Open()</code>，因为这与 <a href="https://golang.org/pkg/io/#Closer"><code>io.Closer</code></a> 中的 <code>Close()</code> 方法在命名上更好配对。</p>
<p>在我们的客户端示例中，可以使用 <code>Open()</code> 来创建网络连接，并使用 <code>Close()</code> 来关闭：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Client <span class="kw">struct</span> &#123;</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>        conn net.Conn</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Host and port of remote server. Must be set before Open().</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        Host <span class="dt">string</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Open opens the connection to the remote server.</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> (c *Client) Open() <span class="dt">error</span> &#123;</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        conn, err := net.Dial(<span class="st">&quot;tcp&quot;</span>, c.Host)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> &#123;</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">return</span> err</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        c.conn = conn</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Close disconnects the underlying connection to the server.</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> (c *Client) Close() <span class="dt">error</span> &#123;</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> c.conn != <span class="ot">nil</span> &#123;</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>            <span class="kw">return</span> c.conn.Close()</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    &#125;</span></code></pre></div>
<p>在上面这个简单的例子中有两个重要的事实需要注意。首先，在 <code>Open()</code> 中，只使用一次我们的 <code>Host</code>，然后就不再使用了。这可以避免在打开该对象后设置主机产生的任何竞争条件。其次，不尝试重置对象状态以重用对象。这些一次性对象避免了试图重用对象时发生的大量错误。</p>
<h4 id="一次性对象">一次性对象</h4>
<p>在实践中，很难正确地清理复杂的对象，然后重用它们。在我们的例子中，不尝试在 <code>Close()</code> 中设置 <code>conn</code> 为 <code>nil</code>。这是因为 <code>Client</code> 可能会有一个后台 goroutine 试图监控连接，而改变 <code>conn</code> 的值需要我们添加一个互斥量来保护该字段。</p>
<p>我们还可以使用该字段来防止双重打开：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Open opens the connection to the remote server.</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> (c *Client) Open() <span class="dt">error</span> &#123;</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> c.conn != <span class="ot">nil</span> &#123;</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>            <span class="kw">return</span> errors.New(<span class="st">&quot;myapp.Client: cannot reopen client&quot;</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        ...</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    &#125;</span></code></pre></div>
<p>然而，我们应该假设最终用户的基本能力，并且通常要避免这些过度的保护。</p>
<h2 id="替代方法">替代方法</h2>
<p>现在，我们已经看到了 <em>实例化-初始化-启动</em> 方法，接下来，让我们来评估 Go 社区中的其他常见方法吧。</p>
<h3 id="选项-1函数选项">选项 #1：函数选项</h3>
<p>Dave Cheney 在他的文章（<a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">Functional Options for Friendly APIs</a>）中描述了一种名为 <em>函数选项（functional options）</em> 的模式。其思想是，我们可以声明一个函数参数类型来更新我们未导出的字段。之后，就可以在同一个调用中启动我们的对象了，因为它已经被初始化过了。</p>
<p>我们使用上面的 <code>Client</code> 示例来描述一下该模式：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Client <span class="kw">struct</span> &#123;</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>        host <span class="dt">string</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// OpenClient returns a new, opened client.</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> OpenClient(opts ...ClientOption) (*Client, <span class="dt">error</span>) &#123;</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        c := &amp;Client&#123;&#125;</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> _, opt := <span class="kw">range</span> opts &#123;</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> err := opt(c); err != <span class="ot">nil</span> &#123;</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>                <span class="kw">return</span> err</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// open client...</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> c, <span class="ot">nil</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ClientOption represents an option to initialize the Client.</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> ClientOption <span class="kw">func</span>(*Client) <span class="dt">error</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Host sets the host field of the client.</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> Host(host <span class="dt">string</span>) ClientOption &#123;</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="kw">func</span>(c *Client) <span class="dt">error</span> &#123;</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>            c.host = host</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>            <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    &#125;</span></code></pre></div>
<p>然后就可以用一行代码使用了：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    client, err := OpenClient(Host(<span class="st">&quot;google.com&quot;</span>))</span></code></pre></div>
<p>虽然这种方法隐藏了配置字段，但是却是以复杂性和可读性为代价的。而随着选项数量大增长，godoc API 也会变得庞大且无法使用，这使得咋看之下很难确定哪种选项适合哪种类型。</p>
<p>但是，最终我们不需要隐藏配置字段。我们应该记录它们的用法，然后相信开发者会正确使用它们。保持这些字段的导出状态会将所有相关的配置字段组合在一个类型中，正如 <a href="https://golang.org/pkg/net/http/#Request"><code>net.Request</code></a> 类型那样。</p>
<h3 id="选项-2配置实例化">选项 #2：配置实例化</h3>
<p>另一个常见的方法是为你的类型提供“配置”对象。这种方法试图将配置字段与类型本身分离开来。很多时候，开发者会将配置对象中的字段复制到类型中，或者直接将配置潜入到类型。</p>
<p>使用上面的 <code>Client</code> 示例来解释一下：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Client <span class="kw">struct</span> &#123;</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>        host <span class="dt">string</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> ClientConfig <span class="kw">struct</span> &#123;</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        Host <span class="dt">string</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> NewClient(config ClientConfig) *Client &#123;</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> &amp;Client&#123;</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            host: config.Host,</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    &#125;</span></code></pre></div>
<p>同样，这样会隐藏 <code>Client</code> 类型的配置字段，除此之外，没有其他好处了。相反，我们应该简单公开我们的 <code>Client.Host</code> 字段，让我们的用户直接管理它。这降低了我们的 API 的复杂度，并且会提供更清晰的文档。</p>
<h4 id="何时使用配置对象">何时使用配置对象</h4>
<p>配置对象很有用，但它不应该是 API 调用者和 API 作者之间的接口。当最终用户和你的软件之间存在接口的时候，才应该存在配置对象。</p>
<p>例如，配置对象可以通过 <a href="http://yaml.org/">YAML</a> 文件和你的代码提供一个接口。这些配置对象通常应该位于你的 <code>main</code> 包中，因为你的二进制文件充当着最终用户和代码之间的翻译层。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">package</span> main</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> main() &#123;</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        config := NewConfig()</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> err := readConfig(path); err != <span class="ot">nil</span> &#123;</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>            fmt.Fprintln(os.Stderr, <span class="st">&quot;cannot read config file:&quot;</span>, err)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>            os.Exit(<span class="dv">1</span>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        client := NewClient()</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        client.Host = config.Host</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> err := client.Open(); err != <span class="ot">nil</span> &#123;</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            fmt.Fprintln(os.Stderr, <span class="st">&quot;cannot open client:&quot;</span>, err)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>            os.Exit(<span class="dv">1</span>)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// do stuff... </span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Config <span class="kw">struct</span> &#123;</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        Host <span class="dt">string</span> <span class="st">`yaml:&quot;host&quot;`</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> NewConfig() Config &#123;</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> &amp;Config&#123;</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>            Host: <span class="st">&quot;localhost:1234&quot;</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    &#125;</span></code></pre></div>
<h2 id="总结">总结</h2>
<p>我们研究了一种管理 Go 对象生命周期的方法，这种方法结合了简单性和灵活性，并且文档友好。首先，我们 <em>实例化</em> 对象以分配内存并设置默认值。接着，通过自定义导出字段来 <em>初始化</em> 对象。最后，<em>启动</em> 我们的对象，这可能会启动后台 goroutine 或者连接。</p>
<p>这简单的 3 个步骤有助于构建易于被开发者当下使用并在未来轻松维护的代码。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>译|Goroutine 泄漏：被遗忘的发送者</title>
    <url>/2018/11/15/%E8%AF%91-Goroutine-%E6%B3%84%E6%BC%8F%EF%BC%9A%E8%A2%AB%E9%81%97%E5%BF%98%E7%9A%84%E5%8F%91%E9%80%81%E8%80%85/</url>
    <content><![CDATA[<p>原文：<a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html">Goroutine Leaks - The Forgotten Sender</a></p>
<hr />
<h3 id="介绍">介绍</h3>
<p>并发编程允许开发者使用多个执行路径来解决问题，并通常用在为提高性能所做的尝试中。但是，并发并不意味着，这些路径并行执行；而是意味着这些路径乱序执行而不是顺序执行。从历史上看，使用标准库或者第三方开发者提供的库可以很方便地进行此类编程。</p>
<p>而在 Go 中，诸如 goroutine 和 channel 这样的并发特性内置在语言和运行时中,以减少或者消除对库对需求。这就造成了用 Go 编写并发程序很容易的错觉。当你决定使用并发时必须很小心，因为如果不正确使用的话，它们就会带来一些独特的副作用或者陷阱。一不小心，这些陷阱就会造成复杂性以及令人讨厌的错误。</p>
<p>而在这篇文章中，我将讨论的陷阱则与 Goroutine 泄漏有关。</p>
<h3 id="goroutine-泄漏">goroutine 泄漏</h3>
<p>在内存管理方面，Go 为你处理了许多细节。Go 编译器使用 <a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html">escape analysis</a> 来确定值在内存中的位置。运行时使用 <a href="https://blog.golang.org/ismmkeynote">垃圾收集器</a>来跟踪和管理堆分配。虽然在应用中创造<a href="https://en.wikipedia.org/wiki/Memory_leak">内存泄漏</a> 不是不可能，但是这种概率已经被大大降低了。</p>
<p>内存泄漏的一种常见类型是 Goroutine 泄漏。你启动了一个 Goroutine，并且你期望它最终会终止，但如果它永远结束不了，那么说明它已经泄露了。它存在于应用的整个生命周期中，并且为这个 Goroutine 分配的任何内存都不会得到释放。这也是“<a href="https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop">永远不要启动一个不知道它将如何停止的 Goroutine</a>”这个建议背后的部分原因。</p>
<p>为了描述基本的 Goroutine 泄露，让我们看看下面的代码：</p>
<p><strong>清单 1</strong><br />
<a href="https://play.golang.org/p/dsu3PARM24K" class="uri">https://play.golang.org/p/dsu3PARM24K</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">31</span> <span class="comment">// leak is a buggy function. It launches a goroutine that</span></span><br><span class="line"><span class="number">32</span> <span class="comment">// blocks receiving from a channel. Nothing will ever be</span></span><br><span class="line"><span class="number">33</span> <span class="comment">// sent on that channel and the channel is never closed so</span></span><br><span class="line"><span class="number">34</span> <span class="comment">// that goroutine will be blocked forever.</span></span><br><span class="line"><span class="number">35</span> <span class="function"><span class="keyword">func</span> <span class="title">leak</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="number">36</span>     ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="number">37</span> </span><br><span class="line"><span class="number">38</span>     <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="number">39</span>         val := &lt;-ch</span><br><span class="line"><span class="number">40</span>         fmt.Println(<span class="string">&quot;We received a value:&quot;</span>, val)</span><br><span class="line"><span class="number">41</span>     &#125;()</span><br><span class="line"><span class="number">42</span> &#125;</span><br></pre></td></tr></table></figure>
<p>清单 1 定义了一个名为 <code>leak</code> 的函数。该函数在第 36 行创建了一个 channel，以允许 Goroutine 传递整型数据。然后，在第 38 行创建了 Goroutine，该 Goroutine 在第 39 行阻塞，以等待从 channel 中接收值。当这个 Goroutine 在等待（接收值）时，<code>leak</code> 函数却返回了。此时，该程序的其他任何部分都不能通过这个 channel 发送信号。这使得该 Goroutine 阻塞在第 39 行，并且永远处于等待状态。第 40 行的 <code>fmt.Println</code> 调用将永远不会发生。</p>
<p>在这个例子中，代码审查阶段就可以快速识别到这个 Goroutine 泄露。不幸的是，生产代码中的 Goroutine 泄露往往更难以发现。我不可能展示 Goroutine 泄露可能会发生的所有方式，但是，这篇文章将详细说明你可能会遇到的一类 Goroutine 泄露：</p>
<h3 id="泄露被遗忘的发送者">泄露：被遗忘的发送者</h3>
<p><em><strong>在这个泄露示例中，你将会看到一个无限期阻塞的 Goroutine，它等待向 channel 发送值。</strong></em></p>
<p>我们将看到的这个程序会基于一些搜索词来查找记录，然后将其打印出来。该程序建立在一个名为 <code>search</code> 的函数之上：</p>
<p><strong>清单 2</strong><br />
<a href="https://play.golang.org/p/o6_eMjxMVFv" class="uri">https://play.golang.org/p/o6_eMjxMVFv</a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">29</span> <span class="co">// search simulates a function that finds a record based</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dv">30</span> <span class="co">// on a search term. It takes 200ms to perform this work.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dv">31</span> <span class="kw">func</span> search(term <span class="dt">string</span>) (<span class="dt">string</span>, <span class="dt">error</span>) &#123;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dv">32</span>     time.Sleep(<span class="dv">200</span> * time.Millisecond)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">33</span>     <span class="kw">return</span> <span class="st">&quot;some value&quot;</span>, <span class="ot">nil</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">34</span> &#125;</span></code></pre></div>
<p>在清单 2 中，第 31 行的 <code>search</code> 函数是一个模拟实现，用以模拟像数据库查询或者 web 调用这样的长耗时操作。在这个例子中，耗时硬编码为 200ms。</p>
<p>清单 3 展示了调用 <code>search</code> 函数的应用。</p>
<p><strong>清单 3</strong><br />
<a href="https://play.golang.org/p/o6_eMjxMVFv" class="uri">https://play.golang.org/p/o6_eMjxMVFv</a></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dv">17</span> <span class="co">// process is the work for the program. It finds a record</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dv">18</span> <span class="co">// then prints it.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dv">19</span> <span class="kw">func</span> process(term <span class="dt">string</span>) <span class="dt">error</span> &#123;</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dv">20</span>     record, err := search(term)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dv">21</span>     <span class="kw">if</span> err != <span class="ot">nil</span> &#123;</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="dv">22</span>         <span class="kw">return</span> err</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="dv">23</span>     &#125;</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="dv">24</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="dv">25</span>     fmt.Println(<span class="st">&quot;Received:&quot;</span>, record)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="dv">26</span>     <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="dv">27</span> &#125;</span></code></pre></div>
<p>在清单 3 中的第 19 行，定义了一个名为 <code>process</code> 的函数，它接收一个表示搜索词的 <code>string</code> 参数。在第 20 行，将 <code>term</code> 变量传递给 <code>search</code> 函数（它会返回一个记录和一个错误信息）。如果发生了错误，那么在第 22 行就会将错误返回给调用者。如果没有错误发生，那么，会在第 25 行打印这个记录。</p>
<p>对某些应用而言，顺序调用 <code>search</code> 产生的延时可能是不能接受的。假设 <code>search</code> 不可能更快了，那么，可以修改 <code>process</code> 函数为不消耗 <code>search</code> 产生的总延迟。</p>
<p>为此，可以使用一个 Goroutine，如下清单 4 所示。不幸的是，这第一次尝试存在错误，因为它创造了潜在的 Goroutine 泄露。</p>
<p><strong>清单 4</strong><br />
<a href="https://play.golang.org/p/m0DHuchgX0A" class="uri">https://play.golang.org/p/m0DHuchgX0A</a></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dv">38</span> <span class="co">// result wraps the return values from search. It allows us</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dv">39</span> <span class="co">// to pass both values across a single channel.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dv">40</span> <span class="kw">type</span> result <span class="kw">struct</span> &#123;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dv">41</span>     record <span class="dt">string</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="dv">42</span>     err    <span class="dt">error</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="dv">43</span> &#125;</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="dv">44</span> </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="dv">45</span> <span class="co">// process is the work for the program. It finds a record</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="dv">46</span> <span class="co">// then prints it. It fails if it takes more than 100ms.</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="dv">47</span> <span class="kw">func</span> process(term <span class="dt">string</span>) <span class="dt">error</span> &#123;</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="dv">48</span> </span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="dv">49</span>     <span class="co">// Create a context that will be canceled in 100ms.</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="dv">50</span>     ctx, cancel := context.WithTimeout(context.Background(), <span class="dv">100</span>*time.Millisecond)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="dv">51</span>     <span class="kw">defer</span> cancel()</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="dv">52</span> </span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="dv">53</span>     <span class="co">// Make a channel for the goroutine to report its result.</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="dv">54</span>     ch := <span class="bu">make</span>(<span class="kw">chan</span> result)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="dv">55</span> </span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="dv">56</span>     <span class="co">// Launch a goroutine to find the record. Create a result</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="dv">57</span>     <span class="co">// from the returned values to send through the channel.</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="dv">58</span>     <span class="kw">go</span> <span class="kw">func</span>() &#123;</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="dv">59</span>         record, err := search(term)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="dv">60</span>         ch &lt;- result&#123;record, err&#125;</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="dv">61</span>     &#125;()</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="dv">62</span> </span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="dv">63</span>     <span class="co">// Block waiting to either receive from the goroutine&#39;s</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="dv">64</span>     <span class="co">// channel or for the context to be canceled.</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="dv">65</span>     <span class="kw">select</span> &#123;</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="dv">66</span>     <span class="kw">case</span> &lt;-ctx.Done():</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="dv">67</span>         <span class="kw">return</span> errors.New(<span class="st">&quot;search canceled&quot;</span>)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="dv">68</span>     <span class="kw">case</span> result := &lt;-ch:</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="dv">69</span>         <span class="kw">if</span> result.err != <span class="ot">nil</span> &#123;</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="dv">70</span>             <span class="kw">return</span> result.err</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="dv">71</span>         &#125;</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="dv">72</span>         fmt.Println(<span class="st">&quot;Received:&quot;</span>, result.record)</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span class="dv">73</span>         <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a><span class="dv">74</span>     &#125;</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a><span class="dv">75</span> &#125;</span></code></pre></div>
<p>在清单 4 中的第 50 行，重写了 <code>process</code> 函数，创建了一个将会在 100ms 后取消的 <code>Context</code>。关于如何使用 <code>Context</code> 的更多信息，请阅读 <a href="https://blog.golang.org/context">golang.org 博文</a>。</p>
<p>然后在第 54 行，程序创建了一个无缓存 channel，允许 Goroutine 传递 <code>result</code> 类型的数据。在第 58 行到第 61 行，定义了一个匿名函数，然后以此创建了一个 Goroutine。这个 Goroutine 调用 <code>search</code>，然后在第 60 行试图通过该 channel 发送调用结果。</p>
<p>在 Goroutine 运行的过程中，在第 65 行，<code>process</code> 执行了 <code>select</code> 块。这个块的两个 case 都是 channel 接收操作。</p>
<p>第 66 行是一个从 <code>ctx.Done()</code> channel 接收数据的 case。如果取消了前面定义的 <code>Context</code>（过了 100ms），那么就会执行这个 case。 而如果执行了这个 case，那么在第 67 行，<code>process</code> 就会返回一个错误，表示它放弃等待。</p>
<p>或者，第 68 行的 case 从 <code>ch</code> channel 接收值，然后把值赋给一个名为 <code>result</code> 的变量。和前面的顺序实现一样，程序在第 69 行和第 70 行检查和处理错误。如果没有错误，那么该程序会在第 72 行打印记录，并返回 <code>nil</code>，表示成功。</p>
<p>此重构版本设置了 <code>process</code> 函数将会等待 <code>search</code> 完成的最长持续时间。然而，该实现也会产生潜在的 Goroutine 泄露。想一想这个代码中 Goroutine 在做的事情吧；在第 60 行，它往 channel 发送数据。向这个 channel 发送数据会阻塞执行，直到另一个 Goroutine 准备好接收该数据。在超时的情况下，接收者停止等待从 Goroutine 接收数据并继续执行。这将会导致 Goroutine <strong>永远</strong> 阻塞在等待接收者，而显然，接收者永远都不会出现。这正是 Goroutine 泄露之时。</p>
<h4 id="修复创建一些空间">修复：创建一些空间</h4>
<p>解决这种泄露最简单的方式是，将 channel 从无缓存 channel 更改为容量为 1 的有缓存 channel。</p>
<p><strong>清单 5</strong><br />
<a href="https://play.golang.org/p/u3xtQ48G3qK" class="uri">https://play.golang.org/p/u3xtQ48G3qK</a></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dv">53</span>     <span class="co">// Make a channel for the goroutine to report its result.</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dv">54</span>     <span class="co">// Give it capacity so sending doesn&#39;t block.</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dv">55</span>     ch := <span class="bu">make</span>(<span class="kw">chan</span> result, <span class="dv">1</span>)</span></code></pre></div>
<p>现在，在超时的情况下，接收者继续执行之后，通过将 <code>result</code> 值放在 channel，search Goroutine 将会完成其发送操作，然后返回。最终，用于这个 Goroutine 以及这个 channel 的内存将会被回收。一切都会自然而然地发挥作用。</p>
<p>在 <a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html">channel 的行为（The Behavior of Channels）</a>中，William Kennedy 提供了几个关于 channel 行为的很好的例子，并且提供了有关其使用的哲学。那篇文中的最后一个示例 <a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html#signal-without-data-context">“清单 10”</a> 展示了一个类似于这个超时示例的程序。阅读那篇文章，以获取关于何时使用带缓存 channel，以及什么级别的容量合适的更多建议。</p>
<h3 id="总结">总结</h3>
<p>Go 让启动 Goroutine 变得简单，但是，明智使用它们则是我们的责任。在这篇文章中，我展示了如何错误使用 Goroutine 的一个例子。有许多其他的方式会创造 Goroutine 泄露，并且在使用并发的时候也可能遇到其他陷阱。在以后的文章中，我将提供更多的 Goroutine 泄露和其他并发陷阱的例子。现在，我会给你这个建议；任何时候当你启动一个 Goroutine 时，都必须问你自己：</p>
<ul>
<li>它何时终止？</li>
<li>什么可能会阻止它终止？</li>
</ul>
<p><em><strong>并发是良器，但必须小心使用。</strong></em></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>没事翻着玩</tag>
      </tags>
  </entry>
  <entry>
    <title>译|新研究表明，黑客可以轻而易举地窃取你的数据</title>
    <url>/2018/03/30/%E8%AF%91%EF%BC%9A%E6%96%B0%E7%A0%94%E7%A9%B6%E8%A1%A8%E6%98%8E%EF%BC%8C%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E8%BD%BB%E8%80%8C%E6%98%93%E4%B8%BE%E5%9C%B0%E7%AA%83%E5%8F%96%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>原文：<a href="https://securitybrief.eu/story/new-study-details-how-easy-it-hackers-steal-your-data/">SecurityBrief Europe - New study details how easy it is for hackers to steal your data</a></p>
<hr />
<p>Exabeam 的一份新报告详细说明了，网络犯罪分子要入侵你的生活有多容易。</p>
<p>web 浏览器存储大量有关用户的敏感信息并非什么秘密，而网站开发人员使用各种各样的方式来定制这种体验。广告商也使用这些功能来最大限度地提高网站上展示的广告的影响力。</p>
<p>结果就是，浏览器深藏着你的大量信息。Exabeam 高级威胁研究员 Ryan Benson 表示，黑客可能会以多种方式利用这些信息。所有类型的个人信息，包括位置信息、工作时间、习惯、银行信息、应用，甚至是密码，都唾手可得。</p>
<p>浏览器存储信息的方式有多种，包括访问的网站、HTTP cookie、本地存储、保存的登录信息和自动填充。</p>
<p>为了进行研究，Exabeam 使用 Alexa Top 1000 名单作为指导，访问互联网上最受欢迎的网站，并进行测试。</p>
<p>在研究的第一阶段，Exabeam 发现，有 56 个网站将用户的某些层次的地理位置信息存储在本地系统中，而有 57 个网站记录了用户的 IP 地址。</p>
<p>“在第二阶段，我们能够从流行的服务中提取大量潜在的敏感信息，包括账户用户名、相关的电子邮件地址、搜索条件、已阅电子邮件和文档的标题，以及下载的文件。下面的表 2 一些较明显的例子。” Benson 说。</p>
<p>“除了这些网站行为，如果用户选择让浏览器使用内置的密码管理器保存密码，那么，我们能够抽取出所有被测网站的已保存的用户名和密码。”</p>
<p><img src="https://securitybrief.eu/media/uploads/2018/03/15/screen-shot-2018-03-14-at-110301-am.png" /></p>
<p>那么，攻击者可以如何获得这些信息的访问权呢？</p>
<p>Benson 说，这实际上很简单。你可以很容易获取收集存储在浏览器中的信息的恶意软件，并且这些恶意软件的变体已经存在多年，包括 Cerber、Kriptovor 和 CryptXXX 勒索软件系列。</p>
<p>“免费的 NirSoft 工具 WebBrowserPassView 从 IE、Mozilla Firefox、Google Chrome、Safari 和 Opera 转储已保存的密码。虽然表面上，它是用来帮助用户恢复自己的密码，但也可能被恶意使用。Benson 说，“被用来扰乱平昌奥运会的 ‘Olympic Destroyer’ 恶意软件最近被爆出利用浏览器中保存的用户凭据。”</p>
<p>“另一个问题是在共享电脑或者共享工作区中工作。如果机器被解锁，那么，插入运行专业软件的 USB，或者点击会插入恶意软件的网络链接，就可以在几秒内完成提取浏览器信息用以分析的操作。 虽然浏览器会加密密码，但是，当浏览器使用这些密码的时候，它们会进行解密，因此可以被任意进程访问。”</p>
<p>然后，通过这些信息（Exabeam 称之为“网络卷宗”），网络犯罪分子可以如何使用它们呢？</p>
<p>** 账号发现 **</p>
<p>“攻击者可以从你的 URL 历史（包括工作应用和个人理财网站），得出你经常使用的应用列表。例如，犯罪分子可以了解公司中有哪些人可以访问财务或工资应用，然后编译出一个可供利用的用户名单，” Benson 说。</p>
<p>“了解公司正在使用哪些应用可以帮助攻击者制作出更具说服力的钓鱼电子邮件，来试图欺骗用户，让他们交出密码，这样，攻击者便能有所收获。”</p>
<p>Benson 说，了解你的银行、在线经纪人或者退休基金经历的名字也并非难事。</p>
<p>** 位置记录 **</p>
<p>“我们能够从各种流行的网站（包括 nba.com 和 cbssports.com）提取不同级别的地理定位指标，包括 IP 地址。包括 cbsnews.com、cnn.com、usatoday.com、foxnews.com、telegraph.co.uk、nypost.com 和 nytimes.com 在内的新闻网站也会在用户的本地机器上存储用户的位置信息，” Benson 说。</p>
<p>“从 Web 浏览器上提取的历史位置信息，可以被用来绘制出用户的习惯和过去活动的图像。通过从广泛的网站中提取出相似类型的信息，调查者可以获得多个数据点，用来帮助确定不同的地理位置数据点。因此，攻击者可以确定一些信息，比方说，你的工作时间和在家时间。”</p>
<p>** 用户兴趣 **</p>
<p>“当然咯，通过访问你的 URL 历史，攻击者可以轻松了解到你的个人兴趣。攻击者可以通过两种方式来操纵这些信息。首先，众所周知，攻击者利用爱好来猜测密码，” Benson 说。</p>
<p>“其次，如果你的爱好或者兴趣具有争议性、不同寻常甚至是违法的，那么，你可能成为网上勒索的受害者。最后，随着网络暴力的不幸兴起，尤其是在青少年中，网络卷宗可能会被用来暴露受害者，或者让受害者难堪。”</p>
<p>** 设备发现 **</p>
<p>“现代浏览器向用户提供了一致性体验的选择，无论他们使用的是什么设备。因此，通过检查浏览器历史，是有可能提取出用户拥有的其他设备的信息的。” Benson 说。</p>
<p>“一些浏览器明确地在多个设备之间同步记录，而另一些浏览器利用“投射”或者其他屏幕共享方法来与其他设备通信。通过查看这些信息，也许能找到用户试图隐藏的设备，或者将个人机器连接到工作机器上。”</p>
<p>因此，就保护而言，Benson 说，确保终端防护，以及不要在公众场所解锁机器，二者都非常重要。用户还应该考虑修改浏览器设置，以进一步保护他们的隐私。</p>
]]></content>
      <tags>
        <tag>没事翻着玩</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>那些令人wow的小技巧集锦</title>
    <url>/2015/12/16/%E9%82%A3%E4%BA%9B%E4%BB%A4%E4%BA%BAwow%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7%E9%9B%86%E9%94%A6/</url>
    <content><![CDATA[<p>收集看到的好玩的技巧~~</p>
<h1 id="隐文术">隐文术</h1>
<p>如何将文件隐藏在一张图片中~~</p>
<h2 id="windows下">Windows下</h2>
<ol type="1">
<li>首先，你要准备一张图片，假设图片名称为image.png</li>
<li>把你要隐藏的文件压缩成rar，假设压缩后名称为mys.rar</li>
<li>cmd，输入命令：<code>copy /b image.png + mys.rar image2.png</code></li>
<li>此时，会在当前目录下生成image2.png文件。打开可以看到此文件跟image.png所展示的图片是一模一样的。给文件名加个后缀<code>.rar</code>，即修改为image2.png.rar。然后，你就可以看到前面的mys.rar文件了！！</li>
</ol>
<h2 id="linux下">Linux下</h2>
<ol type="1">
<li>首先，你要准备一张图片，假设图片名称为image.jpg</li>
<li>把你要隐藏的文件压缩成zip，假设压缩后名称为mys.zip</li>
<li>终端下，输入命令：<code>cat mys.zip &gt;&gt; image.jpg</code></li>
<li>此时，看到此文件跟原image.png所展示的图片是一模一样的。给文件名加个后缀<code>.zip</code>，即修改为image.jpg.zip。然后，你就可以看到前面的mys.zip文件了！！</li>
</ol>
<h1 id="热点wifi下的照片拦截">热点WIFI下的照片拦截</h1>
<h2 id="linux下-1">Linux下</h2>
<ol type="1">
<li>安装ARP欺骗工具ettercap: <code>apt-get install  ettercap-text-only</code></li>
<li>安装driftnet（用于抓取指定接口数据流上面图片的软件并且吧嗅探到的图片友好的显示在一个窗口当中的工具）：<code>apt-get install driftnet</code></li>
<li>进行欺骗： <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 192.168.1.101为目标IP，192.168.1.1为网关地址</span></span><br><span class="line"><span class="comment"># wlan0为自己电脑上的interface</span></span><br><span class="line">ettercap -i wlan0  -T -M arp:remote <span class="regexp">/192.168.1.1/</span> <span class="regexp">/192.168.1.101/</span></span><br></pre></td></tr></table></figure></li>
<li>启动driftnet：<code>driftnet -i wlan0</code>。此时，会弹出一个黑色的小框框，将其放大。</li>
<li>let's play~~ 目标IP浏览带有图片的网站时，所浏览的网站上的图片就会显示在上面的小框框中。</li>
</ol>
<p>注：目标IP可以通过神器nmap扫描：<code>nmap -sP 192.168.1.0/24</code>，获得同一个网段中的活跃主机</p>
]]></content>
      <categories>
        <category>hack</category>
      </categories>
      <tags>
        <tag>hack</tag>
      </tags>
  </entry>
  <entry>
    <title>链表及其Python的简单实现</title>
    <url>/2016/01/04/%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6Python%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="链表的形式">链表的形式</h1>
<p>单链接或双链接，已排序或未排序，循环的或非循环的</p>
<h2 id="双向链表">双向链表</h2>
<p>链表L中的每个元素都是一个对象，每个对象有一个关键字key和两个指针：next和prev，对象中还可以包含其他辅助数据（卫星数据）。若x是链表中的一个元素，则有： * x.next指向它在链表中的后继元素，x.prev指向它的前驱元素 * 若x.prev = None，则元素x是链表的第一个元素，即链表的头(head) * 若x.next = None, 则元素x是链表的最后一个元素，即链表的尾(tail) * L.head指向链表L的第一个元素，若L.head = None，则链表为空。</p>
<figure>
<img src="http://img.blog.csdn.net/20130426213000402" alt="双向链表" /><figcaption aria-hidden="true">双向链表</figcaption>
</figure>
<h2 id="单向链表">单向链表</h2>
<p>链表L中的每个元素都是一个对象，每个对象有一个关键字key和一个指针：next，对象中还可以包含其他辅助数据（卫星数据）</p>
<h2 id="已排序链表">已排序链表</h2>
<p>链表的线性顺序与链表元素中关键字的线性顺序一致。因此，最小的元素就是表头元素，最大的元素是表尾元素。</p>
<p>注：对于未排序链表，这各元素可以以任何顺序出现</p>
<h2 id="循环链表">循环链表</h2>
<p>链表L中的每个元素都是一个对象，每个对象有一个关键字key和两个指针：next和prev，对象中还可以包含其他辅助数据（卫星数据）。有： * 表头元素的prev指针指向表尾元素 * 表尾元素的next指针指向表头元素</p>
<h1 id="链表的操作">链表的操作</h1>
<p>注：以未排序且双链接链表为例</p>
<ol type="1">
<li>搜索 <figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"># 线性搜索，返回指向第一个关键字为k的元素的指针</span><br><span class="line"># 若无关键字为k的对象，则返回None</span><br><span class="line"># 最坏时间复杂度：O(n)，n为链表中元素个数</span><br><span class="line">LIST_SEARCH(L, k)</span><br><span class="line">    <span class="meta">x</span> = L.head</span><br><span class="line">    <span class="meta">while</span> <span class="meta">x</span> != None <span class="meta">and</span> <span class="meta">x</span>.<span class="meta">key</span> != k</span><br><span class="line">        <span class="meta">x</span> = <span class="meta">x</span>.next</span><br><span class="line">    <span class="meta">return</span> <span class="meta">x</span></span><br></pre></td></tr></table></figure></li>
<li>插入 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"># x为已设置好关键字key的元素</span><br><span class="line"># 将x插入到链表的前端</span><br><span class="line"># 时间复杂度：<span class="constructor">O(1)</span></span><br><span class="line"><span class="constructor">LIST_INSERT(L, <span class="params">x</span>)</span></span><br><span class="line">    x.next = <span class="module-access"><span class="module"><span class="identifier">L</span>.</span></span>head</span><br><span class="line">    <span class="keyword">if</span> <span class="module-access"><span class="module"><span class="identifier">L</span>.</span></span>head != None # 若L不为空链表，则将L原第一个元素指向x</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">L</span>.</span></span>head.prev = x</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">L</span>.</span></span>head = x</span><br><span class="line">    x.prev = None</span><br></pre></td></tr></table></figure> <img src="" alt="链表的插入" /></li>
<li>删除 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x是指向要删除元素</span></span><br><span class="line"><span class="comment"># 若要删除具有给定关键字值的元素，必须先调用LIST_SEARCH找到该元素</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(1)</span></span><br><span class="line">LIST_DELETE(L,x)</span><br><span class="line">    <span class="keyword">if</span> x.prev != <span class="literal">None</span></span><br><span class="line">        x.prev.<span class="built_in">next</span> = x.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">else</span> L.head = x.<span class="built_in">next</span> <span class="comment"># x是第一个元素</span></span><br><span class="line">    <span class="keyword">if</span> x.<span class="built_in">next</span> != <span class="literal">None</span> <span class="comment"># 若x不是最后一个元素</span></span><br><span class="line">        x.<span class="built_in">next</span>.prev = x.prev</span><br></pre></td></tr></table></figure></li>
<li>简化操作：哨兵 哨兵L.nil是一个哑对象，表示None，其作用是简化边界条件的处理。 将常规的双向链表转变为一个有哨兵的双向循环链表：
<ul>
<li>哨兵L.nil位于表头和表尾之间</li>
<li>属性L.nil.next指向表头，L.nil.prev指向表尾</li>
<li>表尾的next属性和表头的prev属性同时指向L.nil</li>
<li>把对L.head的引用代替为对L.nil.next的引用</li>
<li>一个空的链表只由一个哨兵构成，L.nil.next和L.nil.prev同时指向L.nil <img src="/img/201601051134.png" alt="带哨兵的双向循环链表" /> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LIST_SEARCH_SENTINEL(L,k)</span><br><span class="line">    x = L.nil.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> x != L.nil <span class="keyword">and</span> x.key != k:</span><br><span class="line">        x = x.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">LIST_INSERT_SENTINEL(L,x)</span><br><span class="line">    x.<span class="built_in">next</span> = L.nil.<span class="built_in">next</span></span><br><span class="line">    L.nil.<span class="built_in">next</span>.prev = x</span><br><span class="line">    L.nil.<span class="built_in">next</span> = x</span><br><span class="line">    x.prev = L.nil</span><br><span class="line">LIST_DELETE_SENTINEL(L,x)</span><br><span class="line">    x.prev.<span class="built_in">next</span> = x.<span class="built_in">next</span></span><br><span class="line">    x.<span class="built_in">next</span>.prev = x.prev</span><br></pre></td></tr></table></figure> 注意：仅当真正简化代码时才使用哨兵。</li>
</ul></li>
</ol>
<h1 id="python实现">Python实现</h1>
<p>结点对象： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,value=<span class="number">0</span>,prev=<span class="literal">None</span>,<span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        self.prev = prev</span><br></pre></td></tr></table></figure> 双向循环列表（无哨兵） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLink</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="comment"># 双向循环列表（无哨兵）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span> <span class="comment">#表头初始为None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self,key</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回指向第一个关键字为key的元素的指针</span></span><br><span class="line"><span class="string">           若无关键字为k的对象，则返回None</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        x = self.head</span><br><span class="line">        <span class="keyword">while</span> x != <span class="literal">None</span> <span class="keyword">and</span> x.value != key:</span><br><span class="line">            x = x.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;x为已设置好关键字key的元素</span></span><br><span class="line"><span class="string">           将x插入到链表的前端</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        x.<span class="built_in">next</span> = self.head</span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># 若不为空链</span></span><br><span class="line">            self.head.prev = x</span><br><span class="line">        self.head = x</span><br><span class="line">        x.prev = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;&#x27;删除元素&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x,DNode): x = self.search(x)</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> x.prev != <span class="literal">None</span>: <span class="comment"># x不是第一个结点</span></span><br><span class="line">            x.prev.<span class="built_in">next</span> = x.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>: self.head = x.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> x.<span class="built_in">next</span> != <span class="literal">None</span>: <span class="comment"># x不是最后一个结点</span></span><br><span class="line">            x.<span class="built_in">next</span>.prev = x.prev</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;打印链表&#x27;&#x27;&#x27;</span></span><br><span class="line">        x = self.head</span><br><span class="line">        <span class="keyword">while</span> x != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span> x.value</span><br><span class="line">            x = x.<span class="built_in">next</span></span><br></pre></td></tr></table></figure> 双向循环链表(带哨兵) <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkS</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="comment"># 带哨兵的双向循环链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.nil = DNode() <span class="comment"># 哨兵</span></span><br><span class="line">        self.nil.<span class="built_in">next</span> = self.nil <span class="comment"># 一个空的链表只由一个哨兵构成，L.nil.next和L.nil.prev同时指向L.nil</span></span><br><span class="line">        self.nil.prev = self.nil</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self,key</span>):</span></span><br><span class="line">        x = self.nil.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> x != self.nil <span class="keyword">and</span> x.value != key:</span><br><span class="line">            x = x.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x.<span class="built_in">next</span> = self.nil.<span class="built_in">next</span></span><br><span class="line">        self.nil.<span class="built_in">next</span>.prev = x</span><br><span class="line">        self.nil.<span class="built_in">next</span> = x</span><br><span class="line">        x.prev = self.nil</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x,DNode): x = self.search(x)</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line">        x.prev.<span class="built_in">next</span> = x.<span class="built_in">next</span></span><br><span class="line">        x.<span class="built_in">next</span>.prev = x.prev</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        x = self.nil.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> x != self.nil:</span><br><span class="line">            <span class="built_in">print</span> x.value</span><br><span class="line">            x = x.<span class="built_in">next</span></span><br></pre></td></tr></table></figure> # 单向链表实现的其他结构 ## 单向链表结点 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,value,<span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure> ## 单向链表 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self,key</span>):</span></span><br><span class="line">        x = self.head</span><br><span class="line">        <span class="keyword">while</span> x != <span class="literal">None</span> <span class="keyword">and</span> x.value != key:</span><br><span class="line">            x = x.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self,x</span>):</span> <span class="comment"># 插入到链表头</span></span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            x.<span class="built_in">next</span> = self.head</span><br><span class="line">        self.head = x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self,key</span>):</span></span><br><span class="line">        prev, x = <span class="literal">None</span>, self.head</span><br><span class="line">        <span class="comment">#查找第一个值为key的元素x，并保留x前的元素prev</span></span><br><span class="line">        <span class="keyword">while</span> x != <span class="literal">None</span> <span class="keyword">and</span> x.value != key:</span><br><span class="line">            prev = x</span><br><span class="line">            x = x.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> prev: <span class="comment"># x不是第一个元素</span></span><br><span class="line">            prev.<span class="built_in">next</span> = x.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.head = x.<span class="built_in">next</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        x = self.head</span><br><span class="line">        <span class="keyword">while</span> x != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span> x.value</span><br><span class="line">            x = x.<span class="built_in">next</span></span><br></pre></td></tr></table></figure> ## 栈 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单链表实现栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UNDERFLOW</span>(<span class="params">Exception</span>):</span><span class="keyword">pass</span> <span class="comment"># 下溢</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackL</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">    <span class="comment">#测试一个栈是否为空</span></span><br><span class="line">    STACK_EMPTY = <span class="keyword">lambda</span> self: self.head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment">#插入元素到栈顶</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PUSH</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            x.<span class="built_in">next</span> = self.head          </span><br><span class="line">        self.head = x</span><br><span class="line">    <span class="comment">#将栈顶元素返回并删除</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">POP</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.STACK_EMPTY():</span><br><span class="line">            <span class="keyword">raise</span> UNDERFLOW(<span class="string">&quot;stack is empty&quot;</span>)</span><br><span class="line">        x = self.head</span><br><span class="line">        self.head = x.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        x = self.head</span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span> x.value</span><br><span class="line">            x = x.<span class="built_in">next</span></span><br></pre></td></tr></table></figure> ## 队列 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UNDERFLOW</span>(<span class="params">Exception</span>):</span><span class="keyword">pass</span> <span class="comment"># 下溢</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueL</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = self.tail = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 判断队列是否为空</span></span><br><span class="line">    QUEUE_EMPTY = <span class="keyword">lambda</span> self: self.head == <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ENQUEUE</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.QUEUE_EMPTY(): <span class="comment">#空队列，队头队尾都执行同一个元素</span></span><br><span class="line">            self.head = self.tail = x</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#否则，队头保持不变，新元素放在队尾后</span></span><br><span class="line">            self.tail.<span class="built_in">next</span> = x</span><br><span class="line">            self.tail = x</span><br><span class="line">    <span class="comment"># 出队</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DEQUEUE</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.QUEUE_EMPTY(): <span class="keyword">raise</span> UNDERFLOW(<span class="string">&quot;the queue is empty&quot;</span>)</span><br><span class="line">        x = self.head</span><br><span class="line">        self.head = x.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        x = self.head</span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span> x.value</span><br><span class="line">            x = x.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>香蕉派+悦读fm:打造红外遥控FM播放器</title>
    <url>/2016/01/26/%E9%A6%99%E8%95%89%E6%B4%BE+%E6%82%A6%E8%AF%BBfm%20--%20%E6%89%93%E9%80%A0%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7FM%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    <content><![CDATA[<p>最近天气冷得整个人都不好了，早上怎么都起不了床。于是想着可以在被窝里听听FM，以便催化我的清醒度。手机上的app可以听FM呀，但是还要解锁，打开app，然后选音频。太烦了，还不如遥控器直接。</p>
<p>某天，把自己的小音箱上老闪老闪的LED给剪了，然后就不怕把它放在卧室会影响睡眠了。另外，香蕉派自己内置了红外接收装置，而前不久买的arduino套件里面就有一个红外遥控器恰好可用。 总结下需要的硬件： 1. banana pro 一块 （配置可上网） 2. 小音箱一个 3. 红外遥控器一个</p>
<h1 id="安装红外ir">安装红外IR</h1>
<ol type="1">
<li><p>安装lirc(一个开源的红外控制软件)： <code>sudo apt-get install lirc</code></p></li>
<li><p>修改<code>/etc/lirc/hardware.conf</code>文件内容： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/lirc/hardware.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Arguments which will be used when launching lircd</span></span><br><span class="line">LIRCD_ARGS=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Don&#x27;t start lircmd even if there seems to be a good config file</span></span><br><span class="line"><span class="comment">#START_LIRCMD=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Don&#x27;t start irexec, even if a good config file seems to exist.</span></span><br><span class="line"><span class="comment">#START_IREXEC=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Try to load appropriate kernel modules</span></span><br><span class="line"><span class="comment"># if LOAD_MODULES=false , modules must be preloaded, i.e. during boot (/etc/modules)</span></span><br><span class="line">LOAD_MODULES=<span class="literal">true</span></span><br><span class="line"><span class="comment">#MODULES=&quot;sun4i_ir&quot;</span></span><br><span class="line"><span class="comment"># newer kernel</span></span><br><span class="line">MODULES=<span class="string">&quot;sunxi-ir&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run &quot;lircd --driver=help&quot; for a list of supported drivers.</span></span><br><span class="line">DRIVER=<span class="string">&quot;devinput&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># usually /dev/lirc0 is the correct setting for systems</span></span><br><span class="line">DEVICE=<span class="string">&quot;/dev/input/event0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Default configuration files for your hardware if any</span></span><br><span class="line">LIRCD_CONF=<span class="string">&quot;/etc/lirc/lircd.conf&quot;</span></span><br><span class="line">LIRCMD_CONF=<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>测试是否可以识别遥控器： <code>sudo evttest</code> &gt;如果没有装，要先安装evttest。 &gt;运行命令后，就开始安静，若控制台有打印出什么，说明遥控器可被识别</p></li>
<li><p>下载记录遥控器的命令的模板： <code>wget http://lirc.sourceforge.net/remotes/generic/NEC.conf</code></p></li>
<li><p>获取可用按键名： <code>irrecord -l</code> &gt;根据自己要记录的按键，把每个名字先想好</p></li>
<li><p>记录按键： <code>irrecord -H devinput -d /dev/input/event0 NEC.conf</code> &gt;按照提示，输入第5步所想好的按键名并按下对应的按键。</p></li>
<li><p>最后生成的<code>NEC.conf.conf</code>文件中，按键部分如下： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">begin codes</span><br><span class="line">        KEY_CHANNELDOWN          0x01004500000001 0x00000000000000</span><br><span class="line">        KEY_CHANNEL              0x01004600000001 0x00000000000000</span><br><span class="line">        KEY_CHANNELUP            0x01004700000001 0x00000000000000</span><br><span class="line">        KEY_PREVIOUS             0x01004400000001 0x00000000000000</span><br><span class="line">        KEY_NEXT                 0x01004000000001 0x00000000000000</span><br><span class="line">end codes</span><br></pre></td></tr></table></figure> 将最后一列的<code>0x00000000000000</code>删除后保存，然后将<code>NEC.conf.conf</code>文件拷贝到<code>/etc/lirc/lircd.conf</code>里。 &gt;注意：<code>/etc/lirc/lircd.conf</code>的第一行不能为空</p></li>
<li><p>重启lirc： <code>sudo /etc/init.d/lirc restart</code> 输出如下： <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">root</span>@<span class="selector-tag">lemaker</span>:/<span class="selector-tag">etc</span>/<span class="selector-tag">lirc</span># <span class="selector-tag">sudo</span> /<span class="selector-tag">etc</span>/<span class="selector-tag">init</span><span class="selector-class">.d</span>/<span class="selector-tag">lirc</span> <span class="selector-tag">restart</span></span><br><span class="line"><span class="selector-attr">[ ok ]</span> <span class="selector-tag">Stopping</span> <span class="selector-tag">execution</span> <span class="selector-tag">daemon</span>: <span class="selector-tag">irexec</span><span class="selector-pseudo">:.</span></span><br><span class="line"><span class="selector-attr">[ ok ]</span> <span class="selector-tag">Stopping</span> <span class="selector-tag">remote</span> <span class="selector-tag">control</span> <span class="selector-tag">daemon</span>(s): <span class="selector-tag">LIRC</span><span class="selector-pseudo">:.</span></span><br><span class="line"><span class="selector-attr">[ ok ]</span> <span class="selector-tag">Loading</span> <span class="selector-tag">LIRC</span> <span class="selector-tag">modules</span><span class="selector-pseudo">:.</span></span><br><span class="line"><span class="selector-attr">[ ok ]</span> <span class="selector-tag">Starting</span> <span class="selector-tag">remote</span> <span class="selector-tag">control</span> <span class="selector-tag">daemon</span>(s) : <span class="selector-tag">LIRC</span> <span class="selector-pseudo">:.</span></span><br><span class="line"><span class="selector-attr">[ ok ]</span> <span class="selector-tag">Starting</span> <span class="selector-tag">execution</span> <span class="selector-tag">daemon</span>: <span class="selector-tag">irexec</span><span class="selector-pseudo">:.</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>测试验证 <code>irw</code> &gt;按下遥控器上刚才配置的按键，若出现了内容，则表示配置成功。例如： <figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">root<span class="variable">@lemaker</span><span class="symbol">:/etc/lirc</span><span class="comment"># irw</span></span><br><span class="line">0001004700000001 00 KEY_CHANNELUP xixi</span><br><span class="line">0001004000000001 00 KEY_NEXT xixi</span><br></pre></td></tr></table></figure> # 编写红外遥控脚本 ## 获得悦读FM的文章信息 悦读FM提供了一个脚本，可以获取文章的信息：<a href="https://github.com/yuedu-fm/yuedu.fm-fetcher">yuedu.fm-fetcher</a> 根据指导，可以得到位于output目录下的文章信息。</p></li>
</ol>
<h2 id="配置lircrc文件">配置lircrc文件</h2>
<p>lircrc文件可以是/etc/lirc/lircrc，或者~/.lircrc <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@lemaker:/etc/lirc<span class="comment"># cat lircrc</span></span><br><span class="line">begin</span><br><span class="line">    prog = xixi</span><br><span class="line">    button = KEY_CHANNELDOWN <span class="comment"># 按键信息</span></span><br><span class="line">    config = KEY_CHANNELDOWN <span class="comment"># 按键对应的配置</span></span><br><span class="line">end</span><br><span class="line">begin</span><br><span class="line">    prog = xixi</span><br><span class="line">    button = KEY_CHANNEL</span><br><span class="line">    config = KEY_CHANNEL</span><br><span class="line">end</span><br><span class="line">begin</span><br><span class="line">    prog = xixi</span><br><span class="line">    button = KEY_CHANNELUP</span><br><span class="line">    config = KEY_CHANNELUP</span><br><span class="line">end</span><br><span class="line">begin</span><br><span class="line">    prog = xixi</span><br><span class="line">    button = KEY_PREVIOUS</span><br><span class="line">    config = KEY_PREVIOUS</span><br><span class="line">end</span><br><span class="line">begin</span><br><span class="line">    prog = xixi</span><br><span class="line">    button = KEY_NEXT</span><br><span class="line">    config = KEY_NEXT</span><br><span class="line">end</span><br><span class="line">begin</span><br><span class="line">    prog = xixi</span><br><span class="line">    button = KEY_PLAY</span><br><span class="line">    config = KEY_PLAY</span><br><span class="line">end</span><br></pre></td></tr></table></figure> ## 安装python-lirc <code>sudo apt-get install python-lirc</code></p>
<h2 id="编写脚本">编写脚本</h2>
<p>play.py <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> lirc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span>():</span></span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	获得悦读FM音频列表</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">	items = [item <span class="keyword">for</span> item <span class="keyword">in</span> os.listdir(<span class="string">&quot;./output&quot;</span>) <span class="keyword">if</span> item.startswith(<span class="string">&quot;articles&quot;</span>)]</span><br><span class="line">	item = items[random.randint(<span class="number">0</span>,<span class="built_in">len</span>(items)-<span class="number">1</span>)]</span><br><span class="line">	articles = json.load(file(os.path.join(<span class="string">&quot;./output&quot;</span>,item)))</span><br><span class="line">	<span class="keyword">for</span> art <span class="keyword">in</span> articles[<span class="string">&quot;list&quot;</span>]:</span><br><span class="line">		os.popen(<span class="string">&quot;mpg123 &quot;</span> + art[<span class="string">&quot;audio&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	sockid = lirc.init(<span class="string">&quot;xixi&quot;</span>)</span><br><span class="line">	rc = lirc.nextcode()</span><br><span class="line">	<span class="built_in">print</span> rc</span><br><span class="line">	<span class="keyword">if</span> <span class="string">&quot;KEY_PLAY&quot;</span> <span class="keyword">in</span> rc: <span class="comment">#&quot;KEY_PLAY&quot;对应遥控器上的PLAY键</span></span><br><span class="line">		play()</span><br></pre></td></tr></table></figure> ## 测试一下 1. 运行：<code>python play.py</code> 2. 按下遥控器上的PLAY键 3. 享受FM吧~~</p>
<h1 id="可以怎么用">可以怎么用？</h1>
<ol type="1">
<li>把获得悦读FM的文章信息的脚本加入crontab，这样就可以定时检查更新了</li>
<li>把脚本加入开机自启动，这样即使小派不小心重启也不怕</li>
</ol>
<h1 id="接下来">接下来……</h1>
<ol type="1">
<li>新增几个channel，可以选择播放豆瓣FM，本地音乐集等等</li>
<li>监控按键信息，可以选择下一首</li>
<li>实现PAUSE功能</li>
<li>对接显示屏，显示正在播放的音频的名字~</li>
</ol>
<h1 id="参考文档">参考文档</h1>
<ol type="1">
<li><a href="http://www.withonly.com/?p=515">香蕉派（Banana Pi）使用红外IR之安装篇</a></li>
<li><a href="https://pypi.python.org/pypi/python-lirc/1.2.1">python-lirc 1.2.1</a></li>
<li><a href="http://www.lirc.org/html/configure.html">The lircrc file format</a></li>
</ol>
]]></content>
      <categories>
        <category>香蕉派</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>香蕉派</tag>
        <tag>随便折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>香蕉派+悦读fm:打造红外遥控FM播放器（续）</title>
    <url>/2016/02/02/%E9%A6%99%E8%95%89%E6%B4%BE+%E6%82%A6%E8%AF%BBfm%20--%20%E6%89%93%E9%80%A0%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7FM%E6%92%AD%E6%94%BE%E5%99%A8%EF%BC%88%E7%BB%AD%EF%BC%89/</url>
    <content><![CDATA[<p>前面的<a href="/2016/01/26/香蕉派+悦读fm%20--%20打造红外遥控FM播放器/">香蕉派+悦读fm:打造红外遥控FM播放器</a>讲了怎么使用红外遥控。当时留了一个接下来的任务。这两天弄完并经过长时间的验证，觉得尚可行。那么回家前就说说怎么增加按键控制和频道选择吧</p>
<h1 id="安装mplayer">安装mplayer</h1>
<p>之前用的是mpg123。虽然mpg123有个命令参数<code>-C</code>可以进行基本的音量控制，播放控制等操作，但是无奈它并不支持PIPE控制，因此python.subprocess也就派不上用场。而虽然它还有一个参数<code>-R</code>配合<code>--fifo</code>可以进行远程操作，也就是PIPE可用。但还有个问题，在这种远程操作模式下可用命令是非常有限的，其实就没有我想要的可以上下切音频的命令。因此，转而用mplayer。</p>
<p>MPlayer有一个参数<code>-slave</code>，配合另一个选项<code>-input filename</code>使用，可以往<code>filename</code>中写入命令（<code>mplayer -input cmdlist</code>可以显示所有可用命令）以控制MPlayer，达到控制音量、上下切换音频等目的。</p>
<p>安装mplayer很简单，直接<code>apt-get install mplayer</code>即可。 安装后测试使用：<code>mplayer xxx.mp3</code>。</p>
<p>不知道怎么的，虽然安装顺利，但是在使用的时候会遇到例如<code>libbcm_host.so</code>文件缺失之类的问题。这个文件在香蕉派中完全查不到任何信息，但是却在树莓派的firmware里面找到了。死马当活马医吧。把缺失的<code>.so</code>文件在<a href="https://github.com/raspberrypi/firmware/tree/master/opt/vc/lib">respberrypi/firmware/opt/vc/lib/</a>下找到后，下载到香蕉派的<code>/usr/lib</code>目录下。Bingo，最后居然也可用了。</p>
<h1 id="写点代码">写点代码</h1>
<h2 id="配置lircr文件">配置lircr文件</h2>
<p>将/etc/lirc/lircr文件修改如下： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># XIXI MODES BEGIN</span></span><br><span class="line">begin xixi</span><br><span class="line">	begin</span><br><span class="line">		prog = xixi</span><br><span class="line">		button = KEY_PREVIOUS</span><br><span class="line">		config = KEY_PREVIOUS</span><br><span class="line">	end</span><br><span class="line">	begin</span><br><span class="line">		prog = xixi</span><br><span class="line">		button = KEY_NEXT</span><br><span class="line">		config = KEY_NEXT</span><br><span class="line">	end</span><br><span class="line">	begin</span><br><span class="line">		prog = xixi</span><br><span class="line">		button = KEY_PLAY</span><br><span class="line">		config = KEY_PLAY <span class="comment">#这两个配置的意思是，按一次KEY_PLAY会得到KEY_PLAY</span></span><br><span class="line">		config = KEY_PAUSE <span class="comment"># 再按一次，会得到KEY_PAUSE，这样轮流取值</span></span><br><span class="line">	end</span><br><span class="line">	begin</span><br><span class="line">		prog = xixi</span><br><span class="line">		button = KEY_VOLUMEDOWN</span><br><span class="line">		config = KEY_VOLUMEDOWN</span><br><span class="line">	end</span><br><span class="line">	begin</span><br><span class="line">		prog = xixi</span><br><span class="line">		button = KEY_VOLUMEUP</span><br><span class="line">		config = KEY_VOLUMEUP</span><br><span class="line">	end</span><br><span class="line">	begin</span><br><span class="line">		prog = xixi</span><br><span class="line">		button = KEY_EQUAL</span><br><span class="line">		config = KEY_EQUAL</span><br><span class="line">	end</span><br><span class="line">	begin</span><br><span class="line">		prog = xixi</span><br><span class="line">		button = KEY_0</span><br><span class="line">		config = KEY_0</span><br><span class="line">	end</span><br><span class="line">	begin</span><br><span class="line">		prog = xixi</span><br><span class="line">		button = KEY_1</span><br><span class="line">		config = KEY_1</span><br><span class="line">	end</span><br><span class="line">end xixi</span><br></pre></td></tr></table></figure> ## 频道0：播放本地音乐 因为我们需要全局控制进行，因此，使用subprocess后，应该还要返回一个子进程对象。 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_local_music</span>():</span></span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	local musics in /samba/DLNA/Music/</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">	path = <span class="string">r&quot;/samba/DLNA/Music/*.*&quot;</span> <span class="comment"># 本地音乐存储目录</span></span><br><span class="line">	child_process =	subprocess.Popen(<span class="string">&quot;mplayer -slave -input file=cmd_pannel -shuffle -quiet %s&quot;</span> % path, <span class="comment">#若使用列表，会导致没法播放指定目录下的所有文件</span></span><br><span class="line">		shell=<span class="literal">True</span>,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">return</span> child_process, []</span><br></pre></td></tr></table></figure> ## 频道1：播放悦读FM 同样的，要返回一个子进程对象。 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_yuedu_fm</span>():</span></span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	yuedu.fm</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">	path = <span class="string">r&quot;./yuedu.fm-fetcher/output&quot;</span> <span class="comment"># yuedu.fm的音频信息保存目录</span></span><br><span class="line">	items = [item <span class="keyword">for</span> item <span class="keyword">in</span> os.listdir(path) <span class="keyword">if</span> item.startswith(<span class="string">&quot;articles&quot;</span>)]</span><br><span class="line">	item = items[random.randint(<span class="number">0</span>,<span class="built_in">len</span>(items)-<span class="number">1</span>)] <span class="comment"># 随机选择一个articles</span></span><br><span class="line">	articles = json.load(file(os.path.join(path,item)))</span><br><span class="line">  play_list = [art[<span class="string">&quot;audio&quot;</span>] <span class="keyword">for</span> art <span class="keyword">in</span> articles[<span class="string">&quot;list&quot;</span>]]</span><br><span class="line">	child_process =	subprocess.Popen(</span><br><span class="line">		[<span class="string">&quot;mplayer&quot;</span>,<span class="string">&#x27;-cache&#x27;</span>, <span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;-cache-min&#x27;</span>, <span class="string">&#x27;70&#x27;</span>,<span class="string">&#x27;-slave&#x27;</span>,<span class="string">&#x27;-input&#x27;</span>, <span class="string">&#x27;file=cmd_pannel&#x27;</span>,<span class="string">&#x27;-quiet&#x27;</span>] + play_list]</span><br><span class="line">	) <span class="comment"># 是滴，这里就是用slave模式</span></span><br><span class="line">	<span class="keyword">return</span> (child_process, play_list)</span><br></pre></td></tr></table></figure> ## 其他播放控制 用slave模式打开MPlayer后，我们就可以往控制文件(这里是<code>cmd_pannel</code>)写入命令来控制了播放上/下一首、音量增减、暂停/播放和关闭。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> lirc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_next</span>():</span> <span class="comment">#播放下一首</span></span><br><span class="line">	os.popen(<span class="string">&quot;echo &#x27;pt_step 1&#x27; &gt; cmd_pannel&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_prev</span>():</span> <span class="comment">#播放上一首</span></span><br><span class="line">	os.popen(<span class="string">&quot;echo &#x27;pt_step -1&#x27; &gt; cmd_pannel&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_pause</span>():</span> <span class="comment">#暂停/播放</span></span><br><span class="line">	os.popen(<span class="string">&quot;echo &#x27;pause&#x27; &gt; cmd_pannel&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">volumn_down</span>():</span> <span class="comment"># 减少音量</span></span><br><span class="line">	os.popen(<span class="string">&quot;echo &#x27;volume -10&#x27; &gt; cmd_pannel&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">volumn_up</span>():</span> <span class="comment"># 增加音量</span></span><br><span class="line">	os.popen(<span class="string">&quot;echo &#x27;volume 10&#x27; &gt; cmd_pannel&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quit</span>(<span class="params">child_process</span>):</span> <span class="comment"># 退出Mplayer。这里需要传递一个子进程对象</span></span><br><span class="line">	os.popen(<span class="string">&quot;echo &#x27;quit&#x27; &gt; cmd_pannel&quot;</span>)</span><br><span class="line">	child_process.terminate() <span class="comment"># 有时候这里的terminate会关不干净</span></span><br><span class="line">	os.system(<span class="string">&quot;killall -9 mplayer&quot;</span>) <span class="comment"># 以防万一</span></span><br><span class="line">	os.popen(<span class="string">&quot;echo &#x27;&#x27; &gt; cmd_pannel&quot;</span>) <span class="comment"># 以防下次启动MPlayer时里面的值会影响</span></span><br></pre></td></tr></table></figure>
<h2 id="把它们放在一起">把它们放在一起</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">no_operation</span>(<span class="params">*args,**kw</span>):</span> <span class="comment"># 默认操作</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>,[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	channel_map = &#123; <span class="comment"># 频道映射</span></span><br><span class="line">		<span class="string">&quot;KEY_0&quot;</span> : play_local_music,</span><br><span class="line">		<span class="string">&quot;KEY_1&quot;</span> : play_yuedu_fm,</span><br><span class="line">	&#125;</span><br><span class="line">	operation_map = &#123; <span class="comment"># 命令映射</span></span><br><span class="line">		<span class="string">&quot;KEY_PREVIOUS&quot;</span> : play_prev,</span><br><span class="line">		<span class="string">&quot;KEY_NEXT&quot;</span> : play_next,</span><br><span class="line">		<span class="string">&quot;KEY_PLAY&quot;</span> : play_pause,</span><br><span class="line">		<span class="string">&quot;KEY_PAUSE&quot;</span> : play_pause,</span><br><span class="line">		<span class="string">&quot;KEY_VOLUMEDOWN&quot;</span> : volumn_down,</span><br><span class="line">		<span class="string">&quot;KEY_VOLUMEUP&quot;</span> : volumn_up,</span><br><span class="line">		<span class="string">&quot;KEY_EQUAL&quot;</span> : quit,</span><br><span class="line">	&#125;</span><br><span class="line">	sockid = lirc.init(<span class="string">&quot;xixi&quot;</span>)</span><br><span class="line">	pid, play_list = <span class="literal">None</span>, []</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 不断轮询</span></span><br><span class="line">		rc = lirc.nextcode()</span><br><span class="line">		<span class="keyword">if</span> rc <span class="keyword">and</span> rc[<span class="number">0</span>] <span class="keyword">in</span> channel_map: <span class="comment"># 若按键是频道按键</span></span><br><span class="line">			<span class="keyword">if</span> pid: quit(pid) <span class="comment"># 若之前有子进程在运行，先把它干掉</span></span><br><span class="line">			pid, play_list = channel_map.get(rc[<span class="number">0</span>],no_operation)()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">if</span> <span class="string">&quot;KEY_EQUAL&quot;</span> <span class="keyword">in</span> rc <span class="keyword">and</span> pid: <span class="comment"># 退出子进程</span></span><br><span class="line">			operation_map.get(<span class="string">&quot;KEY_EQUAL&quot;</span>,no_operation)(pid)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">if</span> rc:</span><br><span class="line">			operation_map.get(rc[<span class="number">0</span>], no_operation)()</span><br></pre></td></tr></table></figure>
<h1 id="最后">最后……</h1>
<ol type="1">
<li>把它放在/etc/rc.local文件中，设置开机自启动，然后想干啥干啥。</li>
<li>目前我只用了两个频道，要增添频道只要修改lircrc文件，增加频道映射和相应的播放函数即可</li>
<li>♪(<sup>∇</sup>*)可以回家了~~</li>
</ol>
<h1 id="参考文档">参考文档</h1>
<ul>
<li><code>man mplayer</code></li>
<li><a href="http://www.mplayerhq.hu/DOCS/tech/slave.txt">Mplayer slave mode</a></li>
</ul>
]]></content>
      <categories>
        <category>香蕉派</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>香蕉派</tag>
        <tag>随便折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB初识之查询</title>
    <url>/2015/11/11/MongoDB%E5%88%9D%E8%AF%86%E4%B9%8B%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h1 id="查询">查询</h1>
<h2 id="find">find</h2>
<p>使用find进行查询，返回一个集合中文档的子集，子集合的范围从0个文档到整个集合。 <code>find ( query , fields , limit , skip, batchSize, options )</code> * query：查询器文档，决定了要返回哪些文档，这个参数说明了要执行的查询细节 1. 默认为{}，表示匹配集合的全部内容。例如：<code>&gt; db.c.find()</code> 2. 支持多个键/值对的方式将多个查询条件组合在一起。例如：<code>&gt; db.users.find(&#123;"username":"joe","age":27&#125;)</code> * fields：指定返回的键 1. 使用此参数的好处：节省传输的数据量，节省客户端解码文档的时间和内存消耗 2. 使用举例：<code>&gt; db.users.find(&#123;&#125;,&#123;"username":1,"emails":1&#125;)</code> 3. 注意，"_id"这个键总是被返回，即便是没有指定也一样 4. 也可以用来剔除查询结果中的某个键/值对。例如：<code>&gt; db.users.find(&#123;&#125;,&#123;"emails":0&#125;)</code> * limit * skip * batchSize * options</p>
<h2 id="查询条件">查询条件</h2>
<h3 id="比较查询">比较查询</h3>
<p>四种比较操作符："<span class="math inline">\(lt&quot;(&lt;), &quot;\)</span>lte"(&lt;=), "<span class="math inline">\(gt&quot;(&gt;), &quot;\)</span>gte"(&gt;=) <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询在18~30岁（含）的用户</span></span><br><span class="line">&gt; db.users.<span class="builtin-name">find</span>(&#123;<span class="string">&quot;age&quot;</span>:&#123;<span class="string">&quot;<span class="variable">$gte</span>&quot;</span>:18,<span class="string">&quot;<span class="variable">$lte</span>&quot;</span>:30&#125;&#125;)</span><br></pre></td></tr></table></figure> 条件操作符："<span class="math inline">\(ne&quot;(&lt;&gt;，用于所有类型的数据) <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询所有名字不为joe的用户</span></span><br><span class="line">&gt; db.users.<span class="builtin-name">find</span>(&#123;<span class="string">&quot;username&quot;</span>:&#123;<span class="string">&quot;<span class="variable">$ne</span>&quot;</span>:<span class="string">&quot;joe&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure> ### OR查询 两种方式 * &quot;\)</span>in"用来查询一个键的多个值 * "$or"用来完成多个键值的任意给定值 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在raffle中查找ticket_no在[725,542,390]中的文档</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&quot;<span class="variable">$in</span>&quot;</span>还可以指定不同类型的条件和值</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.raffle.find(&#123;<span class="string">&quot;ticket_no&quot;</span>:&#123;<span class="string">&quot;<span class="variable">$in</span>&quot;</span>:[725,542,390]&#125;&#125;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&quot;<span class="variable">$nin</span>&quot;</span>将返回与数组中所有条件都不匹配的文档</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面这个语句就是查找ticket_no不在[725,542,390]中的文档</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.raffle.find(&#123;<span class="string">&quot;ticket_no&quot;</span>:&#123;<span class="string">&quot;<span class="variable">$nin</span>&quot;</span>:[725,542,390]&#125;&#125;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&quot;<span class="variable">$or</span>&quot;</span>接受一个包含所有可能条件的数组作为参数</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.raffle.find(&#123;<span class="string">&quot;<span class="variable">$or</span>&quot;</span>:[&#123;<span class="string">&quot;ticket_no&quot;</span>:725&#125;,&#123;<span class="string">&quot;winner&quot;</span>:<span class="literal">true</span>&#125;]&#125;)</span></span><br></pre></td></tr></table></figure> 注意：对于OR类型的查询，第一个条件尽可能匹配更多的文档，这样才最为有效</p>
<h3 id="not-not元条件句可以用在任何其他条件之上与正则表达式联合使用可以用来查找那些与特定模式不符的文档"><span class="math inline">\(not &quot;\)</span>not"：元条件句，可以用在任何其他条件之上。与正则表达式联合使用，可以用来查找那些与特定模式不符的文档。</h3>
<h3 id="条件句-v.s-修改器">条件句 V.S 修改器</h3>
<ol type="1">
<li>条件句是内层文档的键，修改器则是外层文档的键</li>
<li>可以对一个键应用多个条件，但是不能对一个键应用多个更新修改器</li>
</ol>
<h2 id="特定于类型的查询">特定于类型的查询</h2>
<h3 id="null">null</h3>
<ol type="1">
<li>null可以匹配自身</li>
<li>还可以匹配不存在。也就是说，这种匹配会返回缺少这个键的所有文档 <figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 下面这个语句会返回name值为null的文档</span></span><br><span class="line"><span class="meta"># 还会返回没有键值name的所有文档</span></span><br><span class="line">&gt; db.users.find(&#123;<span class="string">&quot;name&quot;</span>:<span class="literal">null</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>若只想匹配键值为null的文档，既要检查该键的值是否为null，还要通过"$exists"条件判定键值已存在 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt; db.c.<span class="builtin-name">find</span>(&#123;<span class="string">&quot;z&quot;</span>:&#123;<span class="string">&quot;<span class="variable">$in</span>&quot;</span>:[<span class="literal">null</span>],<span class="string">&quot;<span class="variable">$exists</span>&quot;</span>:true&#125;&#125;)</span><br></pre></td></tr></table></figure> ### 正则表达式 MongoDB使用Perl兼容的正则表达式（PCRE）库来匹配正则表达式。 <figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 忽略大小写：查找所有名为Joe或者joe的用户</span></span><br><span class="line">&gt; db.users.find(&#123;<span class="string">&quot;username&quot;</span><span class="symbol">:/joe/i</span>&#125;)</span><br><span class="line"><span class="comment"># 匹配各种大小写组合形式的joe</span></span><br><span class="line">&gt; db.users.find(&#123;<span class="string">&quot;username&quot;</span><span class="symbol">:/joe?/i</span>&#125;)</span><br><span class="line"><span class="comment"># 还可以匹配自身</span></span><br><span class="line">&gt; db.foo.insert(&#123;<span class="string">&quot;bar&quot;</span><span class="symbol">:/baz/</span>&#125;)</span><br><span class="line">&gt; db.foo.find(&#123;<span class="string">&quot;bar&quot;</span><span class="symbol">:/baz/</span>&#125;)</span><br></pre></td></tr></table></figure> ### 查询数组</li>
</ol>
<ul>
<li>$all：匹配一组元素，元素的顺序无关紧要 <figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">&gt; db.food.insert(&#123;<span class="string">&quot;_id&quot;</span>:<span class="number">1</span>,<span class="string">&quot;fruit&quot;</span>:[<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;kumquat&quot;</span>,<span class="string">&quot;orange&quot;</span>]&#125;)</span><br><span class="line">&gt; db.food.insert(&#123;<span class="string">&quot;_id&quot;</span>:<span class="number">2</span>,<span class="string">&quot;fruit&quot;</span>:[<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;kumquat&quot;</span>,<span class="string">&quot;orange&quot;</span>]&#125;)</span><br><span class="line">&gt; db.food.insert(&#123;<span class="string">&quot;_id&quot;</span>:<span class="number">3</span>,<span class="string">&quot;fruit&quot;</span>:[<span class="string">&quot;cherry&quot;</span>,<span class="string">&quot;banana&quot;</span>,<span class="string">&quot;apple&quot;</span>]&#125;)</span><br><span class="line"># 查找既有<span class="string">&quot;apple&quot;</span>又有<span class="string">&quot;banana&quot;</span>的文档</span><br><span class="line">&gt; db.food.find(&#123;<span class="string">&quot;fruit&quot;</span>:&#123;$all:[<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;banana&quot;</span>]&#125;&#125;)</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>, <span class="string">&quot;fruit&quot;</span> : [ <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;peach&quot;</span> ] &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="number">3</span>, <span class="string">&quot;fruit&quot;</span> : [ <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span> ] &#125;</span><br></pre></td></tr></table></figure></li>
<li><span class="math inline">\(size：查询指定长度的数组 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt; db.food.<span class="builtin-name">find</span>(&#123;<span class="string">&quot;fruit&quot;</span>:&#123;<span class="string">&quot;<span class="variable">$size</span>&quot;</span>:3&#125;&#125;)</span><br></pre></td></tr></table></figure> 注意：&quot;\)</span>size"不能与其他查询子句组合，但是这种查询可以通过在文档中添加一个"size"键的方式来实现。</li>
<li><span class="math inline">\(slice：返回数组的一个子集合 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 返回前10条评论。如果要返回后10条，使用-10即可</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.blog.posts.findOne(&#123;&#125;,&#123;<span class="string">&quot;comments&quot;</span>:&#123;<span class="string">&quot;<span class="variable">$slice</span>&quot;</span>:10&#125;&#125;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$slice</span>接受偏移值和要返回的元素数量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面这个语句返回第24~33个元素</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.blog.posts.findOne(&#123;&#125;,&#123;<span class="string">&quot;comments&quot;</span>:&#123;<span class="string">&quot;<span class="variable">$slice</span>&quot;</span>:[23,10]&#125;&#125;)</span></span><br></pre></td></tr></table></figure> 注意：如无特别声明，使用\)</span>slice会返回文档中所有键。</li>
</ul>
<h3 id="查询内嵌文档">查询内嵌文档</h3>
<p>两种方式： * 查询整个文档：与普通查询完全相同。要注意，这种查询与顺序是相关的。 * 只针对其键/值对进行查询 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.people.find(&#123;&quot;name.first&quot;:&quot;joe&quot;,&quot;name.last&quot;:&quot;Schemoe&quot;&#125;)</span><br></pre></td></tr></table></figure> 说明：点表示法是查询文档区别于其他文档的主要特点，查询文档时使用表示“深入内嵌文档内部”。因此，也要求待插入的文档不能包含“.”</p>
<h2 id="where查询-使用where子句可以执行任意javascript作为查询的一部分"><span class="math inline">\(where查询 使用&quot;\)</span>where"子句，可以执行任意JavaScript作为查询的一部分</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.foo.insert(&#123;&quot;apple&quot;:1,&quot;banana&quot;:6,&quot;peach&quot;:3&#125;)</span><br><span class="line">&gt; db.foo.insert(&#123;&quot;apple&quot;:8,&quot;spinach&quot;:4,&quot;watermelon&quot;:4&#125;)</span><br><span class="line"># 比较文档中两个键的值是否相等</span><br><span class="line"># 若函数返回true，文档就作为结果的一部分被返回；若为false，则不然</span><br><span class="line">&gt; db.foo.find(&#123;&quot;$where&quot;:function () &#123;</span><br><span class="line">... for (var current in this) &#123;</span><br><span class="line">...     for (var other in this) &#123;</span><br><span class="line">...         if (current !&#x3D; other &amp;&amp; this[current] &#x3D;&#x3D; this[other]) &#123;</span><br><span class="line">...             return true;</span><br><span class="line">...         &#125;</span><br><span class="line">...     &#125;</span><br><span class="line">... &#125;</span><br><span class="line">... return false;</span><br><span class="line">... &#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>注意：如非必要，一定要避免使用"<span class="math inline">\(where&quot;查询。因为它们在速度上比常规查询慢得多（每个文档都要从BSON转换成JavaScript对象，然后通过\)</span>where表达式运行。而且还不能用索引）</p>
<h2 id="游标">游标</h2>
<p>数据库使用游标返回find的执行结果 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用cursor变量保存结果</span><br><span class="line">&gt; var cursor &#x3D; db.c.find()</span><br><span class="line"># 使用游标的next方法来迭代结果，hasNext方法检查是否有后续结果存在</span><br><span class="line">&gt; while (cursor.hasNext()) &#123;</span><br><span class="line">... obj &#x3D; cursor.next()</span><br><span class="line">... &#x2F;&#x2F; do stuff</span><br><span class="line">... &#125;</span><br><span class="line"># 游标类实现了迭代器接口，可以在foreach循环中使用</span><br><span class="line">&gt; cursor.forEach(function(x) &#123;</span><br><span class="line">... print (x);</span><br><span class="line">... &#125;);</span><br></pre></td></tr></table></figure> ### limit, skip和sort 最常用的查询选项是限制返回结果的数量(limit)，忽略一定数量的结果(skip)并排序(sort)。所有这些选项一定要在查询被派发到服务器之前添加。 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 限制结果数量，limit指定上限</span></span><br><span class="line">&gt; db.c.<span class="builtin-name">find</span>().limit(3)</span><br><span class="line"><span class="comment"># 略过前n个匹配的文档，返回如下的文档。若匹配的文档少于n个，则不会返回任何文档</span></span><br><span class="line">&gt; db.c.<span class="builtin-name">find</span>().skip(3)</span><br><span class="line"><span class="comment"># sort用一个对象作为参数：一组键/值对。</span></span><br><span class="line"><span class="comment"># 键对应文档的键名，值代表排序的方向(1：升序；-1：降序)。</span></span><br><span class="line"><span class="comment"># 若指定了多个键，则按照多个键的顺序逐个排序</span></span><br><span class="line">&gt; db.c.<span class="builtin-name">find</span>().sort(&#123;x:1,age:-1&#125;)</span><br><span class="line"><span class="comment"># 可以组合来用。例如：分页</span></span><br><span class="line">&gt; db.stock.<span class="builtin-name">find</span>(&#123;<span class="string">&quot;desc&quot;</span>:<span class="string">&quot;mp3&quot;</span>&#125;).limit(50).skip(50).sort(&#123;<span class="string">&quot;price&quot;</span>:-1&#125;)</span><br></pre></td></tr></table></figure> 对于混合类型的键排序顺序是预先定义好的。从小到大，顺序如下： 1. 最小值 2. null 3. 数字（整型、长整型、双精度） 4. 字符串 5. 对象/文档 6. 数组 7. 二进制数据 8. 对象ID 9. 布尔型 10. 日期型 11. 时间戳 12. 正则表达式 13. 最大值</p>
<h3 id="避免使用skip略过大量结果">避免使用skip略过大量结果</h3>
<p>当skip的数量非常多的时候，会变得很慢，所以要尽量避免 * 不用skip对结果分页：一般来讲，可以找到一种方法实现不用skip的分页。 * 随机选取文档：可以在插入文档时给每个文档都添加一个额外的随机键以避免skip</p>
<h3 id="高级查询选项">高级查询选项</h3>
<p>两种查询： 1. 普通查询：<code>&gt; var cursor = db.foo.find(&#123;"foo":"bar"&#125;)</code> 2. 包装查询：<code>&gt; var cursor = db.foo.find(&#123;"foo":"bar"&#125;).sort(&#123;"x":1&#125;)</code>。这种查询实际上会被转化为<code>db.foo.find(&#123;"$query":&#123;"foo":"bar"&#125;, "$orderby": &#123;"x":1&#125;&#125;)</code> 下面是一些有用选项： * $maxscan：integer 指定查询最多扫描的文档数量 * $min：document 查询的开始条件 * $max：document 查询的结束条件 * $hint：document 指定服务器使用哪个索引进行查询 * $explain：boolean 获取查询执行的细节（用到的索引、结果数量、耗时等），而并非真正执行查询 * $snapshot：boolean 确保查询的结果是在查询执行的一致快照</p>
<h3 id="获取一致结果">获取一致结果</h3>
<p>当查找修改后存回去时，可能会出现由于文档体积增加而预留空间不足造成的移动。通常会将其挪至集合的末尾处。这样的情况下，游标有可能会返回那些已经被挪动的文档。 解决方法是对查询进行<strong>快照</strong>，也就是使用"$snapshot"选项。这个时候，查询是针对不变的集合视图运行的。</p>
<h2 id="在服务端的游标">在服务端的游标</h2>
<p>游标在服务端会消耗内存和其他资源：当游标遍历尽了结果以后或者客户端发来消息要求终止，数据库才会释放这些资源 导致游标终止（随后被清理）的一些情况： 1. 游标完成匹配结果的迭代时会清理自身； 2. 当游标在客户端已经不在作用域内了，驱动会向服务器发送专门的消息让其销毁游标； 3. 只要10分钟不使用游标，数据库游标就会自动销毁。</p>
<h1 id="索引">索引</h1>
<p>索引是用来加速查询的。 当查询中仅使用一个键时，可以对该键建立索引，以提高查询速度。 <figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># ensureIndex方法：创建索引</span></span><br><span class="line">&gt; db.users.ensureIndex(&#123;<span class="string">&quot;username&quot;</span>:<span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta"># 一组值为1（升序）或-1（降序）的键，表示索引创建的方向。</span></span><br><span class="line"><span class="meta"># 若索引只有一个键，则方向无关紧要</span></span><br><span class="line">&gt; db.posts.ensureIndex(&#123;<span class="string">&quot;date&quot;</span>:<span class="number">1</span>, <span class="string">&quot;username&quot;</span>:<span class="number">-1</span>&#125;)</span><br></pre></td></tr></table></figure> MongoDB的查询优化器会重排查询项的顺序，以便利用索引。 创建索引的缺点是每次插入、更新和删除时都会产生额外的开销（数据库不但需要执行这些操作，还要讲这些数据在集合的索引中标记）。</p>
<ul>
<li>使用索引前三问
<ol type="1">
<li>会做什么样的查询？其中哪些键需要索引？</li>
<li>每个键的索引方向是怎样的？</li>
<li>如何应对扩展？有没有种不同键的排列可以使常用数据更多地保留在内存中？</li>
</ol></li>
<li>为内嵌文档的键建立索引和为普通的键创建索引没有什么区别。而对内嵌文档的键索引与普通键索引并无差异，二者可以联合组成复合索引。</li>
<li>由于做无索引排序时有内存限制的，因此，可以按照排序来索引以便让MongoDB按照顺序提取数据。</li>
<li>索引名字
<ol type="1">
<li>每个索引都有一个字符串类型的名字，来唯一标识索引</li>
<li>默认情况下，索引名类似<code>keyname1_dir1_keyname2_dir2_..._keynameN_dirN</code>，其中keynameX代表索引的键，dirX代表索引的方向(-1/1)</li>
<li>可以自定义索引名字，例如：<code>&gt; db.foo.ensureIndex(&#123;"a":1,"b":-1&#125;, &#123;"name":"alphabet"&#125;)</code></li>
</ol></li>
</ul>
<h2 id="唯一索引">唯一索引</h2>
<p>唯一索引可以确保集合的每一个文档的指定键都有唯一值 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建唯一索引：&#123;<span class="string">&quot;unique&quot;</span>:<span class="literal">true</span>&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.users.ensureIndex(&#123;<span class="string">&quot;username&quot;</span>:1&#125;,&#123;<span class="string">&quot;unique&quot;</span>:<span class="literal">true</span>&#125;)</span></span><br></pre></td></tr></table></figure> * 记住，默认情况下，insert不检查文档是否插入过了。因此，可以使用安全插入。 * 对"_id"的索引是在创建普通集合时一通创建的。这个索引和普通唯一索引只有一点不同，就是不能删除。 * 插入时，若无对应键，索引会将其作为null存储。所以，如果对某个键建立了唯一索引，但插入了多个缺少该索引键的文档，则由于文档包含null值而导致插入失败。 * 当为已有集合创建索引时，若有些值已经重复了，则会创建索引失败。此时，可以使用<code>dropDups</code>选项保留发现的第一个文档，删除接下来的有重复值的文档。例如：<code>&gt; db.users.ensureIndex(&#123;"username":1&#125;,&#123;"unique":true, "dropDups:true"&#125;)</code> * 创建复合唯一索引时，单个键的值可以相同，只要所有键的值组合起来不同即可。</p>
<h2 id="explain和hint">explain和hint</h2>
<ul>
<li>explain：获得查询方面的信息。 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># explain会返回一个文档</span></span><br><span class="line"><span class="comment"># 文档中包含了查询使用的索引情况（若有），耗时及扫描文档数的统计信息。</span></span><br><span class="line">&gt; db.users.<span class="builtin-name">find</span>(&#123;<span class="string">&quot;age&quot;</span>:18&#125;).sort(&#123;<span class="string">&quot;username&quot;</span>:1&#125;).explain()</span><br></pre></td></tr></table></figure></li>
<li>hint：当发现MongoDB用了非预期的索引，可以用hint强制使用某个索引 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.c.find(&#123;&quot;age&quot;:14, &quot;username&quot;:&#x2F;.*&#x2F;&#125;).hint(&#123;&quot;username&quot;:1,&quot;age&quot;:1&#125;）</span><br></pre></td></tr></table></figure> ## 索引管理 索引的元信息存储在每个数据库的<code>system.indexes</code>集合中。这个是个保留集合，不能对其插入或删除文档。操作只能通过<code>ensureIndex</code>或者<code>dropIndexes</code>进行。 <code>system.namespaces</code>集合含有索引的名字。里面包含了两种信息，集合本身和对应集合包含的索引。 注意：集合名和索引名加起来不能超过127字节。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用background选项让建立索引操作在后台完成，同时不阻塞正常请求</span><br><span class="line">&gt; db.users.ensureIndex(&#123;&quot;username&quot;:1&#125;,&#123;&quot;background&quot;:true&#125;)</span><br></pre></td></tr></table></figure> 为已有文档创建索引比先创建索引再插入所有文档要快一点。 <figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># dropIndexes：删除索引</span></span><br><span class="line"><span class="meta"># 通常，要查一下system.indexes集合来找出索引名</span></span><br><span class="line">&gt; db.runCommand(&#123;<span class="string">&quot;dropIndexes&quot;</span>:<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;index&quot;</span>:<span class="string">&quot;alphabet&quot;</span>&#125;)</span><br><span class="line"><span class="meta"># 删除所有索引</span></span><br><span class="line">&gt; db.runCommand(&#123;<span class="string">&quot;dropIndexes&quot;</span>:<span class="string">&quot;users&quot;</span>,<span class="string">&quot;index&quot;</span>:<span class="string">&quot;*&quot;</span>&#125;)</span><br><span class="line"><span class="meta"># 这里注意，删除集合也会删除索引。</span></span><br></pre></td></tr></table></figure> ## 地理空间索引 地理空间索引：MongoDB为坐标平面查询提供的专门的索引 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 参数<span class="string">&quot;2d&quot;</span>：创建地理空间索引</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&quot;gps&quot;</span>键的值必须是某种形式的一对值：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一个包含两个元素的数组或是包含两个键的内嵌文档</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.map.ensureIndex(&#123;<span class="string">&quot;gps&quot;</span>:<span class="string">&quot;2d&quot;</span>&#125;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认情况下，地理空间索引假设值的范围是-180~180</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以通过ensureIndex选项来指定最大最小值</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.star.trek.ensureIndex(&#123;<span class="string">&quot;light-years&quot;</span>:<span class="string">&quot;2d&quot;</span>&#125;,&#123;<span class="string">&quot;min&quot;</span>:-1000,<span class="string">&quot;max&quot;</span>:1000&#125;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询方法一：使用find命令+<span class="string">&quot;<span class="variable">$near</span>&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照离点(40,-73)由近到远的方式将map集合的所有文档都返回</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.map.find(&#123;<span class="string">&quot;gps&quot;</span>:&#123;<span class="string">&quot;<span class="variable">$near</span>&quot;</span>:[40,-73]&#125;&#125;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询方法二：使用geoNear命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> geoNear还会返回每个文档到查询点的距离。</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.runCommand(&#123;geoNear:<span class="string">&quot;map&quot;</span>,near:[40,-73]&#125;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建复合地理空间索引</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.map.ensureIndex(&#123;<span class="string">&quot;location&quot;</span>:<span class="string">&quot;2d&quot;</span>,<span class="string">&quot;desc&quot;</span>1&#125;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.map.find(&#123;<span class="string">&quot;location&quot;</span>:&#123;<span class="string">&quot;<span class="variable">$near</span>&quot;</span>:[-70,30]&#125;,<span class="string">&quot;desc&quot;</span>:<span class="string">&quot;coffeeshop&quot;</span>&#125;)</span></span><br></pre></td></tr></table></figure> # 聚合 ## count：返回集合中文档的数量 <figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 没有传参时，返回总文档数</span></span><br><span class="line">&gt; db.foo.count()</span><br><span class="line"><span class="meta"># 可以传递查询，Mongo会计算查询结果的数量</span></span><br><span class="line"><span class="meta"># 注意：增加查询条件会使得count变慢。因为这相当于先查询出来再计数。</span></span><br><span class="line">&gt; db.foo.count(&#123;<span class="string">&quot;x&quot;</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure> ## distinct：找出给定键的所有不同的值 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用distinct时必须指定集合和键</span><br><span class="line">&gt; db.runCommand(&#123;&quot;distinct&quot;:&quot;users&quot;, &quot;key&quot;:&quot;age&quot;&#125;)</span><br></pre></td></tr></table></figure> ## group 过程：选定分组所依据的键 -&gt; 将集合依据选定键值的不同分成若干组 —&gt; 聚合每一组内的文档 -&gt; 产生一个结果文档 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.runCommand(&#123;&quot;group&quot;: &#123;</span><br><span class="line">... &quot;ns&quot;:&quot;stocks&quot;, # 指定要进行分组的集合</span><br><span class="line">... &quot;key&quot;:&quot;day&quot;, # 指定文档分组依据的键</span><br><span class="line">... &quot;initial&quot;:&#123;&quot;time&quot;:0&#125;, # 每一组reduce函数调用的初始时间，会作为初始文档传递给后续过程。每一组的所有成员都会使用这个累加器</span><br><span class="line">... &quot;$reduce&quot;:function(doc,prev) &#123; # 每个文档都对应一次这个吊用。系统传递两个参数：当前文档和累加器文档</span><br><span class="line">...     if (doc.time &gt; prev.time) &#123;</span><br><span class="line">...         prev.price &#x3D; doc.price;</span><br><span class="line">...         prev.time &#x3D; doc.time;</span><br><span class="line">...     &#125;</span><br><span class="line">... &#125;&#125;&#125;)</span><br><span class="line"># &quot;finalizer&quot;：完成器，用以精简从数据库传到用户的数据</span><br><span class="line"># &quot;$keyf&quot;：定义分组函数</span><br></pre></td></tr></table></figure> ## MapReduce MapReduce会拆分问题，再将各个部分发送到不同的机器上，让每台机器都完成一部分。当所有机器都完成的时候，再把结果汇集起来形成最终完整的结果。</li>
</ul>
<p>MapReduce的步骤： 1. 映射(map)：将操作映射到集合中的每个文档。 2. 洗牌(shuffle)：按照键分组，并将产生的键值组成列表放到对应的键中 3. 化简(reduce)：把列表中的值化简成一个单值。接着进行洗牌，直到每个键的列表只有一个值为止，这个值就是最后结果。</p>
<p>使用MapReduce的代价，就是速度。</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">&gt; map = function() <span class="meta">&#123;....&#125;</span> <span class="comment"># 使用emit函数“返回”要处理的值</span></span><br><span class="line">&gt; reduce = function(key, emits) <span class="meta">&#123;....&#125;</span> <span class="comment"># reduce应该能处理emit文档和其他reduce结果的各种组合</span></span><br><span class="line">&gt; mr = db.runCommand(&#123;<span class="string">&quot;mapreduce&quot;</span>:<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;map&quot;</span>:map,<span class="string">&quot;reduce&quot;</span>: reduce&#125;)</span><br><span class="line"><span class="comment"># 对结果集合进行查询</span></span><br><span class="line">&gt; db[mr.<span class="literal">result</span>].find()</span><br></pre></td></tr></table></figure>
<p>MapReduce命令的其他可选的键： * "finalize":函数 将reduce的结果发送给这个键，这是处理过程的最后一步 * "keeptemp":布尔 连接关闭时临时结果集合是否保存 * "output":字符串 结果集合的名字。设定该项隐含keeptemp:true * "query":文档 会在发往map函数前，先用指定条件过滤文档 * "sort":文档 在发往map前先给文档排序 * "limit":整数 发往map函数的文档数量的上限 * "scope":文档 JavaScript代码中要用到的变量 * "verbose":布尔 是否产生更详尽的服务器日志</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>译|Python的隐藏特性(上)</title>
    <url>/2015/09/27/%5B%E8%AF%91%5DPython%E7%9A%84%E9%9A%90%E8%97%8F%E7%89%B9%E6%80%A7(%E4%B8%8A)/</url>
    <content><![CDATA[<p>知乎上有人问了一个问题：Python有哪些新手不会了解的深入细节。 其中的一个答案引用了stackoverflow上的一个问题解答。 鉴于一直在努力摆脱Python小白，决定好好研究下这几个特性，顺手翻译一下下，扩展一下下~~</p>
<p>原文：<a href="http://stackoverflow.com/questions/101268/hidden-features-of-python">Hidden features of Python</a></p>
<h2 id="argument-unpacking"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#111176">Argument Unpacking</a></h2>
<p>可以使用*和**分别将一个列表或一个字典解包为函数参数。 例如： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_point</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="comment"># do some magic</span></span><br><span class="line"></span><br><span class="line">point_foo = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">point_bar = &#123;<span class="string">&#x27;y&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">draw_point(*point_foo)</span><br><span class="line">draw_point(**point_bar)</span><br></pre></td></tr></table></figure> 由于列表、元组和字典被广泛作为容器使用，因此这是一个非常有用的捷径。 ### 碎碎念 看了下面的评论，发现这个特性广为大家喜爱呀~~ 比较悲催的是，<a href="www.pylint.org">Pylint</a>貌似不大喜欢它。 "*"这个东东也叫作"splat"操作符。鉴于搜索一般会对某些字符当做特殊字符处理，因此，记着英文名也好找些。</p>
<h2 id="braces"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#112303">Braces</a></h2>
<p>假如你不喜欢用空格来表示范围，那么可以通过下面的方式来使用C风格的{} <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> braces</span><br></pre></td></tr></table></figure> ### 碎碎念 其实这个是个复活节彩蛋啦。 当输入这句话的时候，会得到一个错误<code>SyntaxError: not a chance (&lt;pyshell#1&gt;, line 2)</code> 这说明，这个特性永远不可能实现的。 Python开发者超有幽默感的，你可以试试输入例如<code>import __hello__</code>, <code>import this</code>, <code>import antigravity</code>看看会发生啥事~~</p>
<h2 id="chaining-comparison-operators"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#101945">Chaining Comparison Operators</a></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> &lt; x &lt; <span class="number">10</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> &lt; x &lt; <span class="number">20</span> </span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x &lt; <span class="number">10</span> &lt; x*<span class="number">10</span> &lt; <span class="number">100</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> &gt; x &lt;= <span class="number">9</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> == x &gt; <span class="number">4</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> &lt; x &lt; <span class="number">20</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">5</span> <span class="keyword">in</span> [<span class="number">5</span>] <span class="keyword">is</span> <span class="literal">True</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>如果你是这样想的：首先<code>1 &lt; x</code>，结果是<code>True</code>，然后比较<code>True &lt; 10</code>，结果也是<code>True</code>。那么，不好意思，你错了哦，事实根本不是这样的好不好。它会转换为<code>1 &lt; x and x &lt; 10</code>,和<code>x &lt; 10 and 10 &lt; x * 10 and x*10 &lt; 100</code>。当然，这样就不需要输入那么多东东，而且每一个语句只会被计算一次。</p>
<h3 id="碎碎念">碎碎念</h3>
<p>Lisp貌似也是这样玩的。 然后，上面最后例子为嘛是False呢？其实你可以理解为<code>5 in [5] and [5] is True</code>，这样，就知道为嘛了~~</p>
<h2 id="decorators"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#101447">Decorators</a></h2>
<p><a href="http://docs.python.org/ref/function.html#tok-decorators">装饰器</a>允许在另一个函数中包装一个函数或方法，这样可以增加功能，修改参数或结果等。在函数定义的上面一行写上装饰器，以"at"(@)标志开头。 下面的例子展示了一个<code>print_args</code>装饰器，它在调用函数前打印所装饰的函数参数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_args</span>(<span class="params">function</span>):</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>        <span class="built_in">print</span> <span class="string">&#x27;Arguments:&#x27;</span>, args, kwargs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>        <span class="keyword">return</span> function(*args, **kwargs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@print_args</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">text</span>):</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="built_in">print</span> text</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>write(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">Arguments: (<span class="string">&#x27;foo&#x27;</span>,) &#123;&#125;</span><br><span class="line">foo</span><br></pre></td></tr></table></figure> ### 碎碎念 为什么要使用装饰器而不是另外定义一个函数，然后在这个函数中增加可选参数呢？ 答案就是，如果你想增加的功能是一个通用功能呢？总不能为每一个用到这个功能的函数都增加一个新的函数吧？而且，只要短短一句话，就可以将它附加到任意一个函数上哦。例如，当你想要调试的时候，就可以直接加上那么一句，调试完就可以直接移除啦。</p>
<h2 id="default-argument-gotchas-dangers-of-mutable-default-arguments"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#113198">Default Argument Gotchas / Dangers of Mutable Default arguments</a></h2>
<p>要小心可变的默认参数哦~~ <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x=[]</span>):</span></span><br><span class="line"><span class="meta">... </span>    x.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure> 相反，你应该使用一个警戒值来表示“未提供”，然后将可变参数的默认值替换成为这个警戒值： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x=<span class="literal">None</span></span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> x <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>        x = []</span><br><span class="line"><span class="meta">... </span>    x.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line">[<span class="number">1</span>]</span><br></pre></td></tr></table></figure> ### 碎碎念 这个属性藏得很深呢，估计给不少人埋了雷。 至于要怎么理解呢？我们强悍的小伙伴这样解释： 因为def是一个可执行语句，只有def执行的时候才会计算默认默认参数的值，所以使用默认参数会造成函数执行的时候一直在使用同一个对象，引起bug。</p>
<p>另外，上面第二个例子可以改写为 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x=<span class="literal">None</span></span>):</span></span><br><span class="line">	x = x <span class="keyword">or</span> [] <span class="comment"># 或者 x = [] if x is None</span></span><br><span class="line">	x.append(<span class="number">1</span>)</span><br><span class="line">	<span class="built_in">print</span> x</span><br></pre></td></tr></table></figure> 在这里，可以跟lambda来对比一下。考虑下面的例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="keyword">lambda</span> y:x+y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="keyword">lambda</span> y:x+y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a(<span class="number">10</span>)</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b(<span class="number">10</span>)</span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure> 结果是不是很出乎意料？ 这是因为，跟函数的默认值参数定义不同，这里lambda表达式中的x是一个自由变量，在运行时绑定值，而不是像函数的默认值参数是在定义时就绑定值了。因此，每次运行一次lambda表达式，就会取最新的x值来绑定计算。 如果你想让某个匿名函数（lambda）在定义时捕获到值，则只要将那个参数值定义成默认值参数(也就是使用函数默认值参数定义的形式)即可。如： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="keyword">lambda</span> y, x=x:x+y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="keyword">lambda</span> y, x=x:x+y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a(<span class="number">10</span>)</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b(<span class="number">10</span>)</span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure> 扩展阅读： * <a href="https://github.com/acmerfight/insight_python/blob/master/Default_Parameter.md">Default_Parameter</a> * <a href="http://python3-cookbook.readthedocs.org/zh_CN/latest/c07/p05_define_functions_with_default_arguments.html">定义有默认参数的函数</a> * <a href="http://python3-cookbook.readthedocs.org/zh_CN/latest/c07/p07_capturing_variables_in_anonymous_functions.html">匿名函数捕获变量值</a></p>
<h2 id="descriptors"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#102062">Descriptors</a></h2>
<p>他们是一大堆Python核心特性后面的魔法~~ 当你使用"."访问的形式来查找一个成员(例如，<code>x.y</code>)，Python首先查找实例字典中的成员。如果找不到，则在类字典中查找。如果在类字典中找到了，而对象实现了描述符(descriptor)协议，Python会执行它，而不是仅仅返回它。一个描述符是任何实现<code>__get__</code>, <code>__set__</code>或者<code>__delete__</code>方法的类。 下面是如何使用描述符实现你自己的属性的(只读)版本： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Property</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, fget</span>):</span></span><br><span class="line">        self.fget = fget</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, obj, <span class="built_in">type</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> self.fget(obj)</span><br></pre></td></tr></table></figure> 而你可以像内建的<code>property()</code>属性一样使用它: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">    @Property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Foo!&quot;</span></span><br></pre></td></tr></table></figure> Python中使用描述符来在其他东东中实现属性，绑定方法，静态方法，类方法和slot。了解它们可以很容易看到之前看起来像Python的“怪癖”的东东为什么会是那样。 Raymond Hettinger有<a href="http://users.rcn.com/python/download/Descriptor.htm">一个很棒的教程</a>极好的描述了描述符这个东东。</p>
<h3 id="碎碎念-1">碎碎念</h3>
<p>装饰器和描述符是两个不一样的东东哦~ 扩展阅读： * <a href="http://hbprotoss.github.io/posts/python-descriptor.html">Python descriptor</a> * <a href="http://www.geekfan.net/7862/">Python描述符（descriptor）解密</a></p>
<h2 id="dictionary-default-.get-value"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#111970">Dictionary default .get value</a></h2>
<p>字典有一个<code>get()</code>方法。若你使用<code>d['key']</code>而key不存在，那么你将会得到一个异常。而如果使用<code>d.get('key')</code>，那么当key不存在时，会返回None。当然<code>.get()</code>方法提供给了第二个参数，若此参数设了值，那么当key不存在的时候，会返回你所制定的值。例如，<code>d.get('key',0)</code>，当d['key']不存在时，返回0. 这对某些操作很有用，列入，给数字做加法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span>[value] = <span class="built_in">sum</span>.get(value, <span class="number">0</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure> ### 碎碎念 从前，有个函数，叫做setdefault。d.setdefault('key',0)表示，若d['key']存在，则返回d['key'];否则，设置d['key'] = 0。</p>
<h2 id="docstring-tests"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#102065">Docstring Tests</a></h2>
<p><a href="https://docs.python.org/2/library/doctest.html">Doctest</a>: 文档和单元测试同时进行 从Python文档中抽取的例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the factorial of n, an exact integer &gt;= 0.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the result is small enough to fit in an int, return an int.</span></span><br><span class="line"><span class="string">    Else return a long.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; [factorial(n) for n in range(6)]</span></span><br><span class="line"><span class="string">    [1, 1, 2, 6, 24, 120]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(-1)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    ValueError: n must be &gt;= 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Factorials of floats are OK, but the float must be an exact integer:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;n must be &gt;= 0&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> math.floor(n) != n:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;n must be exact integer&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> n+<span class="number">1</span> == n:  <span class="comment"># catch a value like 1e300</span></span><br><span class="line">        <span class="keyword">raise</span> OverflowError(<span class="string">&quot;n too large&quot;</span>)</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    factor = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> factor &lt;= n:</span><br><span class="line">        result *= factor</span><br><span class="line">        factor += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_test</span>():</span></span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    _test()</span><br></pre></td></tr></table></figure> ### 碎碎念 doctest会在docstring部分加入测试代码，这就是所谓的文章和单元测试同步进行。如果doctest通过，则不会有任何输出。 好处呢，是可以用来进行回归测试，而且，直接上示例比用文字说明更直观。另外，还可以用来确认这个docString有木有过期。</p>
<h2 id="ellipsis-slicing-syntax"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python/112316#112316">Ellipsis Slicing Syntax</a></h2>
<p>Python高级切片操作有一个罕为人知的语法元素：省略(Ellipsis)： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">... </span> <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line"><span class="meta">... </span>  <span class="keyword">return</span> item</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C()[<span class="number">1</span>:<span class="number">2</span>, ..., <span class="number">3</span>]</span><br><span class="line">(<span class="built_in">slice</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">None</span>), <span class="literal">Ellipsis</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure> 不幸的是，这个特性很少有用，因为只有在包含元祖的时候才支持省略。</p>
<h3 id="碎碎念-2">碎碎念</h3>
<p>这个特性真是令人困惑呢~~ 一般会出现在numpy或者scipy模块中，几个例子体会一下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> a</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> a[...,<span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">3</span> <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> a[<span class="number">0</span>,...,<span class="number">0</span>] <span class="comment"># a[0,...,0] == a[0][0]</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure> 至于Ellipsis会输出神马，就要看所定义的<code>__getitem__</code>了</p>
<h2 id="enumeration"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#117116">Enumeration</a></h2>
<p>用enumerate包住一个可迭代对象，它将会将index和item绑在一起，返回一个enumerate对象。 例如： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(a): <span class="built_in">print</span> index, item</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> a</span><br><span class="line"><span class="number">1</span> b</span><br><span class="line"><span class="number">2</span> c</span><br><span class="line"><span class="number">3</span> d</span><br><span class="line"><span class="number">4</span> e</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure> 参考： * <a href="http://docs.python.org/tutorial/datastructures.html#looping-techniques">Python tutorial—looping techniques</a> * <a href="http://docs.python.org/library/functions.html#enumerate">Python docs—built-in functions—enumerate</a> * <a href="http://www.python.org/dev/peps/pep-0279/">PEP 279</a></p>
<h3 id="碎碎念-3">碎碎念</h3>
<p>这个当同时需要索引和值的时候灰常有用。 比如说，当你想这样做的时候： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)): <span class="built_in">print</span> i, a[i]</span><br></pre></td></tr></table></figure> 不妨换成上面这种高大上的写法，会显得更python。 当然， enumerate提供第二个参数，可以指定索引开始的位置。例如，<code>enumereate(a,1)</code></p>
<h2 id="forelse"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#114420">For/else</a></h2>
<p>for...else<a href="http://docs.python.org/ref/for.html">语法</a>如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> foo:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;i was never 0&quot;</span>)</span><br></pre></td></tr></table></figure> "else"代码块会在循环正常结束后执行，但如果循环中的break语句被调用，则else代码块不会被执行。 上面的代码也等价于 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">found = <span class="literal">False</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> foo:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        found = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> found: </span><br><span class="line">    print(<span class="string">&quot;i was never 0&quot;</span>)</span><br></pre></td></tr></table></figure> ### 碎碎念 这个语法其实挺容易让人认为如果循环体从不被执行的情况下，else语句应该被执行。因此，在使用的时候，最好还是注释下，免得被其他小伙伴看到搞错它的含义。</p>
<p>上面的代码也等价于 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">found = <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">any</span>(i == <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> foo):</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">&quot;i was never 0&quot;</span>)</span><br></pre></td></tr></table></figure> 同类语法有while...else。</p>
<h2 id="function-as-iter-argument"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#102202">Function as iter() argument</a></h2>
<p>iter()接收一个可回调参数。 例如： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">seek_next_line</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">iter</span>(<span class="keyword">lambda</span>: f.read(<span class="number">1</span>),<span class="string">&#x27;\n&#x27;</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure> <figure class="highlight plain"><figcaption><span>until_value)```函数重复调用callable，然后yield结果，直到返回until_value。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 碎碎念</span><br><span class="line">函数说明：</span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">iter(...)</span><br><span class="line">    iter(collection) -&gt; iterator</span><br><span class="line">    iter(callable, sentinel) -&gt; iterator</span><br><span class="line">    </span><br><span class="line">    Get an iterator from an object.  In the first form, the argument must</span><br><span class="line">    supply its own iterator, or be a sequence.</span><br><span class="line">    In the second form, the callable is called until it returns the sentinel.</span><br></pre></td></tr></table></figure></p>
<h2 id="generator-expressions"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#101310">Generator expressions</a></h2>
<p>假如你像下面这样写： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=(n <span class="keyword">for</span> n <span class="keyword">in</span> foo <span class="keyword">if</span> bar(n))</span><br></pre></td></tr></table></figure> 你将获得一个生成器，并可以把它付给一个变量x。现在，你可以像下面这样玩它了： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> x:</span><br></pre></td></tr></table></figure> 这样做得好处是，你不需要中间存储，而如果你像下面这样做，则需要： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [n <span class="keyword">for</span> n <span class="keyword">in</span> foo <span class="keyword">if</span> bar(n)]</span><br><span class="line"><span class="comment">#列表推导</span></span><br></pre></td></tr></table></figure> 在某些情况下，这会导致极重要的速度提升。 你可以添加许多if语句到生成器的尾端，基本复制for循环嵌套： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = ((a,b) <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">2</span>) <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>,<span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> n:</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span> i </span><br><span class="line"></span><br><span class="line">(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure> ### 碎碎念 使用生成器最大的好处就是节省内存了。因为每一个值只有在你需要的时候才会生成，而不像列表推导那样一次性生成所有的结果。储存一个值和储存一堆值，比比看，就知道谁更省空间了。 但素，要注意的一点是，因为生成器的这个特性，所以它只能被用一次哦，这个就是所谓的"no rewind"特性。 扩展阅读：<a href="http://www.dabeaz.com/generators/">Generator Tricks for Systems Programmers</a></p>
<h2 id="import-this"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#101276">import this</a></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> this</span><br><span class="line"><span class="comment"># btw look at this module&#x27;s source :)</span></span><br></pre></td></tr></table></figure>
<p>结果是（翻译见<a href="http://article.yeeyan.org/view/287706/264148">The Zen of Python</a>）： The Zen of Python, by Tim Peters</p>
<pre><code>Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren&#39;t special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you&#39;re Dutch.
Now is better than never.
Although never is often better than right now.
If the implementation is hard to explain, it&#39;s a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let&#39;s do more of those!</code></pre>
<h3 id="碎碎念-4">碎碎念</h3>
<p>前面<code>from __future__ ipmort braces</code>提到了这个<code>import this</code>。现在就让我们来看看会发生神马吧。 从这个模块的源代码来看（位于python目录下的Lib/this.py），这个是对一段加密后的s进行解密操作（<a href="https://en.wikipedia.org/wiki/ROT13">ROT13</a>），然后输出。</p>
<p>从源码来看，这个彩蛋是很令人困惑的。至于为什么这样写，有人说，只是个玩笑，因为这个源码本身就违反了Zen of Python。你觉得呢？</p>
<h2 id="in-place-value-swapping"><a href="http://stackoverflow.com/questions/101268/hidden-features-of-python#102037">In Place Value Swapping</a></h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = b, a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(<span class="number">5</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>等号右边是一个表达式，它创建了一个新的元组。等号左边立即将这个未引用的元组拆封赋值给a和b 赋值后，新的元组属于未被引用，并标记为可回收垃圾，而a和b绑定的值则被互换。 注意在<a href="http://docs.python.org/tutorial/datastructures.html#tuples-and-sequences">Python tutorial section on data structures</a>中有， 注意，多重赋值其实只是元组封装和序列拆封的组合。</p>
<h3 id="碎碎念-5">碎碎念</h3>
<p>此时，有小伙伴提出疑问，这会不会被传统的方式使用更多的内存空间呢？ 答案是，不会！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>译|比一比：Python的七个数据可视化工具</title>
    <url>/2015/11/22/%5B%E8%AF%91%5D%E6%AF%94%E4%B8%80%E6%AF%94%EF%BC%9APython%E7%9A%84%E4%B8%83%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>原文：<a href="https://www.dataquest.io/blog/python-data-visualization-libraries/">Comparing 7 Python data visualization tools</a></p>
<p>Python的<a href="http://www.scipy.org/about.html">科学栈</a>相当成熟。目前已经有许多用于各种各样目的的库，包括<a href="http://scikit-learn.org/">机器学习</a>和<a href="http://pandas.pydata.org/">数据分析</a>。数据可视化是能够探索数据和交流结果的重要组成部分，但是在过去，稍微落后于其他工具，例如，R。</p>
<p>幸运的是，在过去的几年里，许多新的Python数据可视化库被创造出来以缩小差距。<a href="http://matplotlib.org/index.html">matplotlib</a>已经成为主要的数据可视化库，但是，也有其他诸如<a href="http://vispy.org/">vispy</a>, <a href="http://bokeh.pydata.org/en/latest/">bokeh</a>, <a href="http://stanford.edu/~mwaskom/software/seaborn/">seaborn</a>, <a href="https://github.com/Kozea/pygal">pygal</a>, <a href="https://github.com/python-visualization/folium">folium</a>和<a href="https://github.com/networkx/networkx">networkx</a>的库，它们要么建立在matplotlib的基础上，要么具备matplotlib所不支持的功能。</p>
<p>在这篇文章中，我们将使用一个真实世界的数据集，然后使用这些库进行可视化。在这个过程中，我们会发现什么领域使用什么库最好，以及如何最有效的利用Python的数据可视化生态系统。</p>
<p>在<a href="https://www.dataquest.io/">Dataquest</a>中，我们已经建立了一个互动课程。这个课程会教你Python数据可视化工具。如果你想更深入的了解，看看<a href="https://www.dataquest.io/section/data-visualization">这里</a>。</p>
<h2 id="探索数据集">探索数据集</h2>
<p>在我们深入数据可视化之前，让我们快速浏览一下将使用的数据集。我们将使用来自<a href="http://openflights.org/data.html">openflights</a>的数据。我们还会使用(航线)[http://openflights.org/data.html#route], <a href="http://openflights.org/data.html#airport">机场</a>和<a href="http://openflights.org/data.html#airline">航空公司</a>的数据。航线数据中的每一行对应于两个机场之间的一条航空公司航线。机场数据中的每一行对应世界上的一个机场及其相关信息。航空公司数据的每一行表示一个航空公司。</p>
<p>注：openflights这个网站可能打不开。此时，可以使用github上的数据：<a href="https://github.com/jpatokal/openflights/tree/master/data">openflights</a></p>
<p>我们首先读入数据： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入pandas库</span></span><br><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line"><span class="comment"># 读入机场数据</span></span><br><span class="line">airports = pandas.read_csv(<span class="string">&quot;airports.csv&quot;</span>, header=<span class="literal">None</span>, dtype=<span class="built_in">str</span>)</span><br><span class="line">airports.columns = [<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;code&quot;</span>, <span class="string">&quot;icao&quot;</span>, <span class="string">&quot;latitude&quot;</span>, <span class="string">&quot;longitude&quot;</span>, <span class="string">&quot;altitude&quot;</span>, <span class="string">&quot;offset&quot;</span>, <span class="string">&quot;dst&quot;</span>, <span class="string">&quot;timezone&quot;</span>]</span><br><span class="line"><span class="comment"># 读入航空公司数据</span></span><br><span class="line">airlines = pandas.read_csv(<span class="string">&quot;airlines.csv&quot;</span>, header=<span class="literal">None</span>, dtype=<span class="built_in">str</span>)</span><br><span class="line">airlines.columns = [<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;alias&quot;</span>, <span class="string">&quot;iata&quot;</span>, <span class="string">&quot;icao&quot;</span>, <span class="string">&quot;callsign&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;active&quot;</span>]</span><br><span class="line"><span class="comment"># 读入航线数据</span></span><br><span class="line">routes = pandas.read_csv(<span class="string">&quot;routes.csv&quot;</span>, header=<span class="literal">None</span>, dtype=<span class="built_in">str</span>)</span><br><span class="line">routes.columns = [<span class="string">&quot;airline&quot;</span>, <span class="string">&quot;airline_id&quot;</span>, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;source_id&quot;</span>, <span class="string">&quot;dest&quot;</span>, <span class="string">&quot;dest_id&quot;</span>, <span class="string">&quot;codeshare&quot;</span>, <span class="string">&quot;stops&quot;</span>, <span class="string">&quot;equipment&quot;</span>]</span><br></pre></td></tr></table></figure> 该数据不包含列标题，因此我们通过指定<code>columns</code>属性添加列标题。我们想将每一列作为字符串读取 - 这会使得后面当我们想基于id匹配每一行时，比较整个数据帧更加容易，因此，我们在读取数据时设置<code>dtype</code>参数。</p>
<p>我们可以快速浏览一下每个数据帧： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">airports.head()</span><br></pre></td></tr></table></figure> | | id | name | city | country | code | icao | latitude | longitude | altitude | offset | dst | timezone | | -------- | -----: | :----: | -----: | :----: | -----: | :----: | -----: | :----: | -----: | :----: | -----: | :----: | | 0 | 1 | Goroka | Goroka | Papua New Guinea | GKA | AYGA | -6.081689 | 145.391881 | 5282 | 10 | U | Pacific/Port_Moresby | | 1 | 2 | Madang | Madang | Papua New Guinea | MAG | AYMD | -5.207083 | 145.788700 | 20 | 10 | U | Pacific/Port_Moresby | | 2 | 3 | Mount Hagen | Mount Hagen | Papua New Guinea | HGU | AYMH | -5.826789 | 144.295861 | 5388 | 10 | U | Pacific/Port_Moresby | | 3 | 4 | Nadzab | Nadzab | Papua New Guinea | LAE | AYNZ | -6.569828 | 146.726242 | 239 | 10 | U | Pacific/Port_Moresby | | 4 | 5 | Port Moresby Jacksons Intl | Port Moresby | Papua New Guinea | POM | AYPY | -9.443383 | 147.220050 | 146 | 10 | U | Pacific/Port_Moresby |</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">airlines.head()</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: right;">id</th>
<th style="text-align: center;">name</th>
<th style="text-align: right;">alias</th>
<th style="text-align: center;">iata</th>
<th style="text-align: right;">icao</th>
<th style="text-align: center;">callsign</th>
<th style="text-align: right;">country</th>
<th style="text-align: center;">active</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td style="text-align: right;">1</td>
<td style="text-align: center;">Private flight</td>
<td style="text-align: right;"></td>
<td style="text-align: center;">-</td>
<td style="text-align: right;">NaN</td>
<td style="text-align: center;">NaN</td>
<td style="text-align: right;">NaN</td>
<td style="text-align: center;">Y</td>
</tr>
<tr class="even">
<td>1</td>
<td style="text-align: right;">2</td>
<td style="text-align: center;">135 Airways</td>
<td style="text-align: right;"></td>
<td style="text-align: center;">NaN</td>
<td style="text-align: right;">GNL</td>
<td style="text-align: center;">GENERAL</td>
<td style="text-align: right;">United States</td>
<td style="text-align: center;">N</td>
</tr>
<tr class="odd">
<td>2</td>
<td style="text-align: right;">3</td>
<td style="text-align: center;">1Time Airline</td>
<td style="text-align: right;"></td>
<td style="text-align: center;">1T</td>
<td style="text-align: right;">RNX</td>
<td style="text-align: center;">NEXTIME</td>
<td style="text-align: right;">South Africa</td>
<td style="text-align: center;">Y</td>
</tr>
<tr class="even">
<td>3</td>
<td style="text-align: right;">4</td>
<td style="text-align: center;">2 Sqn No 1 Elementary Flying Training School</td>
<td style="text-align: right;"></td>
<td style="text-align: center;">NaN</td>
<td style="text-align: right;">WYT</td>
<td style="text-align: center;">NaN</td>
<td style="text-align: right;">United Kingdom</td>
<td style="text-align: center;">N</td>
</tr>
<tr class="odd">
<td>4</td>
<td style="text-align: right;">5</td>
<td style="text-align: center;">213 Flight Unit</td>
<td style="text-align: right;"></td>
<td style="text-align: center;">NaN</td>
<td style="text-align: right;">TFU</td>
<td style="text-align: center;">NaN</td>
<td style="text-align: right;">Russia</td>
<td style="text-align: center;">N</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">routes.head()</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: right;">airline</th>
<th style="text-align: center;">airline_id</th>
<th style="text-align: right;">source</th>
<th style="text-align: center;">source_id</th>
<th style="text-align: right;">dest</th>
<th style="text-align: center;">dest_id</th>
<th style="text-align: right;">codeshare</th>
<th style="text-align: center;">stops</th>
<th style="text-align: right;">equipment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td style="text-align: right;">2B</td>
<td style="text-align: center;">410</td>
<td style="text-align: right;">AER</td>
<td style="text-align: center;">2965</td>
<td style="text-align: right;">KZN</td>
<td style="text-align: center;">2990</td>
<td style="text-align: right;">NaN</td>
<td style="text-align: center;">0</td>
<td style="text-align: right;">CR2</td>
</tr>
<tr class="even">
<td>1</td>
<td style="text-align: right;">2B</td>
<td style="text-align: center;">410</td>
<td style="text-align: right;">ASF</td>
<td style="text-align: center;">2966</td>
<td style="text-align: right;">KZN</td>
<td style="text-align: center;">2990</td>
<td style="text-align: right;">NaN</td>
<td style="text-align: center;">0</td>
<td style="text-align: right;">CR2</td>
</tr>
<tr class="odd">
<td>2</td>
<td style="text-align: right;">2B</td>
<td style="text-align: center;">410</td>
<td style="text-align: right;">ASF</td>
<td style="text-align: center;">2966</td>
<td style="text-align: right;">MRV</td>
<td style="text-align: center;">2962</td>
<td style="text-align: right;">NaN</td>
<td style="text-align: center;">0</td>
<td style="text-align: right;">CR2</td>
</tr>
<tr class="even">
<td>3</td>
<td style="text-align: right;">2B</td>
<td style="text-align: center;">410</td>
<td style="text-align: right;">CEK</td>
<td style="text-align: center;">2968</td>
<td style="text-align: right;">KZN</td>
<td style="text-align: center;">2990</td>
<td style="text-align: right;">NaN</td>
<td style="text-align: center;">0</td>
<td style="text-align: right;">CR2</td>
</tr>
<tr class="odd">
<td>4</td>
<td style="text-align: right;">2B</td>
<td style="text-align: center;">410</td>
<td style="text-align: right;">CEK</td>
<td style="text-align: center;">2968</td>
<td style="text-align: right;">OVB</td>
<td style="text-align: center;">4078</td>
<td style="text-align: right;">NaN</td>
<td style="text-align: center;">0</td>
<td style="text-align: right;">CR2</td>
</tr>
</tbody>
</table>
<p>我们可以对每一个数据集单独的做各种有趣的探索，但是通过将它们结合起来，我们将会看到最大的收获。在进行分析的时候，Pandas会帮助我们，因为它能够很容易的过滤矩阵或在它们上面应用函数。我们将深入一些有趣的度量，例如分析航空公司和路线。</p>
<p>在此之前，需要进行一些数据清理： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">routes = routes[routes[<span class="string">&quot;airline_id&quot;</span>] != <span class="string">&quot;\\N&quot;</span>]</span><br></pre></td></tr></table></figure> 上面的代码确保在<code>airline_id</code>列只有数字数据。</p>
<h2 id="建立直方图">建立直方图</h2>
<p>现在，我们已经了解了数据的结构，可以继续前进，开始画图来探索它们。对于第一个图，我们将使用matplotlib。matplotlib是Python栈中一个相对较低级别的绘图库，因此它比其他库需要更多的命令来绘制一个漂亮的图。另一方面，你可以使用matplotlib来绘制几乎任何种类的图。它非常灵活，但这种灵活性是以冗余为代价的。</p>
<p>我们首先绘制直方图来显示按航空公司划分的航线长度分布情况。直方图把所有的航线长度划分成范围（或"仓库"），然后统计每个范围中有多少路线。这可以告诉我们，航空公司飞行更短的航线，还是更长的航线。</p>
<p>为了做到这一点，我们需要首先计算航线的长度。第一步是一个距离公式。我们将使用Haversine距离，即经纬度对之间的距离。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">haversine</span>(<span class="params">lon1, lat1, lon2, lat2</span>):</span></span><br><span class="line">    <span class="comment"># 将坐标转换为浮点数</span></span><br><span class="line">    lon1, lat1, lon2, lat2 = [<span class="built_in">float</span>(lon1), <span class="built_in">float</span>(lat1), <span class="built_in">float</span>(lon2), <span class="built_in">float</span>(lat2)]</span><br><span class="line">    <span class="comment"># 将度数转换为弧度</span></span><br><span class="line">    lon1, lat1, lon2, lat2 = <span class="built_in">map</span>(math.radians, [lon1, lat1, lon2, lat2])</span><br><span class="line">    <span class="comment"># 计算距离</span></span><br><span class="line">    dlon = lon2 - lon1 </span><br><span class="line">    dlat = lat2 - lat1 </span><br><span class="line">    a = math.sin(dlat/<span class="number">2</span>)**<span class="number">2</span> + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/<span class="number">2</span>)**<span class="number">2</span></span><br><span class="line">    c = <span class="number">2</span> * math.asin(math.sqrt(a)) </span><br><span class="line">    km = <span class="number">6367</span> * c</span><br><span class="line">    <span class="keyword">return</span> km</span><br></pre></td></tr></table></figure>
<p>然后，我们可以编写一个函数来计算源机场和目的机场之间某条航线的距离。要做到这一点，我们需要从航线数据帧中获得机场的<code>source_id</code>和<code>dest_id</code>，然后根据机场数据帧中的id列将它们匹配起来以获得这些机场的经度和纬度。接下来，就只是单纯的计算了。下面是这个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_dist</span>(<span class="params">row</span>):</span></span><br><span class="line">    dist = <span class="number">0</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 匹配源和目的以获得坐标</span></span><br><span class="line">        source = airports[airports[<span class="string">&quot;id&quot;</span>] == row[<span class="string">&quot;source_id&quot;</span>]].iloc[<span class="number">0</span>]</span><br><span class="line">        dest = airports[airports[<span class="string">&quot;id&quot;</span>] == row[<span class="string">&quot;dest_id&quot;</span>]].iloc[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 使用坐标计算距离</span></span><br><span class="line">        dist = haversine(dest[<span class="string">&quot;longitude&quot;</span>], dest[<span class="string">&quot;latitude&quot;</span>], source[<span class="string">&quot;longitude&quot;</span>], source[<span class="string">&quot;latitude&quot;</span>])</span><br><span class="line">    <span class="keyword">except</span> (ValueError, IndexError):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> dist</span><br></pre></td></tr></table></figure>
<p>如果<code>source_id</code>或者<code>dest_id</code>列出现无效值时，这个函数将运行失败，所以我们要增加<code>try/except</code>块来捕捉。</p>
<p>最后，我们要使用pandas对整个<code>routes</code>数据帧应用距离计算函数。它将为我们提供一个包含所有航线长度的pandas series。所有航线的长度都是以千米为单位。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">route_lengths = routes.apply(calc_dist, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure> 现在，我们得到了航线的长度，可以创建一个直方图来将这些值归入各个范围中，然后计算每个范围中有多少航线： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">plt.hist(route_lengths, bins=<span class="number">20</span>)</span><br></pre></td></tr></table></figure> <img src="https://www.dataquest.io/blog/images/pyviz/mplhist2.png" /></p>
<p>使用<code>import matplotlib.pyplot as plt</code>导入matplotlib绘图函数。然后使用<code>%matplotlib inline</code>在ipython notebook中启动matplotlib显示图形。最后，使用<code>plt.hist(route_lengths, bins=20)</code>创建一个直方图。正如我们所看到的，相对于长航线，航空公司飞行更多的短航线。</p>
<h2 id="使用seaborn">使用Seaborn</h2>
<p>我们可以使用seaborn（一个更高级的Python绘图库）绘制出相似的图。Seaborn基于matplotlib，创建某些类型的图，通常用于统计工作会更简单。我们可以使用<code>distplot</code>函数来绘制一个直方图，这个图上会带有一个内核密度评估。一个内核密度评估是一个曲线 - 实质上是直方图的一个平滑版本，它更易于看到模式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn</span><br><span class="line">seaborn.distplot(route_lengths, bins=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.dataquest.io/blog/images/pyviz/snshist2.png" /></p>
<p>正如你所看到的，seaborn拥有比matplotlib更好的默认样式。Seaborn并没有所有matplotlib图形的它自己的版本，但是相比较默认的matplotlib图表，它是一种快速获得更深入好看的图形的很好的方式。如果你需要更深入，并且进行一些统计工作，它也是一个很好的库。</p>
<h2 id="柱状图">柱状图</h2>
<p>直方图很棒，但也许我们想要按航空公司查看平均航线长度。我们可以改用柱状图 - 每一家航空公司都有一个单独的柱表示平均航线长度。这将让我们看到哪些运营商是区域性的，哪些是国际化的。我们可以使用pandas，一个python数据分析库，来计算每一个航空公司的平均航线长度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将相关列放入一个数据帧中</span></span><br><span class="line">route_length_df = pandas.DataFrame(&#123;<span class="string">&quot;length&quot;</span>: route_lengths, <span class="string">&quot;id&quot;</span>: routes[<span class="string">&quot;airline_id&quot;</span>]&#125;)</span><br><span class="line"><span class="comment"># 计算每一个航空公司的平均航线长度</span></span><br><span class="line">airline_route_lengths = route_length_df.groupby(<span class="string">&quot;id&quot;</span>).aggregate(numpy.mean)</span><br><span class="line"><span class="comment"># 根据长度排序，这样我们可以得到一个更好的图表</span></span><br><span class="line">airline_route_lengths = airline_route_lengths.sort(<span class="string">&quot;length&quot;</span>, ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>首先，我们使用航线长度和航空公司的id来创建一个新的数据帧。接着基于<code>airline_id</code>将<code>route_length_df</code>分组，从根本上使得每一家航空公司创建一个数据帧。然后使用pandas的<code>aggregate</code>函数计算每一个航空公司数据帧的<code>length</code>列的平均值，再将每一个结果结合成一个新的数据帧。然后，我们对数据帧进行排序以使得最长航线长度的航空公司出现在第一位。</p>
<p>现在，我们可以使用matplotlib画图了： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.bar(<span class="built_in">range</span>(airline_route_lengths.shape[<span class="number">0</span>]), airline_route_lengths[<span class="string">&quot;length&quot;</span>])</span><br></pre></td></tr></table></figure> <img src="https://www.dataquest.io/blog/images/pyviz/mplbar3.png" /></p>
<p>matplotlib的<code>plt.bar</code>方法绘制每一个航空公司飞行的平均航线长度(<code>airline_route_lengths["length"]</code>).</p>
<p>上面的图形的问题是，我们不能很容易的看出每一个航线长度对应哪一个航空公司。为了达到这个目的，我们需要能够看到轴标签。这有点困难，因为有这么多家航空公司。使这更容易的一个方法是将图形变成交互式的，这样将允许我们放大和缩小以查看标签。我们可以使用bokeh库来达到此目的 - 它可以很简单的创建可互动可缩放的图形。</p>
<p>要使用bokeh，我们需要先预处理我们的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lookup_name</span>(<span class="params">row</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 将row的id域航空公司数据帧中的id进行匹配，这样我们可以获得航空公司的名字.</span></span><br><span class="line">        name = airlines[<span class="string">&quot;name&quot;</span>][airlines[<span class="string">&quot;id&quot;</span>] == row[<span class="string">&quot;id&quot;</span>]].iloc[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">except</span> (ValueError, IndexError):</span><br><span class="line">        name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将索引（航空公司的id）作为一个列添加</span></span><br><span class="line">airline_route_lengths[<span class="string">&quot;id&quot;</span>] = airline_route_lengths.index.copy()</span><br><span class="line"><span class="comment"># 查找所有航空公司的名字</span></span><br><span class="line">airline_route_lengths[<span class="string">&quot;name&quot;</span>] = airline_route_lengths.apply(lookup_name, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 删除索引中的重复值</span></span><br><span class="line">airline_route_lengths.index = <span class="built_in">range</span>(airline_route_lengths.shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>上面的代码将为<code>airline_route_lengths</code>中的每一行获取名称，然后将其保存到<code>name</code>列（包含每一家航空公司的名字）。我们也增加<code>id</code>列，这样我们能进行这种查找（<code>apply</code>函数不用传递索引）。</p>
<p>最后，我们重置索引列来获得所有唯一值。若非如此，Bokeh无法正常工作。</p>
<p>现在，我们可以继续画图了： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> bokeh.io <span class="keyword">import</span> output_notebook</span><br><span class="line"><span class="keyword">from</span> bokeh.charts <span class="keyword">import</span> Bar, show</span><br><span class="line"></span><br><span class="line">output_notebook()</span><br><span class="line">p = Bar(airline_route_lengths, <span class="string">&#x27;name&#x27;</span>, values=<span class="string">&#x27;length&#x27;</span>, title=<span class="string">&#x27;Average airline route lengths&#x27;</span>)</span><br><span class="line">show(p)</span><br></pre></td></tr></table></figure> 调用<code>output_notebook</code>设置bokeh可以在ipython notebook中显示图表。然后，使用我们的数据帧和对应的列创建一个条形图。最后，<code>show</code>函数显示这个图表。</p>
<p>这个图表并不是一张图 - 它其实是一个javascript小部件。正因为如此，我们在下面展示的是一张截图，而不是实际的图表。</p>
<p><img src="https://www.dataquest.io/blog/images/pyviz/bokehbar2.png" /></p>
<p>使用它，我们可以放大然后查看哪一个航空公司飞行最长的距离。上面的图使得这些标签看起来很拥挤，但是随着被放大，它们会容易看得多。</p>
<h2 id="水平条形图">水平条形图</h2>
<p>Pygal是一个Python数据分析库，它可以快速的制作出吸引人的图表。我们可以使用它来根据长度对航线进行分类。首先，将航线分为短期，中期和长期，然后计算它们每一个在<code>route_lengths</code>的百分比。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">long_routes = <span class="built_in">len</span>([k for k in route_lengths <span class="built_in">if</span> k &gt; <span class="number">10000</span>]) / <span class="built_in">len</span>(route_lengths)</span><br><span class="line">medium_routes = <span class="built_in">len</span>([k for k in route_lengths <span class="built_in">if</span> k &lt; <span class="number">10000</span> <span class="built_in">and</span> k &gt; <span class="number">2000</span>]) / <span class="built_in">len</span>(route_lengths)</span><br><span class="line">short_routes = <span class="built_in">len</span>([k for k in route_lengths <span class="built_in">if</span> k &lt; <span class="number">2000</span>]) / <span class="built_in">len</span>(route_lengths)</span><br></pre></td></tr></table></figure>
<p>然后，在pygal水平条形图中，将它们每一个绘制成一个条形：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> SVG</span><br><span class="line"></span><br><span class="line">chart = pygal.HorizontalBar()</span><br><span class="line">chart.title = <span class="string">&#x27;Long, medium, and short routes&#x27;</span></span><br><span class="line">chart.add(<span class="string">&#x27;Long&#x27;</span>, long_routes*<span class="number">100</span>)</span><br><span class="line">chart.add(<span class="string">&#x27;Medium&#x27;</span>, medium_routes*<span class="number">100</span>)</span><br><span class="line">chart.add(<span class="string">&#x27;Short&#x27;</span>, short_routes*<span class="number">100</span>)</span><br><span class="line">chart.render_to_file(<span class="string">&#x27;routes.svg&#x27;</span>)</span><br><span class="line">SVG(filename=<span class="string">&#x27;routes.svg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.dataquest.io/blog/images/pyviz/routes.svg" /></p>
<p>在上面，我们首先创造了一个空图表。然后，添加元素，包括标题和条形。每一个条形对应一个百分比，表示航线类型有多常见。</p>
<p>最后，绘制图表文件，并使用IPython中的SVG显示功能加载和显示文件。此图看起来比默认的matplotlib图表漂亮许多，但是我们也需要写更多的代码来创建它。Pygal可能比较适用于小型演示图形。</p>
<h2 id="散点图">散点图</h2>
<p>散点图能让我们比较数据列。我们可以制作一个简单的散点图来比较航空公司id值及其名字的长度: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_lengths = airlines[<span class="string">&#x27;name&#x27;</span>].apply(<span class="keyword">lambda</span> x: <span class="built_in">len</span>(<span class="built_in">str</span>(x)))</span><br><span class="line">plt.scatter(airlines[<span class="string">&#x27;id&#x27;</span>].astype(<span class="built_in">int</span>), name_lengths)</span><br></pre></td></tr></table></figure> <img src="https://www.dataquest.io/blog/images/pyviz/mplscatter.png" /></p>
<p>首先，通通过pandas的<code>apply</code>方法计算每一个名字的长度。这将查找每一个航空公司名字的字母数。</p>
<p>然后，使用matplotlib制作一张散点图来对航空公司的id及其名字的长度进行比较。在绘图的时候，将<code>airlines</code>的<code>id</code>列转换成整型。如果不这样做，将无法进行绘图，因为在x轴，它需要数字值。可以看到，越早的id拥有越长的名字。这可能意味着，较早成立的航空公司往往有较长的名称。</p>
<p>我们可以使用seaborn来验证这个说法。seaborn有一个散点图的增强版本，一个联合图表，它显示了两个变量之间的关系，以及每一个的单独分布。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pandas.DataFrame(&#123;<span class="string">&quot;lengths&quot;</span>: name_lengths, <span class="string">&quot;ids&quot;</span>: airlines[<span class="string">&quot;id&quot;</span>].astype(<span class="built_in">int</span>)&#125;)</span><br><span class="line">seaborn.jointplot(x=<span class="string">&quot;ids&quot;</span>, y=<span class="string">&quot;lengths&quot;</span>, data=data)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.dataquest.io/blog/images/pyviz/snsscatter.png" /></p>
<p>上面的图表表明，两个变量之间不存在任何真实的相关性 - R平方值低。</p>
<h2 id="静态地图">静态地图</h2>
<p>我们的数据就本质而言是相当适合绘制地图的 - 机场、源机场和目的地机场都具有经纬度对。</p>
<p>我们可以制作的第一张图是一张显示遍布全世界的所有机场。我们可以使用<a href="http://matplotlib.org/basemap/">basemap</a>这基于matplotlib扩展的工具。它可以绘制世界地图，添加点，而且非常个性化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入basemap包</span></span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.basemap <span class="keyword">import</span> Basemap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个地图用于绘制。</span></span><br><span class="line"><span class="comment"># 我们使用的是墨卡托投影，并显示整个世界。</span></span><br><span class="line">m = Basemap(projection=<span class="string">&#x27;merc&#x27;</span>,llcrnrlat=-<span class="number">80</span>,urcrnrlat=<span class="number">80</span>,llcrnrlon=-<span class="number">180</span>,urcrnrlon=<span class="number">180</span>,lat_ts=<span class="number">20</span>,resolution=<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘制海岸线，以及地图的边缘</span></span><br><span class="line">m.drawcoastlines()</span><br><span class="line">m.drawmapboundary()</span><br><span class="line"><span class="comment"># 将经纬度转换成x和y坐标</span></span><br><span class="line">x, y = m(<span class="built_in">list</span>(airports[<span class="string">&quot;longitude&quot;</span>].astype(<span class="built_in">float</span>)), <span class="built_in">list</span>(airports[<span class="string">&quot;latitude&quot;</span>].astype(<span class="built_in">float</span>)))</span><br><span class="line"><span class="comment"># 使用matplotlib在地图上绘制点</span></span><br><span class="line">m.scatter(x,y,<span class="number">1</span>,marker=<span class="string">&#x27;o&#x27;</span>,color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="comment"># 显示图表</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们首先使用<a href="https://en.wikipedia.org/wiki/Mercator_projection">墨卡托投影</a>绘制世界地图。墨卡托投影是一种将整个世界投影成二维表面的方法。然后，使用红点在地图上绘制机场。</p>
<p><img src="https://www.dataquest.io/blog/images/pyviz/mplmap.png" /></p>
<p>上面地图的问题是很难看出来每一个机场在哪里 - 它们在高机场密度区域会合并成一个红色的斑点。</p>
<p>正如使用bokeh一样，也有一个交互式的地图库，叫做folium，可以用来放大地图以帮助我们查找单个机场。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> folium</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得一个基本世界地图</span></span><br><span class="line">airports_map = folium.Map(location=[<span class="number">30</span>, <span class="number">0</span>], zoom_start=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 在上面绘制标记</span></span><br><span class="line"><span class="keyword">for</span> name, row <span class="keyword">in</span> airports.iterrows():</span><br><span class="line">    <span class="comment"># 由于某些原因，这个机场会引发问题</span></span><br><span class="line">    <span class="keyword">if</span> row[<span class="string">&quot;name&quot;</span>] != <span class="string">&quot;South Pole Station&quot;</span>:</span><br><span class="line">        airports_map.circle_marker(location=[row[<span class="string">&quot;latitude&quot;</span>], row[<span class="string">&quot;longitude&quot;</span>]], popup=row[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"><span class="comment"># 创建并显示地图</span></span><br><span class="line">airports_map.create_map(<span class="string">&#x27;airports.html&#x27;</span>)</span><br><span class="line">airports_map</span><br></pre></td></tr></table></figure>
<p><img src="https://www.dataquest.io/blog/images/pyviz/foliummap.png" /></p>
<p>folium使用leaflet.js来制作一个完全可交互的地图。你可以点击每一个机场来查看弹出的名字。上面是截图，但是真实的地图会更加的令人印象深刻。folium也允许你修改范围非常广泛的选项来制作更好的标记，或者添加更多的东西到地图中。</p>
<h2 id="绘制大圆圈great-circle">绘制大圆圈(great circle)</h2>
<p>看到所有航线显示在一张地图上将是一件相当酷的事情。幸运的是，我们可以使用basemap来做到这一点。我们将绘制链接源和目的地机场的大圆。每个圆圈将显示一个单一的客机路线。不幸的是，有那么多的路线以至于将它们全部显示出来会乱七八糟。相反，我们将显示前3000条路线。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用墨卡托投影制作一张基础地图。绘制海岸线。</span></span><br><span class="line">m = Basemap(projection=<span class="string">&#x27;merc&#x27;</span>,llcrnrlat=-<span class="number">80</span>,urcrnrlat=<span class="number">80</span>,llcrnrlon=-<span class="number">180</span>,urcrnrlon=<span class="number">180</span>,lat_ts=<span class="number">20</span>,resolution=<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">m.drawcoastlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历前3000行数据</span></span><br><span class="line"><span class="keyword">for</span> name, row <span class="keyword">in</span> routes[:<span class="number">3000</span>].iterrows():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 获取源和目的地机场</span></span><br><span class="line">        source = airports[airports[<span class="string">&quot;id&quot;</span>] == row[<span class="string">&quot;source_id&quot;</span>]].iloc[<span class="number">0</span>]</span><br><span class="line">        dest = airports[airports[<span class="string">&quot;id&quot;</span>] == row[<span class="string">&quot;dest_id&quot;</span>]].iloc[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 不要绘制太长的航线。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(<span class="built_in">float</span>(source[<span class="string">&quot;longitude&quot;</span>]) - <span class="built_in">float</span>(dest[<span class="string">&quot;longitude&quot;</span>])) &lt; <span class="number">90</span>:</span><br><span class="line">            <span class="comment"># 在源和目的机场之间绘制一个大圆圈。</span></span><br><span class="line">            m.drawgreatcircle(<span class="built_in">float</span>(source[<span class="string">&quot;longitude&quot;</span>]), <span class="built_in">float</span>(source[<span class="string">&quot;latitude&quot;</span>]), <span class="built_in">float</span>(dest[<span class="string">&quot;longitude&quot;</span>]), <span class="built_in">float</span>(dest[<span class="string">&quot;latitude&quot;</span>]),linewidth=<span class="number">1</span>,color=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> (ValueError, IndexError):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 显示地图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://www.dataquest.io/blog/images/pyviz/mplmap2.png" /></p>
<p>上面的代码将会绘制一张地图，然后在上面绘制航线。我们增加了一些过滤以防止过长的航线模糊了其他航线。</p>
<h2 id="绘制网络图">绘制网络图</h2>
<p>我们将进行的最后的探索是绘制一张机场的网络图。每一个机场将会是网络中的一个结点，而如果机场之间存在一条航线，我们将绘制结点之间的边。如果有多条航线，将增加边的权重，以表明机场的连接成都。我们将使用networkx库来做到这点。</p>
<p>首先，我们需要计算机场之间的边的权重。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化权重字典</span></span><br><span class="line">weights = &#123;&#125;</span><br><span class="line"><span class="comment"># 跟踪已经添加过一次的键 -- 我们只想要超过1权重的边来使得我们的网络规模可控。</span></span><br><span class="line">added_keys = []</span><br><span class="line"><span class="comment"># 遍历每一条航线</span></span><br><span class="line"><span class="keyword">for</span> name, row <span class="keyword">in</span> routes.iterrows():</span><br><span class="line">    <span class="comment"># 抽取源和目的地id</span></span><br><span class="line">    source = row[<span class="string">&quot;source_id&quot;</span>]</span><br><span class="line">    dest = row[<span class="string">&quot;dest_id&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 为权重字典创建一个键</span></span><br><span class="line">    <span class="comment"># 这对应一条边，拥有航线的起点和终点。</span></span><br><span class="line">    key = <span class="string">&quot;&#123;0&#125;_&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(source, dest)</span><br><span class="line">    <span class="comment"># 如果键已经在wieghts中了，增加权重。</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">in</span> weights:</span><br><span class="line">        weights[key] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 如果key在已添加键中，用权重值2初始化weights字典中的键</span></span><br><span class="line">    <span class="keyword">elif</span> key <span class="keyword">in</span> added_keys:</span><br><span class="line">        weights[key] = <span class="number">2</span></span><br><span class="line">    <span class="comment"># 如果键不在added_keys中，添加它。</span></span><br><span class="line">    <span class="comment"># 这确保我们并未添加权重值为1的边</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        added_keys.append(key)</span><br></pre></td></tr></table></figure> 一旦上面的代码结束运行，权重字典会包含两个机场之间的权重值超过1的边。所以任何一个被两个及以上的航线连接的机场将会展示出来。</p>
<p>现在，我们需要绘图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入networkx，初始化图形</span></span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line">graph = nx.Graph()</span><br><span class="line"><span class="comment"># 在这个集合中追踪已添加的结点，以避免我们添加两次</span></span><br><span class="line">nodes = <span class="built_in">set</span>()</span><br><span class="line"><span class="comment"># 遍历每一条边</span></span><br><span class="line"><span class="keyword">for</span> k, weight <span class="keyword">in</span> weights.items():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 分隔源和目的地id，并把它们转换成整型</span></span><br><span class="line">        source, dest = k.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">        source, dest = [<span class="built_in">int</span>(source), <span class="built_in">int</span>(dest)]</span><br><span class="line">        <span class="comment"># 若源不在nodes中，则添加它</span></span><br><span class="line">        <span class="keyword">if</span> source <span class="keyword">not</span> <span class="keyword">in</span> nodes:</span><br><span class="line">            graph.add_node(source)</span><br><span class="line">        <span class="comment"># 若目的地不在nodes中，则添加它</span></span><br><span class="line">        <span class="keyword">if</span> dest <span class="keyword">not</span> <span class="keyword">in</span> nodes:</span><br><span class="line">            graph.add_node(dest)</span><br><span class="line">        <span class="comment"># 将源和目的地都添加到nodes集合中。</span></span><br><span class="line">        <span class="comment"># 集合不允许重复</span></span><br><span class="line">        nodes.add(source)</span><br><span class="line">        nodes.add(dest)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将边添加到图上</span></span><br><span class="line">        graph.add_edge(source, dest, weight=weight)</span><br><span class="line">    <span class="keyword">except</span> (ValueError, IndexError):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">pos=nx.spring_layout(graph)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制结点和边</span></span><br><span class="line">nx.draw_networkx_nodes(graph,pos, node_color=<span class="string">&#x27;red&#x27;</span>, node_size=<span class="number">10</span>, alpha=<span class="number">0.8</span>)</span><br><span class="line">nx.draw_networkx_edges(graph,pos,width=<span class="number">1.0</span>,alpha=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://www.dataquest.io/blog/images/pyviz/nxgraph.png" /></p>
<h2 id="总结">总结</h2>
<p>已经产生了大量用于数据可视化的Python库，这使得制作几乎任何类型的可视化成为可能。大多数的库是基于matplotlib，并让某些用例更加简单。如果你想要更深入了解如何使用matplotlib, seaborn和其他工具进行数据可视化，看看我们的<a href="https://www.dataquest.io/section/data-visualization">互动课程</a>。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>没事翻着玩</tag>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>译|从零开始的 Go 内存分配器可视化指南（golang）</title>
    <url>/2019/02/25/trans-a-visual-guide-to-golang-memory-allocator-from-ground-up/</url>
    <content><![CDATA[<p>原文：<a href="https://blog.learngoprogramming.com/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed">A visual guide to Go Memory Allocator from scratch (Golang)</a></p>
<hr />
<p>当我第一次开始试图了解 Go 的内存分配器时，觉得它真令人抓狂。所有的所有都像是神秘的黑盒子。而由于几乎每一个技术魔法都隐藏在抽象之下，因此，你需要层层剥开才能理解它。</p>
<p>因此，在这篇博文中，我们将就做这件事。你想学习关于 Go 内存分配器的所有东西吗？那么，阅读这篇文章算是对了。</p>
<hr />
<h3 id="物理内存和虚拟内存">物理内存和虚拟内存</h3>
<p>每一个内存分配器都需要使用由底层操作系统管理的虚拟内存空间。我们来看看它是如何工作的。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*FS11mGLFn7uyeSlJq15K6g.png" /></p>
<p><em>上图为物理内存单元的一个简单说明（并非精确表示）</em></p>
<p><strong>单个内存单元的大大简化概述：</strong></p>
<ol type="1">
<li>地址线（晶体管作为开关）提供对电容器（数据到数据线） 的访问。</li>
<li>当地址线有电流流动时（显示为红色），那么数据线可以写入电容器，因此，电容器充电，存储的逻辑值为“1”。</li>
<li>当地址线没有电流流动时（显示为绿色），那么数据线 不可以写入电容器，因此，电容器未充电，存储的逻辑值为“0”。</li>
<li>当 CPU 需要从 RAM“读取”值时，电流会沿着“地址线”发送（关闭开关）。如果电容器正处于充电状态，那么电流则沿着“数据线”向下流动（值为 1）；否则，没有电流流过数据线，故而电容器保持不带电状态（值为 0）。</li>
</ol>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*4Zygvzn9hwFc3NCg8uWUYQ.png" /></p>
<p><em>（上图为物理内存单元与 CPU 交互方式的简单说明）</em></p>
<p><strong>数据总线：</strong>在 CPU 和物理内存之间传输数据。</p>
<p>让我们稍微聊聊<strong>地址线</strong>和<strong>可寻址字节。</strong></p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*ry7d7jMPW5_GzyPPmHubgA.png" /></p>
<p><em>CPU 和物理内存之间的地址线的说明性表示。</em></p>
<p>1. DRAM 中的每一个“字节”被赋予一个唯一的数字标识符（地址）。 <strong>“存在的物理字节 != 地址线的数目”。</strong>(<em>例如，16bit intel 8088, PAE</em>)</p>
<p>2. 每一个地址线可以发送 1-bit 值，因此，它以给定字节地址的方式指定了“一位”。</p>
<p>3. 在我们的图中，我们有 <strong>32 </strong>条地址线。因此，每一<strong>字节</strong>都有一个“32 位”地址。 <code>[ 00000000000000000000000000000000 ] — 低位内存地址。 [ 11111111111111111111111111111111 ] — 高位内存地址。</code></p>
<p>4. 由于对于每个字节我们都有一个 32 位 地址，因此，我们的地址空间由 2³² 个可寻址字节（4 GB）组成（在上面的说明性表示中）。</p>
<p>故而，可寻址字节依赖于总地址线，因此，对于 64 条地址线 （x86–64 CPU），则有 2⁶⁴ 个可寻址字节（16 个艾字节），但是，大多数使用 64 位指针的架构实际上使用的是 48 位地址线（AMD64）和 42 位地址线（Intel），因此，理论上允许 256 TB 的物理 RAM（Linux 允许<code>[带四级页面表](https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt)</code> 的 x86-64 上的每个进程拥有大小为 128TB 的地址空间，而 windows 则是 192TB）</p>
<p>由于物理 RAM 的大小有限，因此，每个进程都运行在其自己的内存沙箱中 —— “虚拟地址空间”，又称<strong>虚拟内存。</strong></p>
<p><strong>在此虚拟地址空间中的字节地址不再与处理器强加于地址总线的地址相同</strong>。一次呢，必须建立转换数据结构和系统，来将虚拟地址空间中的字节映射到物理字节。</p>
<p>这个虚拟地址长啥样呢？</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*ImbY2Tb3wZaeuKblwarFTg.jpeg" /></p>
<p><em>虚拟地址空间表示</em></p>
<p>因此，当 CPU 执行引用内存地址的指令时，第一步就是将 VMA 中的逻辑地址转换为<strong>线性地址（linear address）。</strong>此转换由 <strong>MMU</strong> 完成。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*xek5BQhJhWqsOPAaA5uROw.png" /></p>
<p><em>（这<strong>不是</strong>物理图，它只是描述。为简单起见，不包括地址转换过程。）</em></p>
<p>由于该逻辑地址太大以致于不能实际（取决于各种因素）单独管理，因此，它们是按<strong>页</strong>进行管理的。当必要的分页结构被激活时，<strong>虚拟内存空间被分成较小的区域，这就是页</strong>（<strong>在大多数的 OS 上，大小为 4kB，可以修改</strong>）。这是虚拟内存中的内存管理的最小数据单元。虚拟内存并不存储任何内容，它只是将程序的地址空间_映射_到底层的物理内存。</p>
<p>个别进程仅仅将此 VMA 视为其地址。<strong>因此，当我们的程序请求更多“堆内存”时，会发生什么呢？</strong></p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*Un3ffseQYt_y3vzObgMqfg.png" /></p>
<p>上面是一个简单的汇编代码，它请求更多的堆内存。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*mvi6PRy9wu0KmBcP9YT5Cw.png" /></p>
<p>上图为堆内存增量</p>
<p>程序通过 <code>[brk](http://www.kernel.org/doc/man-pages/online/pages/man2/brk.2.html)</code>（<code>sbrk</code>/<code>mmap</code> 等）系统调用，请求更多的内存。</p>
<p>内核仅仅更新堆 VMA，然后调用它。</p>
<blockquote>
<p>此时，实际上并没有分配任何页帧，而且新的页也不存在于物理内存中。关键是 VSZ 与 RSS 大小之间的差异点。</p>
</blockquote>
<hr />
<h3 id="内存分配器">内存分配器</h3>
<p>通过“虚拟地址空间”的基本概述，以及增加堆的含义，内存分配器现在变得更容易理解了。</p>
<blockquote>
<p>如果堆有足够的空间以满足代码的内存请求，那么内存分配器可以在没有内核参与的情况下完成请求，否则，它会通过系统（<code>_brk_</code>）调用来扩大堆，通常是请求大块内存。（默认情况下，分配大块内存意味着大于 MMAP_THRESHOLD 字节 -128 kB）。</p>
</blockquote>
<p>然而，与仅仅更新 <code>brk 地址</code> 相比，内存分配器会更尽职些。其中主要是如何同时<strong>减少</strong> <code>internal</code> 和 <code>external</code> 碎片，以及它可以<strong>多快</strong>分配块。考虑我们的程序以 p1 到 p4 的顺序，通过使用函数 <code>malloc(size)</code> 来请求连续内存块，然后使用函数 <code>free(pointer)</code> 释放该内存。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*xeMzyUdfZe9HBQABl2t9Og.png" /></p>
<p><em>上图为外部碎片演示</em></p>
<p>在步骤 p4 中，即使我们有足够的内存块，但是仍然无法满足对 6 个连续内存块的请求，从而导致内存碎片。</p>
<p><strong>所以，我们要如何减少内存碎片呢？</strong>这个问题的答案取决于底层库使用的具体的内存分配算法。</p>
<p>我们将看看 TCMalloc 概述，Go 内存分配器就是紧密模仿这个内存分配器的。</p>
<hr />
<h3 id="tcmalloc">TCMalloc</h3>
<p><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc（线程缓存内存分配）</a>的核心思想是将内存划分为多个级别，以减少锁粒度。TCMalloc 内存管理内部分为两部分：<strong>线程内存</strong>和<strong>页堆</strong>。</p>
<h4 id="线程内存">线程内存</h4>
<p>每个内存页分为 —— 多个可分配的固定大小规格（size class）的可用列表，这有助于减少<strong>碎片</strong>。因此，每个线程都将有一个没有锁的小对象缓存，这使得在并行程序下分配小对象（&lt;= 32k）效率很高。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*L6MpddL2RZY-kmguKL29jw.png" /></p>
<p><em>线程缓存（每个线程都获取自己线程的本地线程缓存）</em></p>
<h4 id="页堆page-heap">页堆（Page Heap）</h4>
<p>TCMalloc 管理的堆由一组页组成，<strong>其中，一组连续的页可以用 span 来表示</strong>。当分配的对象大于 32K 时，页堆被用于分配。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*WBLW_v9sLqFMwNdn_DZ9AA.png" /></p>
<p><em>页堆（用于 span 管理）</em></p>
<p>当没有足够的内存来分配小对象时，就会转到页堆来分配内存。如果还是不够，那么页堆将会向操作系统请求更多的内存。</p>
<p>由于这样的分配模型维护了一个用户空间的内存池，故而能够极大提高内存分配和释放的效率。</p>
<blockquote>
<p>注意：虽然说 go 内存分配器最初是基于 tcmalloc 的，但是二者之间已经分歧良多。</p>
</blockquote>
<hr />
<h3 id="go-内存分配器">Go 内存分配器</h3>
<p>我们知道，Go 运行时将 <strong>Goroutine</strong>（<strong>G</strong>）安排到<strong>逻辑处理器</strong>（<strong>P</strong>）上执行。同样，TCMalloc Go 也会将内存页划分成 <strong>67 </strong> 个不同大小规格。</p>
<blockquote>
<p>如果你不熟悉 Go 调度器，那么你可以看看概述（<a href="https://povilasv.me/go-scheduler/">Go 调度器：M，P 和 G</a>），我会在这里等你看完。</p>
</blockquote>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*dWZLGb3sJWncTdEFVuhxzw.png" /></p>
<p><em>Go 的大小规格（size class）</em></p>
<p>由于 Go 以 <strong>8192B </strong>的粒度管理页，因此如果该页面被分成大小为 <strong>1kB </strong>的块，那么，对于该页，我们就能获得总共 8 个这样的块。例如：</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*wF9KuVSk8o-16N64kB11UA.png" /></p>
<p><em>8 KB 页面被分成 1KB 的大小规格（size class）（在 Go 中，页以 8KB 的粒度进行维护）</em></p>
<p>Go 中这些页的运行也通过称为 <strong>mspan</strong> 的结构进行管理。</p>
<h4 id="mspan">mspan</h4>
<p>简单来说，它是一个双链表对象，包含页的起始地址（startAddr）、页的 span 类（spanClass）以及所包含的页数目（npages）。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*sEWsoabfndVlMDhzhdE-Mw.png" /></p>
<p>内存分配器中的 mspan 的说明性表示</p>
<h4 id="mcache">mcache</h4>
<p>正如 TCMalloc，Go 为每个<strong>逻辑处理器（P）</strong> 提供一个称为 <strong>mcache</strong> 的本地线程缓存，因此，如果 Goroutine 需要内存，那么它可以直接从 <strong>mcache</strong> 获取，而无需涉及任何的<strong>锁</strong>，因为在任何时候，<strong>逻辑处理器（P）</strong> 上面只会运行一个 <strong>Goroutine</strong>。</p>
<p><strong>mcache</strong> 包含一个由所有大小规格组成的 <strong>mspan</strong> 作为缓存。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*ypcI6WgmhQ2OyYbiucWSqA.png" /></p>
<p><em>Go 中 P、mcache 和 mspan 之间关系的说明性表示。</em></p>
<blockquote>
<p>由于每个 P 都有 mcache，因此从 mcache 分配内存的时候无需持有锁。</p>
</blockquote>
<p>对于每一种大小规格，有两种类型。</p>
<ol type="1">
<li><strong>scan</strong> — 包含指针的对象。</li>
<li><strong>noscan</strong> — 不包含指针的对象。</li>
</ol>
<p>这种方法的好处之一是在进行垃圾收集时，无需遍历 <strong>noscan</strong> 对象来找到任何包含活动对象的对象。</p>
<p><strong>啥时会用到 mcache ？</strong></p>
<blockquote>
<p>大小 &lt;= 32K 字节的对象会使用相应大小规格（size class）的 mspan，直接分配到 mcache。</p>
</blockquote>
<p><strong>当 mcache 没有空闲的 slot 时，会发生什么？</strong></p>
<p>从所需大小规格（size class）的 mspans 的 <strong>mcentral</strong> 列表中获取新的 mspan。</p>
<h4 id="mcentral">mcentral</h4>
<p>mcentral 对象收集给定大小规格（size class）的所有 span，每个 mcentral 由两个 mspans 列表组成。</p>
<ol type="1">
<li><strong>empty</strong> mspanList — 非空闲对象（或者缓存在 mcache 中）的 mspan 列表。</li>
<li><strong>nonempty</strong> mspanList — 拥有空闲对象的 span 列表。</li>
</ol>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*HgVYn7Fd7UGnGSzbx-L0fA.png" /></p>
<p><em>mcentral 的说明性表示</em></p>
<p><strong>mheap</strong> 结构维护每一个 mcentral 结构。</p>
<h4 id="mheap">mheap</h4>
<blockquote>
<p>mheap 是 Go 中管理堆的对象，全局只有一个 mheap 实例。它拥有虚拟地址空间。</p>
</blockquote>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*rTsieglF6GO1NW78KN8vkQ.png" /></p>
<p><em>mheap 的说明性表示。</em></p>
<p>正如上面说明所示，<strong>mheap 拥有一个 mcentral 数组</strong>。<strong>该数组包含由每个 span 类组成的 mcentral</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">central [numSpanClasses]<span class="keyword">struct</span> &#123;  </span><br><span class="line">  	mcentral mcentral  </span><br><span class="line">    	pad      [sys.CacheLineSize unsafe.Sizeof(mcentral&#123;&#125;)%sys.CacheLineSize]<span class="keyword">byte</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于对于每个 span 大小规格（size class），我们都有 mcentral，因此当 <strong>mcache</strong> 向 mcentral 请求 <strong>mspan</strong> 时，<strong>lock</strong> 被应用于单个 <strong>mcentral</strong> 级别，因此，还可以服务于任何其他同时请求不同大小的 <strong>mspan</strong> 的 <strong>mcache</strong>。</p>
</blockquote>
<p><em>填充（Padding）确保 MCentral 固定 CacheLineSize 字节的间隔，这样，每一个 MCentral.lock 就可以获得自己的缓存行</em>，从而避免错误的共享问题。</p>
<p>那么，当这个 <strong>mcentral</strong> 列表为空时，会发生什么呢？<strong>mcentral</strong> 会从 <strong>mheap</strong> 获取一连串的页，以组成所需大小规格（size class）的 span。</p>
<ul>
<li><strong>free [_MaxMHeapList]mSpanList</strong>：这是一个 spanList 数组。每一个 spanList 中的 <strong>mspan</strong> 由 1 ~ 127（_MaxMHeapList — 1）个页组成。例如，free[3] 是一个包含 3 个页的 <strong>mspans</strong> 链表。free 意味着空闲列表，也就是未分配。相对应的是 busy 列表。</li>
<li><strong>freelarge mSpanList</strong>：<strong>mspans</strong> 列表。列表中每个元素（也就是 mspan）的页数都比 127 大。这作为 mtreap 数据结构进行维护。相对应的是 busylarge。</li>
</ul>
<blockquote>
<p>大小 &gt; 32k 的对象是一个大对象，直接从 mheap 分配。这些大对象的分配请求是以中央锁为代价的，因此，在任何给定时间点只能处理一个 P 的请求。</p>
</blockquote>
<h3 id="对象分配流程">对象分配流程</h3>
<ul>
<li><p>大小 &gt; 32k 属于大对象，直接从 <strong>mheap</strong> 分配。</p></li>
<li><p>大小 &lt; 16B 的对象，则使用 mcache 的微小分配器（tiny allocator）进行分配</p></li>
<li><p>大小介于 16B ~ 32k 之间的对象，则会计算要使用的 sizeClass，然后使用 mcache 中对应的 sizeClass 的块分配</p>
<ul>
<li><p>如果 mcache 相应的 sizeClass 没有可用的块，则向 mcentral 申请。</p></li>
<li><p>如果 mcentral 没有可用的块，那么向 mheap 申请，然后<strong>使用 BestFit 来查找最适合的 mspan</strong>。如果超出了应用程序大小，那么，将根据需要进行划分，以返回用户所需的页数。其余的页面构成一个新的 mspan，并返回 mheap free 列表。</p></li>
<li><p>如果 mheap 没有可用的 span，那么向操作系统申请一组新的页（至少 1MB）。</p></li>
</ul></li>
</ul>
<blockquote>
<p>但是，Go 在操作系统级别分配更大的页（称为 arena）。分配大量的页会分摊与操作系统通信的成本。</p>
</blockquote>
<p><strong>堆上请求的所有内存都来自 arena。</strong>让我们来看看这个 arena 长啥样。</p>
<h3 id="go-虚拟内存">Go 虚拟内存</h3>
<p>让我们看看一个简单的 go 程序的内存。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*4bePvN9LhkTkPWlRIWGgew.png" /></p>
<p><em>一个程序的进程统计信息</em></p>
<p>所以，即使是一个简单的 go 程序，其虚拟空间大小也大概为 <code>~100 MB</code>，而 RSS 则只有 <code>696kB</code>。我们先尝试弄清楚这种差异。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*JBeUo5u5l45-3qzEQrpJ3A.png" /></p>
<p><em>map 和 smap 统计信息。</em></p>
<p>所以，存在大小大约为 <code>2MB，64MB 和 32MB</code> 的内存区域。那么，这些是什么呢？</p>
<h4 id="arena">arena</h4>
<p>原来，Go 中的虚拟内存层由一<strong>组 arena</strong> 组成。初始堆映射是一个 arena，即 <code>64MB</code>（基于 go 1.11.5）。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*yX9Q92T4B1aHEoQWTQI36g.png" /></p>
<p><em>不同系统上的当前增量 arena 大小。</em></p>
<p>因此，当前内存会按照我们程序所需以小增量进行映射，并且以一个 arena（约 64 MB）开始。</p>
<p><em>请带着怀疑的态度来看待这些数字。它们是可调整的。</em> 之前，<code>go</code> 用来预先保留连续的虚拟地址，在 64 位系统上，arena 的大小是 512 GB。（如果分配足够大，并且<strong>被 mmap 拒绝分配</strong>的话，会发生什么呢？）</p>
<p><strong>这一组 arena 就是我们所说的堆。</strong> 在 Go 中，每一个 arena 都以页（大小为 <code>8192 B</code>）粒度进行管理。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*5pyhqsz3aVLyY_kRFc7Lig.png" /></p>
<p><em>一个 arena（64 MB）</em></p>
<p>Go 还有两个块：<strong>span</strong> 和 <strong>bitmap</strong>。<strong>它们都在堆外分配，并且包含每个 arena 的元数据。</strong>它们主要在垃圾回收期间使用（所以我们这里暂且不提）。</p>
<hr />
<p>我们刚刚讨论过的 Go 中的分配策略分类，只是涉及到丰富多彩的内存分配的皮毛。</p>
<p>然而，Go 内存管理的一般思想是，对于不同大小的对象，使用不同缓存级别的内存的内存结构来分配内存。将从操作系统获得的单个连续地址块划分为不同级别的缓存，通过减少锁来提高内存分配效率，然后根据指定的大小分配内存分配，以减少内存碎片，并在释放内存后实现更快的垃圾回收。</p>
<p>现在，我就把这份 Go 内存分配器的可视化概述交给你。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*T9WO7O3EWTWJjCrxaOz4cg.png" /></p>
<p><em>运行时内存分配器的可视化概述。</em></p>
<p><img src="https://cdn-images-1.medium.com/max/2600/1*-OQBs5b4u65NRQM8aFukAw.png" /></p>
<p>好了，今天就到这了。感谢你的阅读。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>没事翻着玩</tag>
      </tags>
  </entry>
  <entry>
    <title>译 | 如何优雅地关闭 Go 中的工作 goroutine</title>
    <url>/2019/10/19/trans-go-worker-cancellation/</url>
    <content><![CDATA[<p>原文：<a href="https://callistaenterprise.se/blogg/teknik/2019/10/05/go-worker-cancellation/">Go - graceful shutdown of worker goroutines</a></p>
<hr />
<p>在这篇博文中，我们将看看 Go 程序的优雅关闭。这类 Go 程序有一些执行任务的工作 goroutine，要求在程序关闭之前，这些工作 goroutine 必须完成任务。</p>
<h1 id="介绍">介绍</h1>
<p>在一个最近的项目中，我们有一个使用场景：一个基于 Go 的微服务不断地消费另一个第三方库发出的事件。这些事件在调用外部服务之前，会进行一些处理。而外部服务处理每个请求的速度都相当慢，但另一方面，它能够处理许多并发请求。因此，我们实现了一个简单的 worker 池，将输入事件扇出为几个并发执行的 goroutine。</p>
<p>总的来说，它看起来像这样：</p>
<figure>
<img src="https://callistaenterprise.se/assets/blogg/goblog/other/blog-oct2019-1.png" alt="figure 1" /><figcaption aria-hidden="true">figure 1</figcaption>
</figure>
<p>然而，我们需要保证在该微服务关闭的时候，当前任何正在运行的对外部服务的请求必须完成，并且请求结果在我们的内部后端持久化。</p>
<h2 id="worker-池和终止信号处理">worker 池和终止信号处理</h2>
<p><a href="https://gobyexample.com/worker-pools">worker 池模式</a>是一个有名的关于 worker 池的 Go 模式。此外，还有大量关于如何进行<a href="https://gobyexample.com/signals">基于 SIGTERM 通知的优雅关闭</a>的例子。但我们意识到，我们的一些需求使得使用场景有点更复杂。</p>
<p>当程序接收到 SIGTERM 或者 SIGINT 信号（例如，因容器编排器缩容到一定数目的副本数而产生的）时，在终止整个程序之前，必须允许当前任何工作中的 worker goroutine 完成它们长期运行的工作。</p>
<p>让事情稍微复杂些的是，我们对生产者端的库没有任何控制权。一开始我们会注册一个回调函数，每当生产端的库有了一个（我们需要的）事件，就会调用这个回调函数。该库会处于阻塞状态，直到回调函数结束执行。然后，当有更多事件产生时，库会再次调用这个函数。</p>
<p>worker-pool 的诸多 goroutine 通过使用标准的“对 channel 进行 range 操作”结构，来不断处理事件，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workerFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> event := <span class="keyword">range</span> jobsChan &#123; <span class="comment">// 阻塞直到接收到一个事件，或者该 channel 被关闭。</span></span><br><span class="line">        <span class="comment">// handle the event...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这意味着，让一个 worker “结束”最干净的方式是关闭名为 “jobsChan” 的 channel。</p>
<h2 id="在生产者端进行关闭">在生产者端进行关闭</h2>
<p>你首先学到的关于在 Go 中关闭 channel 的第一件事情之一是，如果向已关闭的 channel 发送数据，程序就会 panic。这归结于一个非常简单的规则：</p>
<blockquote>
<p>“总是在生产者端关闭一个 channel（Always close a channel on the producer side）”</p>
</blockquote>
<p>不管怎样，什么是生产者端呢？嗯，一般是那个将事件发送到 channel 里的 <em>goroutine</em>： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callbackFunc</span><span class="params">(event <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	jobsChan&lt;-event</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 上面是我们的回调函数 callbackFunc，我们将其注册到外部库中，外部库就会将事件传给我们。<em>（为了让这些例子简单些，我将真实的事件替换为一个简单的整形，以作为负载。）</em></p>
<p>你要如何 <em>安全地</em> 保护上面的代码免于给已关闭的 channel 发送数据呢？一路沿着 Mutex、布尔型标志和 if 语句以确定是否一些_其他_ goroutine 关闭了 channel，以及控制是否应该允许发送数据，这并不简单。多留心潜在的竞争条件和不确定行为。</p>
<p>我们的解决方法是引入一个中间 channel 和一个内部的“消费者”，后者作为回调和任务 channel 之间的代理：</p>
<figure>
<img src="https://callistaenterprise.se/assets/blogg/goblog/other/blog-oct2019-2.png" alt="figure 2" /><figcaption aria-hidden="true">figure 2</figcaption>
</figure>
<p>消费者函数看起来像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startConsumer</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Loop until a ctx.Done() is received. Note that select&#123;&#125; blocks until either case happens</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> event := &lt;-intermediateChan:</span><br><span class="line">                jobsChan &lt;- event</span><br><span class="line">            <span class="keyword">case</span> _ &lt;- ctx.Done():</span><br><span class="line">                <span class="built_in">close</span>(jobsChan)</span><br><span class="line">                <span class="keyword">return</span>             <span class="comment">// exit this function so we don&#x27;t consume anything more from the intermediate chan</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>好了，等下。这个 “select” 和 “ctx.Done()” 是啥？</p>
<p>恕我直言，<a href="https://gobyexample.com/select">select</a> 语句是 Go 最神奇的东西之一。它允许多个 channel 的等待和协同。在这种情况下，我们或者会从中间 channel 那里收到事件，然后将其传到 jobsChan，又或者会从 <a href="https://golang.org/pkg/context/#WithCancel">context.Context</a> 接收到取消信号。</p>
<p>关闭 jobsChan 之后的 <em>return</em> 语句将让我们离开 for 循环和函数，这确保了 <em>不会有新事件被传递给</em> jobsChan,并且不会从 intermediateChan 消费到 <em>任何事件</em>。</p>
<p>所以，要么是传递事件到 jobsChan（worker 从这里消费），要么在作为生产者的 <em>同一个 goroutine 中</em> 关闭 jobsChan。</p>
<p>关闭 jobsChan 意味着消费端的所有 worker 将会停止遍历 jobsChan：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> event := <span class="keyword">range</span> jobsChan &#123; <span class="comment">// &lt;- on the close(jobsChan), all goroutines waiting for jobs here will exit the for-loop</span></span><br><span class="line">    <span class="comment">// handle the event...</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="发出取消信号">发出取消信号</h2>
<p>等待 Go 程序退出是一种有名的模式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ... rest of program ...</span><br><span class="line">    </span><br><span class="line">    termChan := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">    &lt;-termChan <span class="comment">// Blocks here until either SIGINT or SIGTERM is received.</span></span><br><span class="line">    <span class="comment">// 接下来呢？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 “接下来呢？” 这一部分，捕获到 SIGINT 或者 SIGTERM 后，主 goroutine 恢复执行。我们需要告诉将事件从 intermediateChan 传到 jobsChan 的消费者，跨 goroutine 边界关闭 jobsChan。</p>
<p>再次，使用 Mutex 和条件语句来解决这个问题，技术上是可行的，但是相当难搞并且容易出错。作为替代，我们会利用前面提及的 context.Context 的取消支持。</p>
<p>在 <em>func main()</em> 的某个地方，我们设置了一个带取消支持的根 background context：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancelFunc := context.WithCancel(ctx.Background())</span><br><span class="line">    <span class="comment">// ... some omitted code ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> startConsumer(ctx) <span class="comment">// pass the cancellable context to the consumer function</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... some more omitted code ...</span></span><br><span class="line">    &lt;-termChan</span><br><span class="line">    </span><br><span class="line">    cancelFunc() <span class="comment">// call the cancelfunc to notify the consumer it&#x27;s time to shut stuff down.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就是 <em>&lt; -ctx.Done()</em> 这一 select case 如何被调用的，它开始优雅拆卸 channel 和 worker。</p>
<h2 id="使用-waitgroup">使用 WaitGroup</h2>
<p>上面这个方法只有一个问题：调用 <em>cancelFunc()</em> 后，程序会立即退出，这意味着，正在动态调用中的工作 goroutine 将没有时间执行完毕，这使得我们系统中的处理有可能处于中间态。</p>
<p>我们需要停止关闭，直到所有的 worker 都报告说它们完成了工作。现在，我们进入 <a href="https://golang.org/pkg/sync/#WaitGroup">sync.WaitGroup</a>，它允许我们等待任意数目的 goroutine 结束！</p>
<p>当启动 worker 时，我们传递一个指向在 <em>func main()</em> 中创建的 WaitGroup 的指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numberOfWorkers = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ... omitted ...</span></span><br><span class="line">    wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(numberOfWorkers)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Start [workerPoolSize] workers</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerPoolSize; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> workerFunc(wg)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... more omitted stuff ...</span></span><br><span class="line">    </span><br><span class="line">    &lt;-termChan    <span class="comment">// wait for SIGINT / SIGTERM</span></span><br><span class="line">    cancelFunc()  <span class="comment">// send the shutdown signal through the context.Context</span></span><br><span class="line">    wg.Wait()     <span class="comment">// program will wait here until all worker goroutines have reported that they&#x27;re done</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Workers done, shutting down!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这会稍微改变我们的 worker 启动函数： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workerFunc</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done() <span class="comment">// Mark this goroutine as done! once the function exits</span></span><br><span class="line">    <span class="keyword">for</span> event := <span class="keyword">range</span> jobsChan &#123;</span><br><span class="line">        <span class="comment">// handle the event...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> <em>wg.Done()</em> 将 waitgroup 减一，一旦内部计数器变成 0，那么主 goroutine 将继续执行 <em>wg.Wait()</em> 之下的语句。这就完成了优雅关闭！</p>
<h3 id="运行">运行</h3>
<p>最终程序的源代码在下一个部分。在此其中，我添加了一些日志，这样就能看看该过程发生了什么。</p>
<p>下面是一个带有 4 个工作 goroutine 的程序的执行输出，这里，我使用 Ctrl+C 来停止程序： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span> </span><br><span class="line">  Worker <span class="number">3</span> starting</span><br><span class="line">  Worker <span class="number">2</span> starting</span><br><span class="line">  Worker <span class="number">1</span> starting</span><br><span class="line">  Worker <span class="number">0</span> starting</span><br><span class="line">  Worker <span class="number">3</span> finished processing job <span class="number">0</span></span><br><span class="line">  Worker <span class="number">0</span> finished processing job <span class="number">3</span></span><br><span class="line">  ^C*********************************     &lt;-- HERE I PRESS CTRL+C</span><br><span class="line">  Shutdown signal received</span><br><span class="line">  *********************************</span><br><span class="line">  Worker <span class="number">3</span> finished processing job <span class="number">4</span></span><br><span class="line">  Worker <span class="number">2</span> finished processing job <span class="number">1</span></span><br><span class="line">  Worker <span class="number">1</span> finished processing job <span class="number">2</span></span><br><span class="line">  Consumer received cancellation signal, closing jobsChan!   &lt;-- Here, the consumer receives the &lt;-ctx.Done()</span><br><span class="line">  Worker <span class="number">3</span> finished processing job <span class="number">6</span></span><br><span class="line">  Worker <span class="number">0</span> finished processing job <span class="number">5</span></span><br><span class="line">  Worker <span class="number">1</span> finished processing job <span class="number">8</span></span><br><span class="line">  Worker <span class="number">2</span> finished processing job <span class="number">7</span></span><br><span class="line">  Worker <span class="number">0</span> finished processing job <span class="number">10</span></span><br><span class="line">  Worker <span class="number">0</span> interrupted                    &lt;-- Worker <span class="number">0</span> has finished job #<span class="number">10</span>, <span class="number">3</span> left</span><br><span class="line">  Worker <span class="number">2</span> finished processing job <span class="number">12</span></span><br><span class="line">  Worker <span class="number">2</span> interrupted                    &lt;-- Worker <span class="number">2</span> has finished job #<span class="number">12</span>, <span class="number">2</span> left</span><br><span class="line">  Worker <span class="number">3</span> finished processing job <span class="number">9</span></span><br><span class="line">  Worker <span class="number">3</span> interrupted                    &lt;-- Worker <span class="number">3</span> has finished job #<span class="number">9</span>, <span class="number">1</span> left</span><br><span class="line">  Worker <span class="number">1</span> finished processing job <span class="number">11</span></span><br><span class="line">  Worker <span class="number">1</span> interrupted                    &lt;-- Worker <span class="number">1</span> has finished job #<span class="number">11</span>, all done</span><br><span class="line">  All workers done, shutting down!</span><br><span class="line"></span><br></pre></td></tr></table></figure> 有人可能会观察到，消费者接收到 <em>&lt; -ctx.Done()</em> 的时间点实际上是不确定的，这是因为 Go 运行时调度 channel 上的通信到 select 语句的方法。Go 规范是这样说的： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">“如果可以处理一个或多个通信，那么选择进行处理的那个 chanel 是通过统一的伪随机选择的。（If one or more of the communications can proceed, a single one that can proceed is chosen via a uniform pseudo-random selection）”。</span><br><span class="line"></span><br></pre></td></tr></table></figure> 这就是为什么即使在按下 CTRL+C 之后，任务也可以被传给 worker。</p>
<p>另一个特别的事情是，似乎即使在关闭了 jobsChan <em>之后</em>，任务（任务 9-12）还是被传给 worker 了。恩，它们实际是在该 channel 被关闭 <em>之前</em> 被传给 worker 的。这个现象会发生是因为我们使用了一个带有 4 个“槽” 的缓存 channel。这意味着，假定我们第三方生产者以比我们的 worker 可以处理的速度更快地不断传递新事件，如果所有四个 worker 都从 channel 中消费了一个任务并且处理它们，那么该 channel 里就可能会有四个新的事件正等待被消费。关闭 channel 并不会影响那些已经缓存到 channel 里的数据 —— Go 允许消费者消费它们。</p>
<p>如果我们将 jobsChan 修改为无缓存的： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">jobsChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure> 然后再次运行： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">.... omitted <span class="keyword">for</span> brevity ....</span><br><span class="line">^C*********************************</span><br><span class="line">Shutdown signal received</span><br><span class="line">*********************************</span><br><span class="line">Worker <span class="number">3</span> finished processing job <span class="number">3</span></span><br><span class="line">Worker <span class="number">3</span> started job <span class="number">5</span></span><br><span class="line">Worker <span class="number">0</span> finished processing job <span class="number">4</span></span><br><span class="line">Worker <span class="number">0</span> started job <span class="number">6</span></span><br><span class="line">Consumer received cancellation signal, closing jobsChan! &lt;-- again, it may take some time until the consumer is handed &lt;-ctx.Done()</span><br><span class="line">Consumer closed jobsChan</span><br><span class="line">Worker <span class="number">1</span> finished processing job <span class="number">1</span>     &lt;-- From here on, we see that each worker finishes exactly one job before being interrupted.</span><br><span class="line">Worker <span class="number">1</span> interrupted</span><br><span class="line">Worker <span class="number">2</span> finished processing job <span class="number">2</span></span><br><span class="line">Worker <span class="number">2</span> interrupted</span><br><span class="line">Worker <span class="number">0</span> finished processing job <span class="number">6</span></span><br><span class="line">Worker <span class="number">0</span> interrupted</span><br><span class="line">Worker <span class="number">3</span> finished processing job <span class="number">5</span></span><br><span class="line">Worker <span class="number">3</span> interrupted</span><br><span class="line">All workers done, shutting down!</span><br><span class="line"></span><br></pre></td></tr></table></figure> 这一次，在 channel 关闭后，我们就没有看到任何“不期望的”任务被 worker 消费了。然而，让 channel 缓存跟 worker 数相同的数据，是在不必要拖慢生产端的情况下，让 worker 保持处理数据的常见优化手法。</p>
<h1 id="完整的程序">完整的程序</h1>
<p>上面的代码片段在某些地方进行了简化，以使得它们尽可能简洁。带有某些结构以封装和模拟第三方生产者的完整程序如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> workerPoolSize = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建消费者</span></span><br><span class="line">	consumer := Consumer&#123;</span><br><span class="line">		ingestChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line">		jobsChan:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, workerPoolSize),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟外部库：每秒发送 10 个事件</span></span><br><span class="line">	producer := Producer&#123;callbackFunc: consumer.callbackFunc&#125;</span><br><span class="line">	<span class="keyword">go</span> producer.start()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置取消 context 和 waitgroup</span></span><br><span class="line">	ctx, cancelFunc := context.WithCancel(context.Background())</span><br><span class="line">	wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 传递取消 context 以启动消费者</span></span><br><span class="line">	<span class="keyword">go</span> consumer.startConsumer(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动 worker，并添加 [workerPoolSize] 到 WaitGroup</span></span><br><span class="line">	wg.Add(workerPoolSize)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerPoolSize; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> consumer.workerFunc(wg, i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理终止信号，并等待 termChan 信号</span></span><br><span class="line">	termChan := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	</span><br><span class="line">	&lt;-termChan         <span class="comment">// 这里阻塞直到接收到信号</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理关闭</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;*********************************\nShutdown signal received\n*********************************&quot;</span>)</span><br><span class="line">	cancelFunc()       <span class="comment">// 向 context.Context 发送取消信号</span></span><br><span class="line">	wg.Wait()          <span class="comment">// 这里阻塞直至所有 worker 完成</span></span><br><span class="line">	</span><br><span class="line">	fmt.Println(<span class="string">&quot;All workers done, shutting down!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>消费者结构： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -- 从这里起，下面是 Consumer！</span></span><br><span class="line"><span class="keyword">type</span> Consumer <span class="keyword">struct</span> &#123;</span><br><span class="line">	ingestChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">	jobsChan   <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每当外部库传递一个事件给我们，就会调用 callbackFunc。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Consumer)</span> <span class="title">callbackFunc</span><span class="params">(event <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	c.ingestChan &lt;- event</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// workerFunc 启动一个 worker 函数，它会遍历 jobsChan，直到该 channel 关闭。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Consumer)</span> <span class="title">workerFunc</span><span class="params">(wg *sync.WaitGroup, index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Worker %d starting\n&quot;</span>, index)</span><br><span class="line">	<span class="keyword">for</span> eventIndex := <span class="keyword">range</span> c.jobsChan &#123;</span><br><span class="line">		<span class="comment">// 模拟工作执行 1 ~ 3 秒</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Worker %d started job %d\n&quot;</span>, index, eventIndex)</span><br><span class="line">		time.Sleep(time.Millisecond * time.Duration(<span class="number">1000</span>+rand.Intn(<span class="number">2000</span>)))</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Worker %d finished processing job %d\n&quot;</span>, index, eventIndex)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Worker %d interrupted\n&quot;</span>, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// startConsumer 作为 ingestChan 和 jobsChan 之间的代理，使用 select 语句以支持优雅关闭。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Consumer)</span> <span class="title">startConsumer</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> job := &lt;-c.ingestChan:</span><br><span class="line">			c.jobsChan &lt;- job</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">&quot;Consumer received cancellation signal, closing jobsChan!&quot;</span>)</span><br><span class="line">			<span class="built_in">close</span>(c.jobsChan)</span><br><span class="line">			fmt.Println(<span class="string">&quot;Consumer closed jobsChan&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 最后，模拟外部库的生产者结构： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -- Producer 模拟一个外部库，每 100ms 有新数据时simulates an external library that invokes the </span></span><br><span class="line"><span class="comment">// 它会调用注册的回调函数。</span></span><br><span class="line"><span class="keyword">type</span> Producer <span class="keyword">struct</span> &#123;</span><br><span class="line">    callbackFunc <span class="function"><span class="keyword">func</span><span class="params">(event <span class="keyword">int</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Producer)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    eventIndex := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p.callbackFunc(eventIndex)</span><br><span class="line">        eventIndex++</span><br><span class="line">        time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> # 总结</p>
<p>我希望这篇小博文提供了一个简单的例子，说明了基于 goroutine 的 worker 池，以及如何使用基于 context 的取消、WaitGroup 和生产端 channel 关闭，来优雅关闭这些 goroutine。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>没事翻着玩</tag>
      </tags>
  </entry>
  <entry>
    <title>译|HTTP/3：从起源到建议</title>
    <url>/2019/01/31/trans-http-3-from-root-to-tip/</url>
    <content><![CDATA[<p>原文：<a href="https://blog.cloudflare.com/http-3-from-root-to-tip/">HTTP/3: From root to tip</a></p>
<hr />
<p>HTTP 是为 Web 提供支持的应用层协议。它始于 1991 年所谓的 HTTP/0.9 协议，到 1999 年已经演化为 HTTP/1.1，并为 IETF（Internet Engineering Task Force，互联网工程任务组）所标准化。在很长一段时间里，HTTP/1.1 已经足够好了，但是，Web 不断变化的需求使得我们需要一个更好更合适的协议，因此，在 2015 年，HTTP/2 出现了。最近，据说 IETF 打算提供新的版本 —— HTTP/3。对于一些人而言，这是个惊喜，并由此引发了一些混乱。如果你并没有密切跟踪 IETF 的工作，那么，HTTP/3 看起来似乎是凭空出现的。然而，我们可以通过一系列实验和 Web 协议（特别是 QUIC 传输协议）的演变来追溯它的起源。</p>
<p>如果你不熟悉 QUIC，那么，我的同事在关于它的不同方面已经做了相当不错的工作。John 的<a href="https://blog.cloudflare.com/the-quicening/">博客</a>描述了当今的 HTTP 的一些现实烦恼，Alessandro 的 <a href="https://blog.cloudflare.com/the-road-to-quic/">博客</a> 处理了详细的传输层细节，而 Nick 的 <a href="https://blog.cloudflare.com/head-start-with-quic/">博客</a> 介绍了如何开展一些测试。我们已经在 <a href="https://cloudflare-quic.com" class="uri">https://cloudflare-quic.com</a> 上收集了这些以及其他更多信息。如果这正中你的下怀，那么，请一定要看看 <a href="https://blog.cloudflare.com/enjoy-a-slice-of-quic-and-rust/">quiche</a>，这是我们自己用 Rust 写的 QUIC 协议的开源实现。</p>
<p>HTTP/3 是映射到 QUIC 传输层的 HTTP 应用。该名称在最近的草案版本 17（<a href="https://tools.ietf.org/html/draft-ietf-quic-http-17">draft-ietf-quic-http-17</a>）中正式被提出，该草案于 2018 年 10 月底提出，并在 11 月份曼谷举行的 IETF 103 会议期间进行了讨论且形成了粗略的共识。HTTP/3 之前被称为基于 QUIC 的 HTTP，其自身之前被称为基于 QUIC 的 HTTP/2。在此之前，我们有基于 gQUIC 的 HTTP/2，而很久以前，我们还有基于 gQUIC 的 SPDY。然而，事实是，HTTP/3 只是一种运行在 IETF QUIC 之上的新的 HTTP 语法，一种基于 UDP的多路复用和安全传输。</p>
<p>在这篇博文中，我们将探讨 HTTP/3 之前的一些名称背后的历史，并介绍最近更名背后的动机。我们将回到 HTTP 的早期阶段，触及在此过程中发生的所有好工作。如果你希望全面了解，那么可以跳到文章末尾或打开这个<a href="https://blog.cloudflare.com/content/images/2019/01/web_timeline_large1.svg">非常详细的 SVG 版本</a>。</p>
<figure>
<img src="https://blog.cloudflare.com/content/images/2019/01/http3-stack.png" alt="一个 HTTP/3 层蛋糕" /><figcaption aria-hidden="true">一个 HTTP/3 层蛋糕</figcaption>
</figure>
<h2 id="设置场景">设置场景</h2>
<p>在我们专注 HTTP 之前，值得提醒自己的是，有两种协议共享名称 QUIC。正如我们<a href="https://blog.cloudflare.com/the-road-to-quic/">前面</a>解释的那样，gQUIC 通常用于标识谷歌的（原始协议），而 QUIC 通常用于表示与 gQUIC 不同的 IETF 的标准进行中的版本。</p>
<p>从 90 年代初期开始，网络的需求就发生了变化。我们已经有了新版本的 HTTP，并以传输层安全（Transport Layer Security，TLS）的形式增加了用户安全性。本文中我们将只涉及 TLS，如果你想更详细地探索该领域，那么我们其他的<a href="https://blog.cloudflare.com/tag/tls/">博客文章</a>是一个很棒的来源。</p>
<p>为了帮助解释 HTTP 和 TLS 的历史，我开始整理协议规范和日期的细节。此信息通常以文本的形式呈现，例如按照日期排序的说明文档标题的符号点列表。但是，存在分支标准，每个标准都在时间上重叠，而简单的列表无法表达关系的真实复杂性。在 HTTP 中，已经存在了重构核心协议定义以便于使用、扩展协议以用于新用途以及重新定义协议通过互联网交换数据的方式以提高性能的并行工作。当你尝试着在不同分支工作流中整理近 30 年的互联网历史时，你会需要可视化。所以我做了一张 —— Cloudflare Secure Web Timeline. （注意：技术上讲，它是一张<a href="https://en.wikipedia.org/wiki/Cladogram">分段图</a>，但是时间轴这一术语更广为人知些）。</p>
<p>我在创建它的时候使用了一些艺术许可，并且选择专注于 IETF 空间中的成功分支。一些未显示的内容包括 W3 Consortium <a href="https://www.w3.org/Protocols/HTTP-NG/">HTTP-NG</a> 工作组的努力，以及他们的作者热衷于解释如何发音的一些奇特的想法：<a href="https://blog.jgc.org/2012/12/speeding-up-http-with-minimal-protocol.html">HMURR （发音为 'hammer'）</a> 以及 <a href="https://github.com/HTTPWorkshop/workshop2017/blob/master/talks/waka.pdf">WAKA （发音为 “wah-kah”）</a>。</p>
<p>在接下来的几节中，我将按照这张时间表来解释 HTTP 历史中的关键章节。要享受这篇文章的内容，理解为什么标准化是有益的，以及 IETF 是如何着手处理的是很有帮助的。因此，在回到时间轴之前，我们将首先简要介绍该主题。如果你已经熟悉 IETF，那么请随意跳过下一部分。</p>
<h2 id="互联网标准的类型">互联网标准的类型</h2>
<p>通常，标准定义了公共的参考术语、范围、约束、适用性和其他考虑因素。标准存在许多规格，并且可以是非正式的（也就是事实上的）或者正式的（由诸如 IETF、ISO 或者 MPEG 这样的标准定义组织统一或者发布）。标准被用于许多领域，甚至有正式的英国制茶标准 —— BS 6008。</p>
<p>早期 Web 使用的是 IETF 外部发布的 HTTP 和 SSL 协议定义，这些定义在安全 Web 时间线上被标记为<strong>红线</strong>。客户端和服务器对这些协议的采用使得它们成为了事实上的标准。</p>
<p>在某些时候会决定将这些协议正式化（后面的部分会描述一些动机原因）。互联网标准通常在 IETF 中定义，遵循“粗略共识和运行代码”的非正式原则。这是基于在互联网上开发和部署内容的经验。与尝试在真空中开发完美方案的“净室”形成对比。</p>
<p>IETF 互联网标准通常称为 RFC。这是一个解释起来很复杂的领域，所以我建议你阅读由 QUIC 工作组联合主席 Mark Nottingham 撰写的博客文章“<a href="https://www.ietf.org/blog/how-read-rfc/">如何阅读 RFC</a>”。工作组（或者称为 WG）或多或少只是一个邮件列表。</p>
<p>每年，IETF 举行三次会议，为所有的工作组提供时间和设施以亲自见面（如果他们愿意的话）。这几周的议程可能变得非常拥挤，只有有限的时间可以深入讨论高度技术性的领域。为了解决这个问题，一些工作组选择在 IETF 一般会议之间的几个月内举行临时会议。这有助于保持规范开发的势头。自 2017 年以来，QUIC 工作组已经举行了几次临时会议，在他们的<a href="https://datatracker.ietf.org/wg/quic/meetings/">会议页面</a>上，你可以看到完整的清单。</p>
<p>这些 IETF 会议还为其他与 IETF 相关的人群（例如 <a href="https://www.iab.org/">互联网架构委员会（Internet Architecture Board）</a> 或者 <a href="https://irtf.org/">互联网研究工作组（Internet Research Task Force）</a>）提供了见面的机会。近年来，<a href="https://www.ietf.org/how/runningcode/hackathons/">IETF 黑客马拉松</a>会在 IETF 会议之前的周末举行。这为社区提供了开发运行代码的机会，更重要的是，与他人在同一个房间内进行互操作性测试。这有助于查找可在接下来几天中讨论的规范中的问题。</p>
<p>而出于此文的目的，需要理解的重要事项是，RFC 并不会刚好存在。相反，它们会经历一个通常以 IETF 互联网草案（I-D）格式（该格式是为了考虑采用而提交的）开始的流程。在已经存在发布规范的情况下，一份 I-D 的准备可能只是一次简单的重新格式化练习。I-D 们自发布日起有六个月的有效期。而要让它们保持活跃，则需要发布新的版本。实践中，让一份 I-D 就这么过去并不会有太大的后果，并且这种事时有发生。这些文件会继续托管在 <a href="https://datatracker.ietf.org/doc/recent">IETF 文档网站</a>上，供任何想要阅读它们的人查阅。</p>
<p>I-D 在安全 Web 时间线上表示为 <strong>紫色线条</strong>。每一个都有一个唯一的名称，格式为 <em>draft-{作者名}-{工作组}-{主题}-{版本}</em>。工作组字段是可选的，它可能预示处理该文件的 IETF 工作组，并且有时这会发生变化。如果 IETF 采用了一份 I-D，或者如果 I-D 是直接在 IETF 内启动的，那么名称格式则为 <em>draft-ietf-{工作组}-{主题}-{版本}</em>。I-D 可能会出现分支、合并或消亡。版本从 00 开始，每次发布新草稿时加一。例如，一份 I-D 的第四稿版本为 03。一旦 I-D 改名，那么它的版本将重置为 00。</p>
<p>值得注意的是，任何人都可以向 IETF 提交 I-D；所以你不应该将这些视为标准。但是，如果一份 I-D 的 IETF 标准化过程确实达成了共识，并且最终文档通过了审核，那么，我们最终就获得了一份 RFC。在此阶段，它的名称会再次发生变化。每一份 RFC 都哟一个唯一编号，例如 <a href="https://tools.ietf.org/html/rfc7230">RFC 7230</a>。这些在安全 Web 时间线上表示为<em>蓝线</em>**。</p>
<p>RFC 是不可变文档。这意味着，对 RFC 的更改需要一个全新的编号。可能会对其进行更改以便合并勘误表（已发现和报告的编辑或技术错误），或者仅仅是重构规范以改进布局。RFC 可能会<strong>淘汰</strong>旧版本（完全替代），或者只是<strong>更新</strong>它们（实质性更改）。</p>
<p>所有的 IETF 文档均可在 <a href="http://tools.ietf.org" class="uri">http://tools.ietf.org</a> 上公开获得。就个人而言，我发现 <a href="https://datatracker.ietf.org">IETF Datatracker</a> 更加有友好些，因为它提供了从 I-D 到 RFC 的文档进度可视化。</p>
<p>下面是一个显示 <a href="https://tools.ietf.org/html/rfc1945">RFC 1945</a> - HTTP/1.0 开发的示例，它是安全 Web 时间线的明确灵感来源。</p>
<figure>
<img src="https://blog.cloudflare.com/content/images/2019/01/RFC-1945-datatracker.png" alt="RFC 1945 的 IETF Datatracker 视图" /><figcaption aria-hidden="true">RFC 1945 的 IETF Datatracker 视图</figcaption>
</figure>
<p>有趣的是，在工作过程中，我发现上面的可视化是不正确的。由于某些原因，它缺少 <a href="https://tools.ietf.org/html/draft-ietf-http-v10-spec-05">draft-ietf-http-v10-spec-05</a>。由于 I-D 的有效期为六个月，因此，在它成为 RFC 之前似乎存在缺口，而实际上，草案 05 在 1996 年 8 月份之前仍然有效。</p>
<h2 id="探索安全-web-时间线">探索安全 Web 时间线</h2>
<p>稍微理解了一下互联网标准文档是如何实现的，我们可以开始聊聊安全 Web 时间线了。在这个章节中，会有显示时间轴的重要部分的一些摘录图。每个点代表文档或者功能可用的日期。对于 IETF 文档，为了清晰起见，我们省略了草稿编号。但是，如果你想查看所有细节，那么请看<a href="https://blog.cloudflare.com/content/images/2019/01/web_timeline_large1.svg">完整的时间线</a>。</p>
<p>HTTP 开始于 1991 年所谓的 HTTP/0.9，然后在 1994 年发布了I-D <a href="https://tools.ietf.org/html/draft-fielding-http-spec-00">draft-fielding-http-spec-00</a>。这很快就被 IETF 所采用，导致其名称更改为 <a href="https://tools.ietf.org/html/draft-ietf-http-v10-spec-00">draft-ietf-http-v10-spec-00</a>。该 I-D 在 1996 年作为 <a href="https://tools.ietf.org/html/rfc1945">RFC 1945</a> - HTTP/1.0 发布之前经历了六个草案版本。</p>
<p><img src="https://blog.cloudflare.com/content/images/2019/01/http11-standardisation.png" /></p>
<p>然而，在 HTTP/1.0 的相关工作完成之前，就已经有了在 HTTP/1.1 上启动的单独活动了。I-D <a href="https://tools.ietf.org/html/draft-ietf-http-v11-spec-00">draft-ietf-http-v11-spec-00</a> 于 1995 年 11 月发布，并于 1997 年正式发布为 <a href="https://tools.ietf.org/html/rfc2068">RFC 2068</a>。仔细一看你会发现，安全 Web 时间线并未完全捕获该事件序列，这是用来生成该可视化的工具的不幸的副作用。我会努力尽可能减少此类问题的。</p>
<p>1997 年中期以 <a href="https://tools.ietf.org/html/draft-ietf-http-v11-spec-rev-00">draft-ietf-http-v11-spec-rev-00</a> 的形式开始了 HTTP/1.1 的修订工作。1999 年 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 的出版标志着这项工作的完成。直到 2007 年，IETF HTTP 世界都很安静。我们很快会回到这点。</p>
<h2 id="ssl-和-tls-的历史">SSL 和 TLS 的历史</h2>
<p><img src="https://blog.cloudflare.com/content/images/2019/01/ssl-tls-standardisation.png" /></p>
<p>将注意力放在 SSL 上。我们看到，SSL 2.0 规范是在 1995 年左右发布的，而 SSL 3.0 是在 1996 年 11 月发布的。有趣的是，SSL 3.0 是在 <a href="https://tools.ietf.org/html/rfc6101">RFC 6101</a> 中描述的，该 RFC 于 2011 年 8 月发布。它位于<strong>历史</strong>类别中，该类别“通常是被考虑和被丢弃的文档想法，或者是在决定记录它们时已经具有历史意义的协议”（根据 <a href="https://www.ietf.org/blog/iesg-statement-designating-rfcs-historic/?primary_topic=7&amp;">IETF</a>）。在这种情况下，有一个描述 SSL 3.0 的 IETF 文档是有利的，因为在其他地方，它可以被用作规范参考。</p>
<p>我们更感兴趣的是，SSL 是如何激发 TLS 的发展的，后者在 1996 年 11 月以 <a href="https://tools.ietf.org/html/draft-ietf-tls-protocol-00">draft-ietf-tls-protocol-00</a> 宣告开始。它经历了六个草案版本，并于 1999 年初作为 <a href="https://tools.ietf.org/html/rfc2246">RFC 2246</a> - TLS 1.0 发布。</p>
<p>在 1995 和 1999 年间，SSL 和 TLS 协议用于保护互联网上的 HTTP 通信。这作为事实上的标准运行良好。直到 1998 年 1 月，随着 I-D <a href="https://tools.ietf.org/html/draft-ietf-tls-https-00">draft-ietf-tls-https-00</a> 的发布，HTTPS 的正式标准化过程才开始。该工作于 2000 年 5 月以 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> - HTTP 上的 TLS 的发布结束。</p>
<p>TLS 在 2000 到 2007 年间继续发展，标准化为 TLS 1.1 和 1.2。直至七年后，TLS 的下一个版本开始进行，该版本在 2014 年四月被采纳为 <a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-00">draft-ietf-tls-tls13-00</a>，并在 28 份草稿后，于 2018 年八月出了完成版本 <a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a> - TLS 1.3。</p>
<h2 id="互联网标准化进程">互联网标准化进程</h2>
<p>在看了一下该时间线后，我希望你能够了解 IETF 的工作原理。 对于互联网标准形成方式的一个概括就是，研究人员或者工程师涉及适合其特定用途的实验协议。他们以不同规模，或公开或私人地试验这些协议。数据有助于识别改进或者问题。可能会发布这些工作来解释试验，用以收集更广泛的意见，或者帮助找到其他实现者。其他人对这项早期工作的接受可能会让其成为事实上的标准；最终，可能会有足够的动力使得正式标准化成为可能。</p>
<p>对于可能在考虑实现、部署或以某种方式使用一个协议的的组织，其状态可能是一个重要的考虑因素。正式的标准化过程可以使事实上的标准更具吸引力，因为这倾向于提供稳定性。诸如 IETF 这样的组织提供管理和指导，反映了更广泛的经验。但是，值得强调的是，并非所有正式标准都能成功。</p>
<p>创建最终标准的过程几乎与标准本身一样重要。有一个最初的想法，然后邀请具有更广泛知识、经验和用例的人们贡献，有助于产生对更广泛的人群更有用的东西。然而，标准化过程并不总是那么容易。存在缺陷和障碍。有时，该过程太漫长，以至于输出不再相关。</p>
<p>每一个标准定义组织都倾向于拥有自己的围绕所属领域和参与者的流程。解释 IETF 的工作方式的所有细节远远超出本博客的范围。IETF 的“<a href="https://www.ietf.org/how/">我们是如何工作的</a>” 页面是一个很好的起点，涵盖了许多方面。像往常一样，形成理解的最佳方式是亲自参与。这可以像加入电子邮件列表，或者到相关 GitHub 存储库上参与讨论一样简单。</p>
<h2 id="cloudflare-的运行代码">Cloudflare 的运行代码</h2>
<p>Cloudflare 很自豪能够成为新的和不断发展的协议的早期采用者。我们有早早采用新标准的长长的记录，例如 <a href="https://blog.cloudflare.com/introducing-http2/">HTTP/2</a>。我们还测试了实验性或者尚未定案的协议，例如 <a href="https://blog.cloudflare.com/introducing-tls-1-3/">TLS 1.3</a> 和 <a href="https://blog.cloudflare.com/introducing-spdy/">SPDY</a>。</p>
<p>关于 IETF 标准化过程，在各种网站的真实网络中部署此运行代码有助于我们了解协议在实践中的运行情况。我们将现有的专业知识和实验信息相结合，以帮助改善运行代码，并在有意义的情况下，向正在标准化协议的工作组反馈问题和改进。</p>
<p>测试新事物并非唯一的优先事项。创新者需要是知道什么时候该向前推进，并将老点的东西放在“后视镜”中。有时，有时，这涉及到面向安全的协议，例如，因为 POODLE 漏洞，Cloudflare <a href="https://blog.cloudflare.com/sslv3-support-disabled-by-default-due-to-vulnerability/">默认禁用了 SSLv3</a>。在其他情况下，协议会被技术更先进的协议所取代；Cloudflare <a href="https://blog.cloudflare.com/deprecating-spdy/">弃用了 SPDY</a> 支持以支撑 HTTP/2。</p>
<p>相关协议的引进了弃用在安全 Web 时间线上表示为<strong>橙色线</strong>。虚垂直线有助于将 Cloudflare 事件与相关的 IETF 文档相关联。例如，Cloudflare 在 2016 年九月份引入了 TLS 1.3 支持，而其最终文档 <a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a> 在几乎两年后（2018 年八月份）才发布。</p>
<p><img src="https://blog.cloudflare.com/content/images/2019/01/cf-events.png" /></p>
<h2 id="httpbis-的重构">HTTPbis 的重构</h2>
<p>HTTP/1.1 是一个非常成功的协议，而时间线现实，1999 年之后，IETF 并没有太多的活动。然而，真相是，多年的积极使用提供了实施经验揭露了 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 的潜在问题，会导致一些互操作性问题。此外，其他 RFC（例如 2817 和 2818）扩展了该协议。2007 年决定启动一项新活动来改进 HTTP 协议规范。这就是所谓的 HTTPbis（其中，“bis”源于拉丁文，语义是“两个”、“两次”或者“重复”）,并且它采用了新工作组的形式。原始<a href="https://tools.ietf.org/wg/httpbis/charters?item=charter-httpbis-2007-10-23.txt">章程</a>很好地描述了试图解决的问题。</p>
<p>简而言之，HTTPbis 决定重构 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a>。它将包含勘误修复，并引入在此期间发布的其他规范的某些方面。并决定将文档分成几部分。这导致了 2007 年 12 月发布了六份 I-D：</p>
<ul>
<li>draft-ietf-httpbis-p1-messaging</li>
<li>draft-ietf-httpbis-p2-semantics</li>
<li>draft-ietf-httpbis-p4-conditional</li>
<li>draft-ietf-httpbis-p5-range</li>
<li>draft-ietf-httpbis-p6-cache</li>
<li>draft-ietf-httpbis-p7-auth</li>
</ul>
<p><img src="https://blog.cloudflare.com/content/images/2019/01/http11-refactor.png" /></p>
<p>该图显示了这项工作是如何历经长达七年的起草过程，并在最终标准化之前发布了 27 个草案版本。2014 年六月，发布了所谓的 RFC 723x 系列（其中，x 的范围从 0 到 5）。HTTPbis WG 的主席通过“<a href="https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead">RFC2616 已死</a>” 来庆祝这一成就。也就是说，这些新文档将废弃旧的 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a>。</p>
<h2 id="这与http-3有什么关系">这与HTTP / 3有什么关系？</h2>
<p>虽然 IETF 正忙着研究 RFC 723x 系列，但是世界并未停止运转。人们继续在互联网上增强、扩展和实验 HTTP。其中就有谷歌，他们已经开始尝试一种名为 SPDY（发音为 speedy）的协议。该协议被吹捧为能够提高 web 浏览的性能，而这是 HTTP 的一种主要用例。在 2009 年末，SPDY v1 发布，随后在 2010 年很快就推出了 SPDY v2。</p>
<p>我想要避免深入 SPDY 的技术细节。这些择日再谈。重要的是，要了解 SPDY 采用了 HTTP 的核心范例，并且稍微修改了交换格式以获取改进。我们可以看到，HTTP 明确地划分了语义和语法。语义描述了请求和响应交换的概念，包括：方法、状态码、头部字段（元数据）和消息体（有效负载）。语法描述了如何将语义映射到线路上的字节。</p>
<p>HTTP/0.9、1.0 和 1.1 共享了许多语义。它们还以通过 TCP 连接发送字符串的形式共享了语法。 SPDY 采用了 HTTP/1.1 语义，但是将语法从字符串更改为二进制。这是一个非常有趣的话题，但是今天我们并不会深入挖掘。</p>
<p>谷歌对 SPDY 的实验表明，改变 HTTP 语法是有前景的，并且保留现有的 HTTP 语义也是有价值的。例如，保持使用 http:// 的 URL 格式可以避免许多可能影响采用的问题。</p>
<p>看到一些积极的结果后，IETF 决定是时候考虑 HTTP/2.0 了。2012 年三月 IETF 83 期间举行的 HTTPbis 会议的 <a href="https://github.com/httpwg/wg-materials/blob/gh-pages/ietf83/HTTP2.pdf">幻灯片</a> 显示了成功的要求、目标和衡量标准。它还明确指出，“HTTP/2.0 只表示其传输格式与 HTTP/1.x 不兼容”。</p>
<p><img src="https://blog.cloudflare.com/content/images/2019/01/http2-standardisation.png" /></p>
<p>在那次会议期间，社区被邀请分享提案。提交审议的 I-D 包括 <a href="https://tools.ietf.org/html/draft-mbelshe-httpbis-spdy-00">draft-mbelshe-httpbis-spdy-00</a>、<a href="https://tools.ietf.org/html/draft-montenegro-httpbis-speed-mobility-00">draft-montenegro-httpbis-speed-mobility-00</a> 和 <a href="https://tools.ietf.org/html/draft-tarreau-httpbis-network-friendly-00">draft-tarreau-httpbis-network-friendly-00</a>。最终，通过了 SPDY 草案，并于 2012 年十一月开始 <a href="https://tools.ietf.org/html/draft-ietf-httpbis-http2-00">draft-ietf-httpbis-http2-00</a>。在经历两年多的时间的 18 份草案，<a href="https://tools.ietf.org/html/rfc7540">RFC 7540</a> - HTTP/2 于 2015 年发布。在此规范期间，HTTP/2 的精确语法偏移到刚好使得 HTTP/2 与 SPDY 不兼容。</p>
<p>这些年是 IETF 关于 HTTP 工作的一个非常繁忙的时期，HTTP/1.1 重构和 HTTP/2 标准化并行。这与 21 世纪初多年的静寂形成了鲜明的对比。请务必看完完整的时间线，以真正了解所发生的工作。</p>
<p>虽然 HTTP/2 正处于标准化过程，但是使用和试验 SPDY 仍然有好处。Cloudflare 在 2012 年八月份<a href="https://blog.cloudflare.com/spdy-now-one-click-simple-for-any-website/">引入了对 SPDY 的支持</a>，并在 2018 年二月份我们的统计显示不到 4% 的 Web 客户继续想要 SPDY 的时候才弃用了它。同时，我们在 2015 年十二月份<a href="https://blog.cloudflare.com/introducing-http2/">推出了对 HTTP/2 的支持</a>，也就是在 RFC 发布后不久，那个时候，我们的分析表明，有意义的一部分 Web 客户端可以利用它。</p>
<p>Web 客户端对 SPDY 和 HTTP/2 协议的支持首选使用 TLS 的安全选项。2014 年九月份<a href="https://blog.cloudflare.com/introducing-universal-ssl/">通用 SSL</a> 的引入有助于确保所有注册到 Cloudflare 的网站都能够在我们引入这些新协议时利用它们。</p>
<h3 id="gquic">gQUIC</h3>
<p>谷歌在 2012 到 2015 年间继续进行实验，并且发布了 SPDY v3 和 v3.1。他们还开始研究 gQUIC（当时发音为 quick），并在 2012 年初推出了最初的公开规范。</p>
<p>gQUIC 的早期版本利用了 SPDY v3 形式的 HTTP 语法。这一选择很有意义，因为 HTTP/2 尚未完成。SPDY 二进制语法被打包成可以在 UDP 数据报中发送的 QUIC 包。这与 HTTP 传统上依赖的 TCP 传输有所不同。将这些都堆叠在一起后，看起来像：</p>
<figure>
<img src="https://blog.cloudflare.com/content/images/2019/01/gquic-stack.png" alt="SPDY 位于 gQUIC 层之上的蛋糕" /><figcaption aria-hidden="true">SPDY 位于 gQUIC 层之上的蛋糕</figcaption>
</figure>
<p>gQUIC 使用了巧妙之计来实现性能。其中之一就是打破应用和传输之间的明确分层。这在实践中意味着 gQUIC 只支持 HTTP。甚至于当时被称为“QUIC”的 gQUIC 与作为 HTTP 的下一个候选版本同义。尽管在过去几年中 QUIC 不断发生变化（这个我们将暂时触及），但是，时至今日，人们还是将 QUIC 这个术语理解为最初的仅限 HTTP 的变体。不幸的是，这是在讨论该协议的时候经常引起混乱的源头。</p>
<p>gQUIC 继续进行实验，并最终切换到更接近于 HTTP/2 的语法。事实如此接近，以致于大多数人都将其简称为“基于 QUIC 的 HTTP/2”。然而，由于技术限制，它们还是存在一些非常微妙的差异的。其中一个例子就是涉及如何序列化和交换 HTTP 头部。这是一个微小差异，但实际上意味着基于 gQUIC 的 HTTP/2 与 IETF 的 HTTP/2 并不兼容。</p>
<p>最后但同样重要的是，我们始终需要考虑互联网协议的安全性。gQUIC 选择不使用 TLS 来提供安全性。相反，谷歌开发了一种不同方法，称为 QUIC Crypto。其中一个有趣的方面是用以加速安全握手的新方法。一个之前已经与服务端建立了安全会话的客户端可以重用信息来进行“零往返时间”（0-RTT）握手。 0-RTT 后来被纳入 TLS 1.3。</p>
<h2 id="那么到了你可以告诉我什么是-http3-的时候了吗">那么到了你可以告诉我什么是 HTTP/3 的时候了吗？</h2>
<p>差不多了。</p>
<p>到目前为止，你应该熟悉了标准化的工作原理，以及 gQUIC 并没有太大的不同。人们对谷歌规范以 I-D 的格式编写表示出了足够的兴趣。2015 年六月份，提交了题为“QUIC：基于 UDP 的 HTTP/2 安全可靠的传输”的<a href="https://tools.ietf.org/html/draft-tsvwg-quic-protocol-00">draft-tsvwg-quic-protocol-00</a>。请记住我之前的声明，它的语法几乎是与 HTTP/2 相同。</p>
<p>谷歌<a href="https://groups.google.com/a/chromium.org/forum/#!topic/proto-quic/otGKB4ytAyc">宣布</a>将在布达拉宫的 IETF 93 举行 Bar BoF。对于那些对“Bar BoF”是什么感到好奇的人，请查阅 <a href="https://tools.ietf.org/html/rfc6771">RFC 6771</a>。提示：BoF 代表一丘之貉。</p>
<p><img src="https://blog.cloudflare.com/content/images/2019/01/quic-standardisation.png" /></p>
<p>简而言之，与 IETF 合作的结果是，QUIC 似乎提供了许多传输层方面的优势，因此应该与 HTTP 分离。应该重新引入层与层之间的明确分离。此外，有人倾向于回到基于 TLS 的握手（由于在此阶段 TLS 1.3 正在进行，并且正与 0-RTT 握手进行整合，因此并没有那么糟糕）。</p>
<p>大约一年后，在 2016 年，提交了一套新的 I-D：</p>
<ul>
<li><a href="https://tools.ietf.org/html/draft-hamilton-quic-transport-protocol-00">draft-hamilton-quic-transport-protocol-00</a></li>
<li><a href="https://tools.ietf.org/html/draft-thomson-quic-tls-00">draft-thomson-quic-tls-00</a></li>
<li><a href="https://tools.ietf.org/html/draft-iyengar-quic-loss-recovery-00">draft-iyengar-quic-loss-recovery-00</a></li>
<li><a href="https://tools.ietf.org/html/draft-shade-quic-http2-mapping-00">draft-shade-quic-http2-mapping-00</a></li>
</ul>
<p>这是关于 HTTP 和 QUIC 之间的混乱的另一个源头。<a href="https://tools.ietf.org/html/draft-shade-quic-http2-mapping-00">draft-shade-quic-http2-mapping-00</a> 的标题是“使用 QUIC 传输协议的 HTTP/2 语义”，它将自己描述为“QUIC 之上的 HTTP/2 语义映射”。然而，这里用词不当。HTTP/2 在保持语义的同时对语法进行了更改。此外，由于我之前所概述的原因，“基于 gQUIC 的 HTTP/2” 也从来不是对语法的精确描述。请坚持这个想法。</p>
<p>QUIC 的这个 IETF 版本将是一个全新的传输协议。这是一项艰巨的任务，而在先投入这些承诺之前，IETF 喜欢衡量其成员的实际利益。为此，2016 年在柏林举行的 IETF 96 上举行了正式的 <a href="https://www.ietf.org/how/bofs/">BoF</a> 会议。我很荣幸能够亲自参与会议，但是，<a href="https://datatracker.ietf.org/meeting/96/materials/slides-96-quic-0">幻灯片</a> 并不公正。如 Adam Roach 的<a href="https://www.flickr.com/photos/adam-roach/28343796722/in/photostream/">照片</a> 所示，数百人参加了会议。会议结束时达成了共识；IETF 将会采用 QUIC 并对其进行标准化。</p>
<p>第一份将 HTTP 映射到 QUIC 的 IETF QUIC I-D <a href="https://tools.ietf.org/html/draft-ietf-quic-http-00">draft-ietf-quic-http-00</a>，采用了 Ronseal 的方法，并将其名简化为“基于 QUIC 的 HTTP”。不幸的是，工作并未完全完成，整个机构中还是存在许多 HTTP/2 术语的其他名称。Mike Bishop，也就是该 I-D 新的编辑，发现了这一点，并开始修复 HTTP/2 的误称。在 01 草案中，描述修改为“基于 QUIC 的 HTTP 语义映射”。</p>
<p>随着时间和版本的逐渐增加，术语“HTTP/2”的使用减少了，而实例成了对 <a href="https://tools.ietf.org/html/rfc7540">RFC 7540</a> 部分的单纯应用。向前推进两年直至 2018 年十月，现在，I-D 是版本 16 了。虽然基于 QUIC 的 HTTP 与 HTTP/2 相似，但它最终是一个独立的非向后兼容的 HTTP 语法。然而，对于那些并不密切跟踪 IETF 发展的人（占了地球人口相当巨大的一部分），文档名称并没有显示这种差异。标准化的其中一个要点是帮助沟通和互操作。然而，像命名这样简单的的事情却是导致社区混乱的主要原因。</p>
<p>回响一下我们在 2012 年所说的，“HTTP/2.0 仅表示传输格式与 HTTP/1.x 的格式不兼容”。IETF 遵循了这一项现有提示。在经过 IETF 103 之前和期间的深思熟虑后，达成了将“基于 QUIC 的 HTTP”更名为 HTTP/3 的共识。现在，世界更加美好，我们可以接着进行更重要的讨论了。</p>
<h2 id="但是-rfc-7230-和-7231-并不同意你对语义和语法的定义">但是 RFC 7230 和 7231 并不同意你对语义和语法的定义！</h2>
<p>有时，文档标题可能会让人感到困惑。目前描述语法和语义的 HTTP 文档是：</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc7230">RFC 7230</a> - 超文本传输协议（HTTP/1.1）：消息语法和路由</li>
<li><a href="https://tools.ietf.org/html/rfc7231">RFC 7231</a> - 超文本传输协议（HTTP/1.1）：语义和内容</li>
</ul>
<p>有可能过度解读这些名字，然后认为基本的 HTTP 语义特定于 HTTP 版本，例如 HTTP/1.1。但是，这是 HTTP 系列树的意外副作用。好消息是，HTTPbis 工作组正试图解决这个问题。一些勇敢的成员正进行另一轮的文档修订，正如 Fielding 所说，“再来一次！”。这项工作正在进行中，并且被称为 HTTP 核心活动（你可能也在标记为 HTTPtre 或者 HTTPter 下听说过这个；命名是件难事）。这将把六个草案缩减为三个：</p>
<ul>
<li>HTTP 语义 (draft-ietf-httpbis-semantics)</li>
<li>HTTP 缓存 (draft-ietf-httpbis-caching)</li>
<li>HTTP/1.1 消息语法和路由 (draft-ietf-httpbis-messaging)</li>
</ul>
<p>在此新结构下，HTTP/2 和 HTTP/3 是常见的 HTTP 语义的语法定义变得更加明显。这并不意味着除了语法以外，它们没有自己的特性，但这应该有助于框架讨论。</p>
<h2 id="总结一下">总结一下</h2>
<p>本文简要介绍了在过去三十年，IETF 对 HTTP 的标准化过程。在不触及许多技术细节的情况下，我试图解释如今怎么会有 HTTP/3 的。如果你跳过了中间部分，并且在寻找一句话总结，那么这里就是：HTTP/3 只是一种运行在 IETF QUIC 上的新的 HTTP 语法，一种基于 UDP 的多路复用和安全传输。还有许多有趣的技术领域有待进一步的探索，但这已经是后面的事情了。</p>
<p>在这篇文章中，我们探讨了 HTTP 和 TLS 开发中的重要章节，这些章节是相互独立的。最后，我们将其全部整合到下面提供的完整的安全 Web 时间线中。你可以自行使用它来调查详细的历史记录。对于那些“超级侦探”，请务必查看<a href="https://blog.cloudflare.com/content/images/2019/01/web_timeline_large1.svg">包含草稿编号的完整版本</a>。</p>
<p><img src="https://blog.cloudflare.com/content/images/2019/01/cf-secure-web-timeline-1.png" /></p>
<p>（Ele 注：一开始翻这篇文章的时候以为是讲 HTTP/3 的细节的，翻译的过程中才发现原来是讲历史呀。但是无论如何，了解下互联网协议的生成更新过程以及历史，也是挺有意思的(*^__^*)）</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>没事翻着玩</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>译|Go 的工具箱综述</title>
    <url>/2019/05/14/an-overview-of-go-tooling/</url>
    <content><![CDATA[<p>原文：<a href="https://www.alexedwards.net/blog/an-overview-of-go-tooling">An Overview of Go's Tooling</a></p>
<hr />
<p>偶尔会有人问我，<em>“为什么你会喜欢用 Go 呢？”</em> 在我的回答中，有一个我经常提到的原因，那就是和 Go 一起存在的那些好用的工具，并且它们是作为 <code>go</code> 命令的一部分存在的。其中有一些工具我每天都在用，例如 <code>go fmt</code> 和 <code>go build</code>。而其他像 <code>go tool pprof</code> 这样的工具，则只在解决特定问题的时候会用到。但是无论如何，我很感激它们，让我的项目管理和维护变得更加容易。</p>
<p>在这篇文章中，我希望说明一些我认为最有用的工具的背景和使用场景。更重要的是，解释清楚可以如何将其用于典型项目的工作流程中。如果你刚接触 Go，那么，我希望这篇文章可以给你一个良好的开始。</p>
<p>或者，如果你已经使用 Go 一段时间了，那么你可能已经对这些东西很熟悉了，但是，我希望你仍旧可以从本文中发现一个从前不知道的命令或者标志 : )</p>
<p>本文基于 Go 1.12，并且假设你的项目已经 <a href="https://github.com/golang/go/wiki/Modules#quick-start">启用了 modules</a>。</p>
<h2 id="安装工具">安装工具</h2>
<p>在这篇文章中，我将主要关注作为 <code>go</code> 命令一部分的工具。但是，我还会提到那些不属于标准的 Go 1.12 版本的工具。</p>
<p>要在使用 Go 1.12 的情况下安装这些工具，首先，你需要确保当前位置_不在_启用 module 的目录下（通常，我会切到 <code>/tmp</code>）。然后，你就可以使用 <code>GO111MODULE=on go get</code> 命令来安装工具了。例如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ cd /tmp</span><br><span class="line">$ GO111MODULE=on go get golang.org<span class="regexp">/x/</span>tools<span class="regexp">/cmd/</span>stress</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的操作将会下载相关的包和依赖项，构建可执行文件，然后将其添加到你的 <code>GOBIN</code> 目录下。如果没有显式设置 <code>GOBIN</code> 目录，那么，可执行文件将会被添加到 <code>GOPATH/bin</code> 目录下。无论何种方式，都应该保证系统路径中有相应的目录。</p>
<p>注意：这个过程有点笨重，希望在未来的 Go 版本中有所改进。<a href="https://github.com/golang/go/issues/30515">Issue 30515</a> 正在跟踪关于这件事的讨论。</p>
<h2 id="查看环境信息">查看环境信息</h2>
<p>可以使用 <code>go env</code> 工具来展示当前 Go 操作环境的信息。当你正在使用不熟悉的机器的时候，这个命令尤为有用。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$ go env</span><br><span class="line">GOARCH=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">GOBIN=<span class="string">&quot;&quot;</span></span><br><span class="line">GOCACHE=<span class="string">&quot;/home/alex/.cache/go-build&quot;</span></span><br><span class="line">GOEXE=<span class="string">&quot;&quot;</span></span><br><span class="line">GOFLAGS=<span class="string">&quot;&quot;</span></span><br><span class="line">GOHOSTARCH=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">GOHOSTOS=<span class="string">&quot;linux&quot;</span></span><br><span class="line">GOOS=<span class="string">&quot;linux&quot;</span></span><br><span class="line">GOPATH=<span class="string">&quot;/home/alex/go&quot;</span></span><br><span class="line">GOPROXY=<span class="string">&quot;&quot;</span></span><br><span class="line">GORACE=<span class="string">&quot;&quot;</span></span><br><span class="line">GOROOT=<span class="string">&quot;/usr/local/go&quot;</span></span><br><span class="line">GOTMPDIR=<span class="string">&quot;&quot;</span></span><br><span class="line">GOTOOLDIR=<span class="string">&quot;/usr/local/go/pkg/tool/linux_amd64&quot;</span></span><br><span class="line">GCCGO=<span class="string">&quot;gccgo&quot;</span></span><br><span class="line">CC=<span class="string">&quot;gcc&quot;</span></span><br><span class="line">CXX=<span class="string">&quot;g++&quot;</span></span><br><span class="line">CGO_ENABLED=<span class="string">&quot;1&quot;</span></span><br><span class="line">GOMOD=<span class="string">&quot;&quot;</span></span><br><span class="line">CGO_CFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">CGO_CPPFLAGS=<span class="string">&quot;&quot;</span></span><br><span class="line">CGO_CXXFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">CGO_FFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">CGO_LDFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">PKG_CONFIG=<span class="string">&quot;pkg-config&quot;</span></span><br><span class="line">GOGCCFLAGS=<span class="string">&quot;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build245740092=/tmp/go-build -gno-record-gcc-switches&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你对特定值感兴趣，那么可以将其作为参数传给 <code>go env</code>。例如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ go env GOPATH GOOS GOARCH</span><br><span class="line"><span class="regexp">/home/</span>alex/go</span><br><span class="line">linux</span><br><span class="line">amd64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>想要显示所有 <code>go env</code> 变量和值的文档，可以运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">help</span> environment</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="开发">开发</h2>
<h3 id="运行代码">运行代码</h3>
<p>开发过程中，<code>go run</code> 工具是一种试用代码的便捷方式。它其实是一个快捷方式，用于一步编译代码，在 <code>/tmp</code> 目录下创建可执行的二进制文件，然后运行该二进制文件。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ go <span class="keyword">run</span><span class="bash"> .          <span class="comment"># Run the package in the current directory</span></span></span><br><span class="line">$ go <span class="keyword">run</span><span class="bash"> ./cmd/foo  <span class="comment"># Run the package in the ./cmd/foo directory</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：从 Go 1.11 起，你可以像上面一样，将 <a href="https://golang.org/doc/go1.11#run">一个包的路径</a> 传给 <code>go run</code>。这意味着，不再需要使用像 <code>go run *.go</code> 通配符扩展这样的变通方式，就能运行多个文件了。我超爱这项改进！</p>
<h3 id="获取依赖项">获取依赖项</h3>
<p>假设<a href="https://github.com/golang/go/wiki/Modules#quick-start">启用了 modules</a>，那么，当使用 <code>go run</code>（或者与此有关的 <code>go test</code> 或者 <code>go build</code>）时，任何外部依赖将会自动（递归）地下载，以满足代码中的 <code>import</code> 语句。默认情况下，会下载依赖项的最新标志版本。如果没有可用的标志版本，则会下载最新提交的。</p>
<p>如果事先知道需要特定版本的依赖项（而不是 Go 默认会获取的那个版本），那么可以在使用 <code>go get</code> 的时候带上相关的版本号或者提交哈希值。例如：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/foo/bar@v1.<span class="number">2.3</span></span><br><span class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/foo/bar@<span class="number">8</span>e1b8d3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果提取的依赖项带有 <code>go.mod</code> 文件，那么，<em>它的依赖项_将不会被列入_你的</em> <code>go.mod</code> 文件中。相反，如果你在下载的依赖项没有 <code>go.mod</code> 文件，那么，它的依赖项_将_被列入_你的_ <code>go.mod</code> 文件中，并且在其之下会有一个 <code>// indirect</code> 注释。</p>
<p>这意味着，你的 <code>go.mod</code> 文件不一定会在一个地方显示项目的所有依赖项。相反，可以像这样使用 <code>go list</code> 工具来查看所有依赖项：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> go list -m <span class="keyword">all</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有时，你可能会想知道_为什么它会是一个依赖项？_此时，可以使用 <code>go mod why</code> 命令来解惑。这个命令将显示从主模块中的包到给定依赖项的最短路径。例如：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">$ go mod why -m golang.org<span class="regexp">/x/</span>sys</span><br><span class="line"># golang.org<span class="regexp">/x/</span>sys</span><br><span class="line">github.com<span class="regexp">/alexedwards/</span>argon2id</span><br><span class="line">golang.org<span class="regexp">/x/</span>crypto/argon2</span><br><span class="line">golang.org<span class="regexp">/x/</span>sys/cpu</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：<code>go mod why</code> 命令将返回大多数（并非所有）依赖项之所以为依赖的原因。<a href="https://github.com/golang/go/issues/27900">Issue 27900</a> 正在跟踪此问题。</p>
<p>如果你对分析或者可视化应用的依赖项感兴趣，那么，你可能会想看看 <code>go mod graph</code> 工具。<a href="https://github.com/go-modules-by-example/index/tree/master/018_go_list_mod_graph_why">这里</a> 有一个很棒的生成可视化的教程和示例代码。</p>
<p>最后，下载下来的依赖项会保存在位于 <code>GOPATH/pkg/mod</code> 的_模块缓存_中。如果需要清除模块缓存，那么可以使用 <code>go clean</code> 工具。但是请注意：这个工具将会移除机器上_所有项目_的已下载依赖项。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>go clean -modcache</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="重构代码">重构代码</h3>
<p>可能你熟悉使用 <code>gofmt</code> 工具来自动格式化代码。但是，这个工具也支持_重写规则_，这样，就可以用它来重构代码了。我会证明给你看。</p>
<p>假设你有以下代码，然后你想将 <code>foo</code> 变量修改为 <code>Foo</code> 以便于将其导出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo = <span class="number">1</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了达到这个目的，可以这样使用 <code>gofmt</code> ：带上 <code>-r</code> 标志来实现一条重写规则，带上 <code>-d</code> 标志来显示变更的差异，并且带上 <code>-w</code> 标志来_就地_进行变更。就像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ gofmt -d -w -r <span class="string">&#x27;foo -&gt; Foo&#x27;</span> .</span><br><span class="line">-<span class="keyword">var</span> foo <span class="keyword">int</span></span><br><span class="line">+<span class="keyword">var</span> Foo <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">-	foo = <span class="number">1</span></span><br><span class="line">+	Foo = <span class="number">1</span></span><br><span class="line"> 	fmt.Println(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意到了吗？这是不是比查找替换更智能？ <code>foo</code> 变量已经更改，但是 <code>fmt.Println()</code> 语句中的 <code>"foo"</code> 字符串则保持不变。另外需要注意的是，<code>gofmt</code> 命令是以递归的方式工作的，因此，上面这条命令将操作当前目录和子目录中的所有 <code>*.go</code> 文件。</p>
<p>如果想要使用此功能，我推荐首先_不带_ <code>-w</code> 标志运行重写规则，然后先检查差异，以确保对代码所做的修改正如你所愿。</p>
<p>我们来看个稍微复杂点的例子。假设你想要更新代码以使用新的 Go 1.12 <a href="https://golang.org/pkg/strings/#ReplaceAll">strings.ReplaceAll()</a> 的函数来替代 <a href="https://golang.org/pkg/strings/#Replace">strings.Replace()</a>。要进行更改，可以这样运行：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">$ gofmt -w -r &#x27;strings.<span class="constructor">Replace(<span class="params">a</span>, <span class="params">b</span>, <span class="params">c</span>, -1)</span> -&gt; strings.<span class="constructor">ReplaceAll(<span class="params">a</span>, <span class="params">b</span>, <span class="params">c</span>)</span>&#x27; .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在重写规则里，单个小写字母会被用作匹配任意表达式的通配符，而这些表达式将会在替换过程中被替换。</p>
<h3 id="查看-go-文档">查看 Go 文档</h3>
<p>你可以通过在终端使用 <code>go doc</code> 工具，查看标准库包的文档。我经常在开发的时候使用这个工具来快速检查某些东西，例如某个特定函数的名字或者函数签名。我发现，这比浏览<a href="https://golang.org/pkg">基于 web 的文档</a> 更快，并且总是可以离线使用。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ go doc strings            # <span class="keyword">View</span> simplified documentation <span class="keyword">for</span> the strings package</span><br><span class="line">$ go doc -<span class="keyword">all</span> strings       # <span class="keyword">View</span> <span class="keyword">full</span> documentation <span class="keyword">for</span> the strings package</span><br><span class="line">$ go doc strings.Replace    # <span class="keyword">View</span> documentation <span class="keyword">for</span> the strings.Replace <span class="keyword">function</span></span><br><span class="line">$ go doc <span class="keyword">sql</span>.DB             # <span class="keyword">View</span> documentation <span class="keyword">for</span> the <span class="keyword">database</span>/<span class="keyword">sql</span>.DB <span class="keyword">type</span></span><br><span class="line">$ go doc <span class="keyword">sql</span>.DB.Query       # <span class="keyword">View</span> documentation <span class="keyword">for</span> the <span class="keyword">database</span>/<span class="keyword">sql</span>.DB.Query <span class="keyword">method</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还可以使用 <code>-src</code> 标志来展示相关的 Go 源代码。例如：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>go doc -src strings.Replace   <span class="comment"># View the source code for the strings.Replace function</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<h3 id="运行测试">运行测试</h3>
<p>可以像这样，使用 <code>go test</code> 工具来运行项目中的测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> .          <span class="comment"># Run all tests in the current directory</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> ./...      <span class="comment"># Run all tests in the current directory and sub-directories</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> ./foo/bar  <span class="comment"># Run all tests in the ./foo/bar directory</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通常，我会在启用 Go 的<a href="https://golang.org/doc/articles/race_detector.html">竞争检测器</a> 的情况下运行测试。这有助于帮助我找出在实际使用的过程中可能会出现的_一些_数据竞争。就像这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> -race ./...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>必须注意的是，启用竞争检测器将会增加测试的总体运行时间。所以，如果经常在 TDD 工作流程中运行测试，那么，你可能更愿意只在进行预提交测试的时候使用竞争检测器。</p>
<p>从 1.10 开始，Go 会<a href="https://golang.org/doc/go1.10#test">缓存包级别的测试结果</a>。如果在两次测试运行期间都没有发生改变，并且在使用 <code>go test</code> 时带了相同的可缓存标志，那么，就会展示缓存的测试结果，并且旁边会有一个 <code>"(cached)"</code>。对于大型代码库，这大大加速了测试运行时间。如果要强制运行所有测试（并避免缓存），那么，可以是有 <code>-count=1</code> 标志，或者通过使用 <code>go clean</code> 工具来清除所有缓存的测试结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> -count=1 ./...    <span class="comment"># Bypass the test cache when running tests</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go clean -testcache       <span class="comment"># Delete all cached test results</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：缓存的测试结果与缓存的构建结果一并存储在 <code>GOCACHE</code> 目录下。如果不确定它在你机器上的哪个位置，可以运行 <code>go env GOCACHE</code> 来检查。</p>
<p>可以通过使用 <code>-run</code> 标志来限制 <code>go test</code> 运行特定的测试（和自测试）。这个标志的参数是一个正则表达式，只有名字匹配到这个正则表达式的用例才会运行。我喜欢将它与 <code>-v</code> 标志（启用详细模式）结合使用，这样，就会显示运行中的测试和子测试的名字。这个一种很有用的方式，它确保了我没有写错这个正则表达式，并且期待运行的测试实际上确实在运行！</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ go test -v -<span class="keyword">run</span><span class="bash">=^TestFooBar$ .          <span class="comment"># Run the test with the exact name TestFooBar</span></span></span><br><span class="line">$ go test -v -<span class="keyword">run</span><span class="bash">=^TestFoo .              <span class="comment"># Run tests whose names start with TestFoo</span></span></span><br><span class="line">$ go test -v -<span class="keyword">run</span><span class="bash">=^TestFooBar$/^Baz$ .    <span class="comment"># Run the Baz subtest of the TestFooBar test only</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>值得注意的其他几个标志是 <code>-short</code>（用来<a href="https://golang.org/pkg/testing/#hdr-Skipping">跳过长时间运行的测试</a>）和 <code>-failfast</code>（在碰到第一个失败后会停止进一步的测试）。注意，<code>-failfast</code> 将不会缓存测试结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> -short ./...      <span class="comment"># Skip long running tests</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> -failfast ./...   <span class="comment"># Don&#x27;t run further tests after a failure.</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="分析测试覆盖率">分析测试覆盖率</h3>
<p>你可以在运行测试的时候，通过使用 <code>-cover</code> 标志来启用覆盖率分析。这将会输出每一个包的测试所覆盖的代码百分比，类似于：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ go test -cover ./...</span><br><span class="line">ok  	github.com<span class="regexp">/alexedwards/</span>argon2id	<span class="number">0.467</span>s	coverage: <span class="number">78.6</span>% of statements</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你还可以使用 <code>-coverprofile</code> 标志来生成一份_覆盖程序剖析文件_，然后像这样使用 <code>go tool cover -html</code> 命令，在 web 浏览器中查看：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ go test <span class="attribute">-coverprofile</span>=/tmp/profile.out ./<span class="built_in">..</span>.</span><br><span class="line">$ go<span class="built_in"> tool </span>cover <span class="attribute">-html</span>=/tmp/profile.out</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://www.alexedwards.net/static/images/tooling-1.png" /></p>
<p>这将为你提供所有测试文件的可导航列表，其中，测试覆盖到的代码显示为绿色，而没被覆盖到的则显示为红色。</p>
<p>如果想更进一步，可以设置 <code>-covermode=count</code> 标志，让覆盖程序剖析文件记录测试期间每个语句被执行的确切_次数_。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ go test <span class="attribute">-covermode</span>=count <span class="attribute">-coverprofile</span>=/tmp/profile.out ./<span class="built_in">..</span>.</span><br><span class="line">$ go<span class="built_in"> tool </span>cover <span class="attribute">-html</span>=/tmp/profile.out</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在浏览器中查看时，执行得更频繁的语句会以更饱和的绿色阴影显示，类似于：</p>
<p><img src="https://www.alexedwards.net/static/images/tooling-2.png" /></p>
<p>注意：如果测试中使用了 <code>t.Parallel()</code> 命令，那么，应该使用标志 <code>-covermode=atomic</code> 来替代 <code>-covermode=count</code>，以确保准确计数。</p>
<p>最后，如果没有可供查看覆盖剖析文件的 web 浏览器，那么，可以在终端使用如下命令，按函数或者方法，查看测试测试覆盖率的细分信息：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ go tool cover -<span class="keyword">func</span>=<span class="regexp">/tmp/</span>profile.out</span><br><span class="line">github.com<span class="regexp">/alexedwards/</span>argon2id/argon2id.go:<span class="number">77</span>:		CreateHash		<span class="number">87.5</span>%</span><br><span class="line">github.com<span class="regexp">/alexedwards/</span>argon2id/argon2id.go:<span class="number">96</span>:		ComparePasswordAndHash	<span class="number">85.7</span>%</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="压力测试">压力测试</h3>
<p>可以使用 <code>go test -count</code> 命令来连续多次运行一个测试。这在想要检查偶发或者间歇性失败的时候很有用。例如：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ go test <span class="attribute">-run</span>=^TestFooBar$ <span class="attribute">-count</span>=500 .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>TestFooBar</code> 测试将连续重复 500 次。但是，必须注意的是，测试将_串行_重复（即使它包含了 <code>t.Parallel()</code> 指令）。所以，如果你的测试在做一些相对较慢的事情，例如与数据库、硬盘或者互联网进行一次交互，那么，运行大量测试可能需要相当长的一段时间。</p>
<p>在这种情况下，你也许希望使用 <a href="golang.org/x/tools/cmd/stress"><code>stress</code></a> 工具来以_并行_的方式多次执行相同的用例。可以像这样安装它：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ cd /tmp</span><br><span class="line">$ GO111MODULE=on go get golang.org<span class="regexp">/x/</span>tools<span class="regexp">/cmd/</span>stress</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 <code>stress</code> 工具，首先需要为想要测试的特定包编译_测试二进制文件_。这可以使用 <code>go test -c</code> 命令来完成。例如，在当前目录下的包创建一个测试二进制文件：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">$ go test -c -o=<span class="regexp">/tmp/</span>foo.test .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，测试二进制文件将会输出为 <code>/tmp/foo.test</code>。稍后，你就可以像这样，使用 <code>stress</code> 工具来为这个测试二进制文件执行特定的测试了：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ stress -p=4 /tmp/foo.<span class="keyword">test</span> -<span class="keyword">test</span>.<span class="keyword">run</span>=^TestFooBar$</span><br><span class="line">60 runs <span class="keyword">so</span> far, 0 failures</span><br><span class="line">120 runs <span class="keyword">so</span> far, 0 failures</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：在上面的例子中，我用了 <code>-p</code> 标志来限制 <code>stress</code> 使用的并行进程的个数为 4。如果不带这个标志，该工具默认会使用个数为 <code>runtime.NumCPU()</code> 的进程。</p>
<h3 id="测试所有依赖">测试所有依赖</h3>
<p>在为发布或者部署可执行文件，或者是公开分发代码之前，你可能会想要运行 <code>go test all</code> 命令：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> go test <span class="keyword">all</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个命令将会对模块中的所有包和所有依赖项运行测试（包括测试_测试依赖_以及必要的_标准库包_）。并且它能够帮助验证所使用的依赖项的确切版本是否彼此兼容。这可能需要运行相当长的时间，但是，结果会得到缓存，因此，未来任何后续测试应该都会运行得比较快。如果需要的话，还可以使用 <code>go test -short all</code>，跳过任何长时间运行的测试。</p>
<h2 id="预提交检查">预提交检查</h2>
<h3 id="格式化代码">格式化代码</h3>
<p>Go 提供了两种工具来根据 Go 约定自动格式化代码：<code>gofmt</code> 和 <code>go fmt</code>。使用这些工具有助于让你的文件的项目中的代码保持一致。另外，如果在提交代码之前使用这些工具，那么就有助于在检查文件版本间差异的时候减少噪音。</p>
<p>我喜欢在使用 <code>gofmt</code> 工具的时候带以下标志：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>gofmt -w -s -d foo.go  <span class="comment"># 格式化 foo.go 文件</span></span><br><span class="line"><span class="variable">$ </span>gofmt -w -s -d .       <span class="comment"># 递归格式化当前目录和子目录下的所有文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这些命令中，<code>-w</code> 标志指示工具就地重写文件；<code>-s</code> 标志指示工具在可能的情况下<a href="https://golang.org/cmd/gofmt/#hdr-The_simplify_command">简化</a>代码；而 <code>-d</code> 标志指示工具输出改动的差异（因为我很好奇更改了啥）。如果你只是想要看看改动了哪些文件而不是具体差异，那么，可以将 <code>-d</code> 标志改为 <code>-l</code>。</p>
<p>注意：<code>gofmt</code> 命令以递归的方式工作。如果你给它传递一个目录，例如 <code>.</code> 或者 <code>./cmd/foo</code>，那么，它只会格式化这个目录下的所有 <code>.go</code> 文件。</p>
<p>另一个格式化工具 <code>go fmt</code> 是对 <code>gofmt</code> 的一个封装，它基本上等同于对指定的文件或者目录调用了 <code>gofmt -l -w</code>。你可以像这样使用它：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>go fmt ./...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="执行静态分析">执行静态分析</h3>
<p><code>go vet</code> 工具会对你的代码进行静态分析，然后对_可能_出现（编译器可能无法获取）的代码错误进行示警。像是无法访问的代码、不必要的赋值和错误格式的构建标记等问题。可以像这样使用它：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> vet foo.<span class="keyword">go</span>     # Vet the foo.<span class="keyword">go</span> <span class="keyword">file</span></span><br><span class="line">$ <span class="keyword">go</span> vet .          # Vet <span class="keyword">all</span> <span class="keyword">files</span> in the current directory</span><br><span class="line">$ <span class="keyword">go</span> vet ./...      # Vet <span class="keyword">all</span> <span class="keyword">files</span> in the current directory <span class="built_in">and</span> sub-directories</span><br><span class="line">$ <span class="keyword">go</span> vet ./foo/bar  # Vet <span class="keyword">all</span> <span class="keyword">files</span> in the ./foo/bar directory</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在背后，<code>go vet</code> 会运行一系列不同的分析器（<a href="https://golang.org/cmd/vet/">列在这里</a>）。你可以根据具体情况禁用特定的分析器。例如，你可以这样禁用 <code>composite</code> 分析器：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>go vet -composites=<span class="keyword">false</span> ./...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://godoc.org/golang.org/x/tools">golang.org/x/tools</a> 中有一些实验分析器，或许你会想要试一试：<a href="https://godoc.org/golang.org/x/tools/go/analysis/passes/nilness/cmd/nilness">nilness</a>（检查冗余或者不可能为 nil 的比较）和 <a href="https://godoc.org/golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow">shadow</a>（检查可能意外会出现的变量遮蔽）。如果想要使用它们，那么需要单独安装和运行这些工具。例如，要安装 <code>nilness</code> 工具，可以这样运行：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ cd /tmp</span><br><span class="line">$ GO111MODULE=on go get golang.org<span class="regexp">/x/</span>tools<span class="regexp">/go/</span>analysis<span class="regexp">/passes/</span>nilness<span class="regexp">/cmd/</span>nilness</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，就可以像这样使用它：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">$ go vet -vettool=<span class="constructor">$(<span class="params">which</span> <span class="params">nilness</span>)</span> ./...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：当使用了 <code>-vettool</code> 标志，<code>go vet</code> 将_只会_运行指定的分析器，这意味着将不会运行所有其他 <code>go vet</code> 分析器。</p>
<p>作为旁注，从 Go 1.10 开始，在运行任何测试之前，<code>go test</code> 工具将自动执行一个小的高可信的 <code>go vet</code> 测试子集。你可以在运行测试的时候关掉这种行为，就像这样：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$ go <span class="keyword">test</span> -vet=<span class="keyword">off</span> ./...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="linting-code">Linting Code</h3>
<p>可以使用 <code>golint</code> 工具来识别代码中的_样式错误_。和 <code>go vet</code> 不一样，它不关系代码的_正确性_，而是帮助你将代码与 <a href="https://golang.org/doc/effective_go.html">Effective Go</a> 和 Go <a href="https://golang.org/wiki/CodeReviewComments">CodeReviewComments</a> 中的样式约定对齐。</p>
<p>这个工具并不是标准库的一部分，因此，需要像这样安装它：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ cd /tmp</span><br><span class="line">$ <span class="attribute">GO111MODULE</span>=on go <span class="builtin-name">get</span> golang.org/x/lint/golint</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，就可以像下面一样运行它了：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>golint foo.go     <span class="comment"># Lint the foo.go file</span></span><br><span class="line"><span class="variable">$ </span>golint .          <span class="comment"># Lint all files in the current directory</span></span><br><span class="line"><span class="variable">$ </span>golint ./...      <span class="comment"># Lint all files in the current directory and sub-directories</span></span><br><span class="line"><span class="variable">$ </span>golint ./foo/bar  <span class="comment"># Lint all files in the ./foo/bar directory</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="整理和验证依赖关系">整理和验证依赖关系</h3>
<p>在提交代码任意改动之前，我建议你运行以下两个命令来整理和验证依赖项：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> go <span class="built_in">mod</span> tidy</span><br><span class="line"><span class="symbol">$</span> go <span class="built_in">mod</span> verify</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>go mod tidy</code> 命令将会修剪 <code>go.mod</code> 和 <code>go.sum</code> 文件中未使用的依赖项，然后更新文件，以包含用于所有可能的构建标签/操作系统/架构组合的依赖项（注意：<code>go run</code>、<code>go test</code>、<code>go build</code> 等都是“懒惰的”，它们只会获取当前构建标签/操作系统/架构所需的包）。在每次提交前运行这个命令，会让你更容易在查看版本控制历史时，确定哪些代码更改负责添加或者删除哪些依赖项。</p>
<p>我还推荐使用 <code>go mod verify</code> 命令来检查计算机上的依赖项自下载后没有被意外（或者故意）更改，并且它们匹配 <code>go.sum</code> 文件中的加密哈希值。运行此命令有助于确保所使用的依赖项确确实实是你所期望的，并且以后对该提交的任何构建都能重现。</p>
<h2 id="构建和部署">构建和部署</h2>
<h3 id="构建可执行文件">构建可执行文件</h3>
<p>你可以使用 <code>go build</code> 工具来编译 <code>main</code> 包，并创建一个可执行的二进制文件。通常，我会将其与 <code>-o</code> 标志结合使用，明确设置输出目录和二进制文件的名字，就像这样：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ go build -o=<span class="regexp">/tmp/</span>foo .            <span class="comment"># 在当前目录下编译包</span></span><br><span class="line">$ go build -o=<span class="regexp">/tmp/</span>foo .<span class="regexp">/cmd/</span>foo    <span class="comment"># 在 ./cmd/foo 目录下编译包</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这些示例中，<code>go build</code> 将会_编译_特定的包（和任何依赖包），然后调用_链接器_来生成一个可执行的二进制文件，并将其输出到 <code>/tmp/foo</code>。</p>
<p>值得注意的是，从 Go 1.10 开始，<code>go build</code> 工具会将构建输出缓存到_<a href="https://golang.org/cmd/go/#hdr-Build_and_test_caching">构建缓存</a>_中。这缓存的输出将在未来的构建中的适当时机重新使用。这就可以显著加快整体的构建时间。这种新的缓存行为意味着，“相比 <code>go build</code>，宁可 <code>go install</code>” 的“<a href="https://peter.bourgon.org/go-best-practices-2016/#build-and-deploy">古训</a>”不再适用。</p>
<p>如果不确定构建缓存位于何处，那么可以运行 <code>go env GOCACHE</code> 命令来检查：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ go env GOCACHE</span><br><span class="line"><span class="regexp">/home/</span>alex<span class="regexp">/.cache/g</span>o-build</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用构建缓存时需要<a href="https://golang.org/pkg/cmd/go/internal/help/">特别注意</a>：它并不会检查使用 <code>cgo</code> 导入的 C 库的改动。因此，如果你的代码通过 <code>cgo</code> 来导入一个 C 库，并且自上次构建后又对其进行了更改，那么需要使用 <code>-a</code> 标志来强制所有的包重新构建。或者，可以使用 <code>go clean</code> 来清除缓存：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>go build -a -o=<span class="regexp">/tmp/foo</span> .     <span class="comment"># 强制重新构建所有包</span></span><br><span class="line"><span class="variable">$ </span>go clean -cache               <span class="comment"># 清除构建缓存</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：运行 <code>go clean -cache</code> 将也会删除缓存的测试结果。</p>
<p>如果你对 <code>go build</code> 的幕后操作感兴趣，那么可能会想要使用以下命令：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>go list -deps . | sort -u     <span class="comment"># 列出所有用来构建可执行文件的包</span></span><br><span class="line"><span class="variable">$ </span>go build -a -x -o=<span class="regexp">/tmp/foo</span> .  <span class="comment"># 重构所有东西，并且显示所运行的命令</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，如果在非 <code>main</code> 包上运行 <code>go build</code> 命令，那么将会在临时位置编译这个包，并且结果将会被存储在构建缓存中。不会生成任何可执行文件。</p>
<h3 id="交叉编译">交叉编译</h3>
<p>这是我最喜欢的 Go 功能之一。</p>
<p>默认情况下，<code>go build</code> 将会输出一个适用于当前操作系统和架构的二进制文件。但它也支持交叉编译，这样，你就可以生成适合在不同机器上使用的二进制文件了。如果你在一个操作系统上开发，却在另一个操作系统上部署，那么这特别有用。</p>
<p>可以分别设置 <code>GOOS</code> 和 <code>GOARCH</code> 环境变量来指定希望为何种操作系统和架构创建二进制文件。例如：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ <span class="attribute">GOOS</span>=linux <span class="attribute">GOARCH</span>=amd64 go build <span class="attribute">-o</span>=/tmp/linux_amd64/foo .</span><br><span class="line">$ <span class="attribute">GOOS</span>=windows <span class="attribute">GOARCH</span>=amd64 go build <span class="attribute">-o</span>=/tmp/windows_amd64/foo.exe .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要查看所有支持的操作系统和架构组合列表，可以运行 <code>go tool dist list</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go tool dist list</span><br><span class="line">aix&#x2F;ppc64</span><br><span class="line">android&#x2F;386</span><br><span class="line">android&#x2F;amd64</span><br><span class="line">android&#x2F;arm</span><br><span class="line">android&#x2F;arm64</span><br><span class="line">darwin&#x2F;386</span><br><span class="line">darwin&#x2F;amd64</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>提示：可以使用 Go 的交叉编译来<a href="https://github.com/golang/go/wiki/WebAssembly">创建 WebAssembly 二进制文件</a>。</p>
<p>有关交叉编译的更深入的信息，推荐阅读<a href="https://rakyll.org/cross-compilation/">这篇优秀的博文</a>。</p>
<h3 id="使用编译器和链接器标志">使用编译器和链接器标志</h3>
<p>在构建自己的可执行文件时，可以使用 <code>-gcflags</code> 标志来更改编译器的行为，并查看执行的详细信息。可以通过运行以下命令，查看可用编译器标志的完整列表：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">go</span> tool <span class="built_in">compile</span> -help</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中一个你可能会感兴趣的标志是 <code>-m</code>，带上了这个标志会触发打印编译期间所进行的优化决策。可以这样使用它：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ go build -gcflags=<span class="string">&quot;-m -m&quot;</span> -o=<span class="regexp">/tmp/</span>foo . <span class="comment"># 输出优化决策信息</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我用了 <code>-m</code> 标志两次，表示我想要打印量级深度的决策信息。你可以通过使用一次来获得简单点的输出。</p>
<p>此外，从 Go 1.10 开始，编译器标志只适用于传给 <code>go build</code> 的指定包，在上面的例子中就是当前目录下的包（由 <code>.</code> 表示）。如果你想打印所有包的优化决策（包括依赖项），那么可以用这个命令替代：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ go build <span class="attribute">-gcflags</span>=<span class="string">&quot;all=-m&quot;</span> <span class="attribute">-o</span>=/tmp/foo .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从 Go 1.11 开始，你应该会发现比之前<a href="https://golang.org/doc/go1.11#debugging">更容易调试优化过的二进制文件</a>了。然而，如果有需要的话，仍然可以使用标志 <code>-N</code> 来禁用优化，使用 <code>-l</code> 来禁用内联。例如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ go build -gcflags=<span class="string">&quot;all=-N -l&quot;</span> -o=<span class="regexp">/tmp/</span>foo .  <span class="comment"># 禁用优化和内联</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以运行以下命令来查看可用的链接器标志列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go tool link -<span class="built_in">help</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，可能最有名的就是 <code>-X</code> 标志了，它允许你将一个（字符串）值“烧入”应用里指定的变量。这通常用于<a href="https://blog.alexellis.io/inject-build-time-vars-golang/">添加版本号或者提交哈希</a>。例如：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ go build <span class="attribute">-ldflags</span>=<span class="string">&quot;-X main.version=1.2.3&quot;</span> <span class="attribute">-o</span>=/tmp/foo .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更多关于 <code>-X</code> 标志和示例代码的信息，请参阅<a href="https://stackoverflow.com/questions/11354518/golang-application-auto-build-versioning">这个 StackOverflow 问题</a> 和本文以及<a href="https://blog.alexellis.io/inject-build-time-vars-golang/">这篇文章</a>。</p>
<p>你可能还有兴趣使用 <code>-s</code> 和 <code>-w</code> 标志来删除二进制文件中的调试信息。这通常会让生成的二进制文件减少 25% 的大小。例如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ go build -ldflags=<span class="string">&quot;-s -w&quot;</span> -o=<span class="regexp">/tmp/</span>foo .  <span class="comment"># 删除二进制文件中的调试信息</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：如果需要优化二进制文件大小，那么或许会想要使用 <a href="https://upx.github.io/">upx</a> 来压缩它。更多信息，请参阅<a href="https://blog.filippo.io/shrink-your-go-binaries-with-this-one-weird-trick/">这篇文章</a>。</p>
<h2 id="诊断问题和优化">诊断问题和优化</h2>
<h3 id="运行和比较基准">运行和比较基准</h3>
<p>Go 的一个很好的功能是，它让你可以轻松对代码进行基准测试。如果你不熟悉编写基准的一般过程，那么，<a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go">这里</a>和<a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go">这这里</a>有不错的指南。</p>
<p>要运行基准测试，你需要使用 <code>go test</code> 工具，并且将 <code>-bench</code> 标志设置为一个可以匹配你想要执行的基准测试的正则表达式。例如：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ go test <span class="attribute">-bench</span>=. ./<span class="built_in">..</span>.                        # 运行所有基准测试和基本测试</span><br><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=. ./<span class="built_in">..</span>.                # 运行所有基准测试（不运行基本测试）</span><br><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=^BenchmarkFoo$ ./<span class="built_in">..</span>.   # 只运行 BenchmarkFoo 这个基准测试（不运行基本测试）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我几乎总用 <code>-benchmem</code> 标志来运行基准测试，这会强制输出内存分配统计信息。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$  go test <span class="attribute">-bench</span>=. -benchmem ./<span class="built_in">..</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下，每个基准测试都会运行至少一秒，并且只运行一次。可以使用 <code>-benchtime</code> 和 <code>-count</code> 标志来更改此行为。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ go test <span class="attribute">-bench</span>=. <span class="attribute">-benchtime</span>=5s ./<span class="built_in">..</span>.       # 每个基准测试至少运行 5 秒</span><br><span class="line">$ go test <span class="attribute">-bench</span>=. <span class="attribute">-benchtime</span>=500x ./<span class="built_in">..</span>.     # 每个基准测试运行 500 次迭代</span><br><span class="line">$ go test <span class="attribute">-bench</span>=. <span class="attribute">-count</span>=3 ./<span class="built_in">..</span>.            # 每个基准测试重复 3 次</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果进行基准测试的代码使用了并发，那么，可以使用 <code>-cpu</code> 标志来查看更改 <code>GOMAXPROCS</code> 值对性能产生的影响（实际上，是可以同时执行 Go 代码的 OS 线程数）。例如，将 <code>GOMAXPROCS</code> 设置为 1，4 和 8，运行基准测试：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ go test <span class="attribute">-bench</span>=. <span class="attribute">-cpu</span>=1,4,8 ./<span class="built_in">..</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要比较基准测试之间的变动，你可能需要使用 <a href="https://godoc.org/golang.org/x/tools/cmd/benchcmp">benchcmp</a> 工具。这个工具不属于标准的 <code>go</code> 命令，所以需要像这样安装它：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ cd /tmp</span><br><span class="line">$ GO111MODULE=on go get golang.org<span class="regexp">/x/</span>tools<span class="regexp">/cmd/</span>benchcmp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，可以像这样使用它：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">$ go test -run=^$ -bench=. -benchmem .<span class="regexp">/... &gt; /</span>tmp/old.txt</span><br><span class="line"># make changes</span><br><span class="line">$ go test -run=^$ -bench=. -benchmem .<span class="regexp">/... &gt; /</span>tmp/<span class="keyword">new</span>.txt</span><br><span class="line">$ benchcmp <span class="regexp">/tmp/</span>old.txt <span class="regexp">/tmp/</span><span class="keyword">new</span>.txt</span><br><span class="line">benchmark              old ns<span class="regexp">/op     new ns/</span>op     delta</span><br><span class="line">BenchmarkExample-<span class="number">8</span>     <span class="number">21234</span>         <span class="number">5510</span>          -<span class="number">74.05</span>%</span><br><span class="line"></span><br><span class="line">benchmark              old allocs     <span class="keyword">new</span> allocs     delta</span><br><span class="line">BenchmarkExample-<span class="number">8</span>     <span class="number">17</span>             <span class="number">11</span>             -<span class="number">35.29</span>%</span><br><span class="line"></span><br><span class="line">benchmark              old bytes     <span class="keyword">new</span> bytes     delta</span><br><span class="line">BenchmarkExample-<span class="number">8</span>     <span class="number">8240</span>          <span class="number">3808</span>          -<span class="number">53.79</span>%</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="分析和跟踪">分析和跟踪</h3>
<p>Go 可以让你创建关于 CPU 使用、内存使用、goroutine 阻塞和互斥锁争用的诊断性_程序剖析文件_。你可以使用它们来深入挖掘应用，以确切了解应用是如何使用（或者等待）资源的。</p>
<p>有三种生成程序剖析文件的方法：</p>
<ul>
<li>如果是 web 应用，那么可以导入 <a href="https://golang.org/pkg/net/http/pprof/"><code>net/http/pprof</code></a> 包。这个操作将向 <code>http.DefaultServeMux</code> 注册一些处理函数。这样，你就可以为运行中的应用生成并下载程序剖析文件了。<a href="https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/">这篇文章</a> 对其进行了很好的解释，并且提供了一些示例代码。</li>
<li>对于其他类型的应用，则可以使用 <code>pprof.StartCPUProfile()</code> 和 <code>pprof.WriteHeapProfile()</code> 函数来生成运行中的程序剖析文件。<a href="https://golang.org/pkg/runtime/pprof/"><code>runtime/pprof</code></a> 文档中有一些示例代码可供参考。</li>
<li>或者，你可以在运行基准测试或者基础测试的时候生成程序剖析文件，只需像这样使用各种 <code>-***profile</code> 标志即可：</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=^BenchmarkFoo$ <span class="attribute">-cpuprofile</span>=/tmp/cpuprofile.out .</span><br><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=^BenchmarkFoo$ <span class="attribute">-memprofile</span>=/tmp/memprofile.out .</span><br><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=^BenchmarkFoo$ <span class="attribute">-blockprofile</span>=/tmp/blockprofile.out .</span><br><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=^BenchmarkFoo$ <span class="attribute">-mutexprofile</span>=/tmp/mutexprofile.out .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：运行基准测试或者基础测试的时候使用 <code>-***profile</code> 标志，当前目录下会生成一个测试二进制文件。如果你想将其输出到另一个地方，那么应该使用 <code>-o</code> 标志，就像这样：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=^BenchmarkFoo$ <span class="attribute">-o</span>=/tmp/foo.test <span class="attribute">-cpuprofile</span>=/tmp/cpuprofile.out .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>无论使用何种方式来生成程序剖析文件，当启用了程序剖析，Go 程序每秒将停止大约 100 次，并在停止的时刻创建程序快照。根据这些 <em>样本</em> 生成一份_程序剖析文件_，然后就可以使用 <code>pprof</code> 文件进行分析了。</p>
<p>我最喜欢的检查剖析文件的方式是，使用 <code>go tool pprof -http</code> 命令来将其在 web 浏览器中打开。例如：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ go<span class="built_in"> tool </span>pprof <span class="attribute">-http</span>=:5000 /tmp/cpuprofile.out</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://www.alexedwards.net/static/images/tooling-3.png" /></p>
<p>这个操作将会默认显示一个_图表_，展示了应用在采样情况下的执行树。这让你可以快速了解任何资源的使用“热点”。在上面的图中，我们可以看到，CPU 使用率方面的热点是来源于 <code>ioutil.ReadFile()</code> 的两个系统调用。</p>
<p>你还可以导航到剖析文件的其他_视图_，包括函数和源代码的最高使用情况。</p>
<p><img src="https://www.alexedwards.net/static/images/tooling-4.png" /></p>
<p>如果信息量太大，那么，或许你会想要使用 <code>--nodefraction</code> 标志，忽略小于样本一定百分比的节点。例如，要忽略那些少于样本 10% 的节点，可以这样运行 <code>pprof</code>：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ go<span class="built_in"> tool </span>pprof <span class="attribute">--nodefraction</span>=0.1 <span class="attribute">-http</span>=:5000 /tmp/cpuprofile.out</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://www.alexedwards.net/static/images/tooling-5.png" /></p>
<p>这会让生成的图不那么“嘈杂”。此时，如果<a href="https://www.alexedwards.net/static/images/tooling-5b.svg">放大这张屏幕截图</a>，那么就可以更清楚地看到并了解 CPU 使用热点在哪里。</p>
<p>分析和优化资源使用是一项大但是细微的主题，而这里我只涉及皮毛。如果你对此感兴趣，并想了解更多，那么建议你阅读以下文章：</p>
<ul>
<li><a href="https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/">分析和优化 Go web 应用</a></li>
<li><a href="https://github.com/golang/go/wiki/Performance">调试 Go 程序中的性能问题</a></li>
<li><a href="https://medium.com/@hackintoshrao/daily-code-optimization-using-benchmarks-and-profiling-in-golang-gophercon-india-2016-talk-874c8b4dc3c5">使用基准测试和程序剖析进行日常代码优化</a></li>
<li><a href="https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/">使用 pprof 分析 Go 程序</a></li>
</ul>
<p>另一个可以用来协助诊断问题的工具是_运行时执行跟踪器_。它可以让你了解 Go 是如何创建和调度 goroutine 运行的，垃圾收集器何时运行，以及关于阻塞系统调用/网络/sync 操作的信息。</p>
<p>同样的，你也可以从基础测试和基准测试中生成跟踪文件，或者使用 <code>net/http/pprof</code> 来创建并下载应用的跟踪文件。然后，就可以使用 <code>go tool trace</code>，像这样在 web 浏览器中查看输出了：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=^BenchmarkFoo$ <span class="attribute">-trace</span>=/tmp/trace.out .</span><br><span class="line">$ go<span class="built_in"> tool </span>trace /tmp/trace.out</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重要提示：目前，只能在 Chrome 或者 Chromium 中查看。</p>
<p><img src="https://www.alexedwards.net/static/images/tooling-6.png" /></p>
<p>关于 Go 的执行跟踪器以及如何解释输出的更多信息，请看 <a href="https://www.youtube.com/watch?v=mmqDlbWk_XA">Rhys Hiltner 的 dotGo 2016 演讲</a> 和这篇<a href="https://making.pusher.com/go-tool-trace/">优秀的博客</a>。</p>
<h3 id="检查竞争条件">检查竞争条件</h3>
<p>我前面谈过使用 <code>go test -race</code>，在测试过程中启用 Go 的竞争检测器。但是，你也可以在构建可执行文件的过程中，为运行中的程序启用它，就像这样：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">$ go build -race -o=<span class="regexp">/tmp/</span>foo .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>非常值得注意的是，启用了竞争检测器的二进制文件将比正常情况下使用更多的 CPU 和内存。因此，在正常情况下，构建用于生产环境的二进制文件时，不应该使用 <code>-race</code> 标志。</p>
<p>但是，你可能希望在服务器池中的某台服务器上面部署启用了竞争检测器的二进制文件。或者用它来跟踪可疑的竞争条件，方法是使用负载测试工具，对启用了竞争检测器的二进制文件并发施压。</p>
<p>默认情况下，在二进制文件运行过程中，如果检测到了竞争，那么会对 <code>stderr</code> 写入一条日志。如果必要，你可以通过使用 <code>GORACE</code> 环境变量来改变这种行为。例如，要运行位于 <code>/tmp/foo</code> 的二进制文件，并将竞争日志写到 <code>/tmp/race.&lt;pid&gt;</code>，则可以这样：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ GORACE=<span class="string">&quot;log_path=/tmp/race&quot;</span> <span class="regexp">/tmp/</span>foo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="管理依赖关系">管理依赖关系</h2>
<p>可以使用 <code>go list</code> 工具来检查指定的依赖项是否有更新版本，如下所示：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ go list -m -u github.com<span class="regexp">/alecthomas/</span>chroma</span><br><span class="line">github.com<span class="regexp">/alecthomas/</span>chroma v0.<span class="number">6.2</span> [v0.<span class="number">6.3</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这将输出当前使用的依赖项的名字和版本，如果存在较新的版本，那么后面会跟着方括号 <code>[]</code>，里面是最新的版本。还可以使用 <code>go list</code> 来检查所有依赖项（和子依赖项）的更新。如下所示：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> go list -m -u <span class="keyword">all</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以升级（或者降级）一个依赖项至最新的版本，只需像这样在 <code>go get</code> 命令后指定发布标记或者提交哈希即可：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/foo/bar@latest</span><br><span class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/foo/bar@v1.<span class="number">2.3</span></span><br><span class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/foo/bar@<span class="number">7</span>e0369f</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你正在更新的依赖项带有 <code>go.mod</code> 文件，那么，根据这份 <code>go.mod</code> 文件的信息，如果有需要的话，还将下载_子依赖项_的更新。如果使用 <code>go get -u</code> 标志，那么将忽略 <code>go.mod</code> 文件的内容，然后所有子依赖项将会被升级至最新的次要或者补丁版本（即使 <code>go.mod</code> 指定了不同的版本。）。</p>
<p>升级或者降级任何依赖项后，最好整理你的 mod 文件。可能你还会希望运行所有包的测试，从而检查兼容性。就像这样：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> go <span class="built_in">mod</span> tidy</span><br><span class="line"><span class="symbol">$</span> go test <span class="keyword">all</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有时，你可能想使用本地版本的依赖项（例如，在上游合并补丁之前，需要使用本地分支）。为此，可以使用 <code>go mod edit</code> 命令，将 <code>go.mod</code> 文件中的依赖项替代为本地版本。例如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ go mod edit -replace=github.com<span class="regexp">/alexedwards/</span>argon2id=<span class="regexp">/home/</span>alex<span class="regexp">/code/</span>argon2id</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这将像这样为你的 <code>go.mod</code> 文件添加一个_替代规则_。然后。未来的 <code>go run</code> 和 <code>go build</code> 等操作将会使用本地版本。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>File: go.mod</span><br><span class="line">    module alexedwards.net/example</span><br><span class="line">    </span><br><span class="line">    go <span class="number">1.12</span></span><br><span class="line">    </span><br><span class="line">    require github.com<span class="regexp">/alexedwards/</span>argon2id v0.<span class="number">0.0</span>-<span class="number">20190109181859</span>-<span class="number">24206601</span>af6c</span><br><span class="line">    </span><br><span class="line">    replace github.com<span class="regexp">/alexedwards/</span>argon2id =&gt; <span class="regexp">/home/</span>alex<span class="regexp">/Projects/</span>playground/argon2id</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>一旦不需要本地版本了，就可以用下面这个命令来移除替换规则：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ go mod <span class="builtin-name">edit</span> <span class="attribute">-dropreplace</span>=github.com/alexedwards/argon2id</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以使用<a href="https://github.com/golang/go/wiki/Modules#can-i-work-entirely-outside-of-vcs-on-my-local-filesystem">同样的技巧</a>来导入_只_存在于你自己文件系统上的包。如果你同时处理开发中的多个模块，其中一个模块依赖另一个模块，那么这将会很有用。</p>
<p>注意：如果不想使用 <code>go mod edit</code> 命令，可以手动编辑 <code>go.mod</code> 文件来进行修改。无论哪种方式都能行得通。</p>
<h2 id="升级到新版本">升级到新版本</h2>
<p><code>go fix</code> 文件最初于 2011 年发布（当时对于 Go 的 API 仍有定期修改），用以帮助用户自动更新旧代码至与 Go 的新版本兼容。从此，Go 的<a href="https://golang.org/doc/go1compat">兼容性承诺</a>意味着，如果你从一个 Go 1.x 版本升级至更新的 1.x 版本，那么将一切正常，故而通常没有必要使用 <code>go fix</code>。</p>
<p>但是，它确实处理了一些非常具体的问题。可以运行 <code>go tool fix -help</code> 来查看这些问题的摘要。如果你决定升级之后想要或者需要运行 <code>go fix</code>，那么应该运行以下命令，然后在提交前检查更改的差异。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">go</span> <span class="built_in">fix</span> ./...</span><br></pre></td></tr></table></figure>
<h2 id="报告错误">报告错误</h2>
<p>如果你确信找到了 Go 的标注库、工具或者文档中未报告的错误，那么可以使用 <code>go bug</code> 命令来创建一个新的 Github issue。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>go bug</span><br></pre></td></tr></table></figure>
<p>这个命令将会打开一个浏览器窗口，其中打开了 issue 页面，并且与填充了系统信息和报告模板。</p>
<h2 id="备忘">备忘</h2>
<p><em>2019-04-19 更新：<span class="citation" data-cites="FedirFR">[@FedirFR]</span>(https://twitter.com/FedirFR) 根据这篇文章制作了一份备忘。你可以<a href="https://github.com/fedir/go-tooling-cheat-sheet/blob/master/go-tooling-cheat-sheet.pdf">在这里下载</a>.</em></p>
<p><a href="https://github.com/fedir/go-tooling-cheat-sheet/blob/master/go-tooling-cheat-sheet.pdf"><img src="https://www.alexedwards.net/static/images/tooling-7.png" /></a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
</search>
