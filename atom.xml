<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>∞</title>
  
  <subtitle>好好学习，天天向上</subtitle>
  <link href="http://ictar.github.io/atom.xml" rel="self"/>
  
  <link href="http://ictar.github.io/"/>
  <updated>2021-01-26T12:43:51.527Z</updated>
  <id>http://ictar.github.io/</id>
  
  <author>
    <name>Ele</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GDA | 有关最小二乘估计的一些事</title>
    <link href="http://ictar.github.io/2021/01/26/gda-least-squares-adjustment/"/>
    <id>http://ictar.github.io/2021/01/26/gda-least-squares-adjustment/</id>
    <published>2021-01-26T03:54:56.000Z</published>
    <updated>2021-01-26T12:43:51.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述">问题描述</h1><p>假设我们有一组观测值： <span class="math display">\[\underline{y_0} = \begin{bmatrix}y_{01}\\...\\y_{0i}\\...\\y_{0m}\end{bmatrix}  \in  \mathbb{R}^m\]</span> 观测值之间相互独立。</p><p>我们想从中估算出一组未知参数： <span class="math display">\[\underline{x} = \begin{bmatrix}x_1\\...\\x_i\\...\\x_n\end{bmatrix}  \in  \mathbb{R}^n \quad (n \le m \text{ for redundancy})\]</span></p><h1 id="最小二乘估计least-squares-estimation">最小二乘估计（Least Squares Estimation）</h1><blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>最小二乘法，又称最小平方法，是一种数学优化建模方法。它通过最小化误差的平方和寻找数据的最佳函数匹配。 利用最小二乘法可以简便的求得未知的数据，并使得求得的数据与实际数据之间误差的平方和为最小。 “最小二乘法”是对线性方程组，即方程个数比未知数更多的方程组，以回归分析求得近似解的标准方法。</p><p>—— 维基百科</p>            <i class="fa fa-quote-right"></i>          </blockquote><h2 id="数据模型">数据模型</h2><p>假设 <span class="math inline">\(\underline{y_0}\)</span> 是 <span class="math inline">\(\underline{y}\)</span> 的一组观测值，而 <span class="math inline">\(\underline{y}\)</span> 和 <span class="math inline">\(\underline{x}\)</span> 之间为线性关系： <span class="math display">\[\begin{aligned}\underline{y} = A\underline{x}+\underline{b} \\\text{其中, } A: \text{ design matrix} \quad \underline{b}: \text{ known term}\end{aligned}\]</span></p><p>假设 <span class="math inline">\(\underline{y_0}\)</span> 和 <span class="math inline">\(\underline{y}\)</span> 之间存在误差 <span class="math inline">\(\underline{\varepsilon}\)</span>，即： <span class="math display">\[\begin{aligned}\underline{y_0} = \underline{y} + \underline{\varepsilon} = A\underline{x}+\underline{b} + \underline{\varepsilon}\\\text{其中, }\underline{\varepsilon}: \text{ unknown error} \\\end{aligned}\]</span></p><p>根据<a href="https://zh.wikipedia.org/zh-hans/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86">中心极限定理</a>以及<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B">大数定理</a>，假设： <span class="math display">\[\begin{aligned}\underline{\varepsilon}   \backsim N(0, \sigma_0^2Q) \\\text{其中, } \sigma_0^2: \text{a prior variance} \quad Q: \text{ cofactor matrix} \end{aligned}\]</span></p><p>因此，问题转换为，求得 <span class="math inline">\(\hat{\underline{x}}\)</span> 和 <span class="math inline">\(\hat{\underline{y}}\)</span>，使其满足：</p><p><span class="math display">\[\begin{aligned}\left\{\begin{matrix}\hat{\underline{y}}=A\hat{\underline{x}}+\underline{b}\\ \hat{\underline{y}} \textbf{ at minimal distance from } \underline{y_0} \Rightarrow (\hat{\underline{y}}-\underline{y_0})^TQ^{-1}(\hat{\underline{y}}-\underline{y_0}): minimum \quad (\text{stochastic distance})\end{matrix}\right.\end{aligned}\]</span></p><h3 id="非线性场景">非线性场景</h3><p>如果 <span class="math inline">\(\underline{y}\)</span> 和 <span class="math inline">\(\underline{x}\)</span> 之间为非线性关系，即 <span class="math inline">\(y = g(x)\)</span>，则首先，我们要将其线性化：</p><ol type="1"><li>通过求解观测值等式来获取未知参数的近似值 <span class="math inline">\(\underline{\widetilde{x}}\)</span></li><li>计算雅可比矩阵(Jacobian Matrix)： <span class="math display">\[J(\widetilde{x}) = \begin{bmatrix}\frac{\partial g_1}{\partial x_1} &amp; \frac{\partial g_1}{\partial x_2} &amp; ... &amp; \frac{\partial g_1}{\partial x_n}\\ \frac{\partial g_2}{\partial x_1} &amp; \frac{\partial g_2}{\partial x_2} &amp; ... &amp; \frac{\partial g_2}{\partial x_n}\\ ... &amp; ... &amp; ... &amp; ...\\ \frac{\partial g_m}{\partial x_1} &amp; \frac{\partial g_m}{\partial x_2} &amp; ... &amp; \frac{\partial g_m}{\partial x_n}\end{bmatrix}_{\underline{\widetilde{x}}} \\\]</span></li><li>模型转换成： <span class="math display">\[\begin{aligned}y_0 = f(\widetilde{x}) + J(\widetilde{x})(x-\widetilde{x}) \\\text{其中， } A = J, b = f(\widetilde{x})\end{aligned}\]</span></li></ol><h2 id="求解">求解</h2><blockquote><p>说明：求最小值问题可以转换为求一阶导数为 0 的问题。这里省略推导过程，直接给出计算步骤.</p></blockquote><ol type="1"><li>计算正规矩阵（Normal Matrix）：<span class="math inline">\(N = A^TQ^{-1}A\)</span></li><li>计算正规已知项（Normal Known Term）：<span class="math inline">\(\underline{t} = A^TQ^{-1}(\underline{y}_0 - \underline{b})\)</span></li><li>计算未知参数的估算解： <span class="math display">\[N\hat{\underline{x}} = A^TQ^{-1}A\hat{\underline{x}} = A^TQ^{-1}(\underline{y}_0 - \underline{b}) = \underline{t} \quad \Rightarrow \quad \underline{\hat{x}} = N^{-1}\underline{t} = N^{-1}A^TQ^{-1}(\underline{y}_0 - \underline{b}) \qquad (\text{the normal system})\]</span></li><li>计算观测值的估算值：<span class="math inline">\(\underline{\hat{y}} = A\underline{\hat{x}} + \underline{b}\)</span></li><li>计算误差的估算值：<span class="math inline">\(\underline{\hat{\varepsilon}} = \underline{y}_0 - \underline{\hat{y}}\)</span></li></ol><blockquote><p>注意： 1. <span class="math inline">\(N\)</span> 必须是可逆的，这就要求 <span class="math inline">\(A\)</span> 满秩 ## 精确度估算 ### 方差 上一步中，我们得到了误差的估算值，因此可以计算后验方差（posterior variance）： <span class="math display">\[\hat{\sigma}^2 = \frac{\underline{\hat{\varepsilon}}^TQ^{-1}\underline{\hat{\varepsilon}}}{m-n}\]</span></p></blockquote><h3 id="协方差">协方差</h3><p>根据 <a href="https://en.wikipedia.org/wiki/Propagation_of_uncertainty">协方差传播（covariance propagation）</a>：</p><p><span class="math display">\[\begin{aligned}\textbf{在线性的场景下：} y = Ax+b \\\text{则 }\left\{\begin{matrix}\text{均值 } \mu_y = A\mu_x + b  \\\text{协方差 } C_{yy} = AC_{xx}A^T\end{matrix}\right.\\\quad \\\textbf{在非线性的场景下：} y = g(x) \\\text{则 }\left\{\begin{matrix}\text{均值 } \mu_y \cong g(\mu_x) \\\text{协方差 } C_{yy} = JC_{xx}J^T\end{matrix}\right.\\\end{aligned}\]</span></p><p>因此观测值的协方差为： <span class="math display">\[\begin{aligned}C_{y0y0} = IC_{\varepsilon\varepsilon}I^T = C_{\varepsilon\varepsilon} = \sigma_0^2Q\end{aligned}\]</span></p><p>由于前面已经得出一个后验方差，因此，上面又可以写成： <span class="math display">\[\begin{aligned}C_{y0y0} = \hat{\sigma}^2Q\end{aligned}\]</span></p><h4 id="未知参数的估算解的协方差">未知参数的估算解的协方差</h4><p><span class="math display">\[\begin{aligned}\because \underline{\hat{x}} = N^{-1}A^TQ^{-1}(\underline{y}_0 - \underline{b}) \\\therefore C_{\hat{x}\hat{x}} = N^{-1}A^TQ^{-1}C_{y_0y_0}(N^{-1}A^TQ^{-1})^T \\= N^{-1}A^TQ^{-1}\hat{\sigma}^2Q(N^{-1}A^TQ^{-1})^T \\= \hat{\sigma}^2N^{-1}\end{aligned}\]</span></p><h4 id="观测值的估算值的协方差">观测值的估算值的协方差</h4><p><span class="math display">\[\begin{aligned}\because \underline{\hat{y}} = A\underline{\hat{x}} + \underline{b} \\\therefore C_{\hat{y}\hat{y}} = AC_{\hat{x}\hat{x}}A^T  \\= A\hat{\sigma}^2N^{-1}A^T\end{aligned}\]</span></p><h4 id="误差的估算值的协方差">误差的估算值的协方差</h4><p><span class="math display">\[\begin{aligned}\because \underline{\hat{\varepsilon}} = \underline{y}_0 - \underline{\hat{y}} \\\therefore C_{\hat{\varepsilon}\hat{\varepsilon}} = C_{y0y0} -  C_{\hat{y}\hat{y}} \\= \hat{\sigma}^2Q - A\hat{\sigma}^2N^{-1}A^T \\= \hat{\sigma}^2(Q-AN^{-1}A^T)\end{aligned}\]</span></p><h2 id="置信度评估">置信度评估</h2><h3 id="全局测试">全局测试</h3><ol type="1"><li>做出假设 <span class="math display">\[H_0: \hat{\sigma}^2=\sigma^2\]</span></li><li>计算：<span class="math inline">\(\frac{\hat{\sigma}^2}{\sigma^2}(m-n)\backsim\chi^2_{exp}\)</span></li><li>查询卡方分布表：<span class="math inline">\(\chi^2_{lim}=\chi^2_{(m-n)}(\alpha)\)</span></li><li>如果 <span class="math inline">\(\chi^2_{exp}\le\chi^2_{lim}\)</span>，则接受假设；如果 <span class="math inline">\(\chi^2_{exp}\gt\chi^2_{lim}\)</span>，则拒绝假设。</li></ol><h3 id="局部测试">局部测试</h3><p>用以识别异常值（outliers）。</p><ol type="1"><li>做出假设 <span class="math display">\[\frac{\hat{\varepsilon_i}}{\sigma_{\varepsilon_i}} = \tau_{exp} \sim \tau_{(m-n)}\]</span></li><li>计算 <span class="math inline">\(\tau_{exp}\)</span>，其中 <span class="math inline">\(\sigma_{\varepsilon_i}=\hat{\sigma}\sqrt{C_{\hat{\varepsilon}\hat{\varepsilon}}(i,i)}\)</span></li><li>查询 T 分布表：<span class="math inline">\(\tau_{lim}=\tau_{(m-n)}(\frac{\alpha}{2})\)</span></li><li>如果 <span class="math inline">\(|\tau_{exp}|\le\tau^2_{lim}\)</span>，则接受假设；如果 <span class="math inline">\(|\tau_{exp}|\gt\tau^2_{lim}\)</span>，则拒绝假设。</li><li>不满足假设的观测值即为异常者。将其移除后，重复整个过程。</li></ol>]]></content>
    
    
    <summary type="html">问题描述
假设我们有一组观测值： \[ \underline{y_0} = \begin{bmatrix}y_{01}\\...\\y_{0i}\\...\\y_{0m}\end{bmatrix} \in \mathbb{R}^m \] 观测值之间相互独立。

我们想从中估算出一组未知参数： \[ \underline{x} = \begin{bmatrix}x_1\\...\\x_i\\...\\x_n\end{bmatrix} \in \mathbb{R}^n \quad (n \le m \text{ for redundancy}) \]

最小二乘估计（Least Squares E</summary>
    
    
    
    <category term="GIS" scheme="http://ictar.github.io/categories/GIS/"/>
    
    
    <category term="GDA" scheme="http://ictar.github.io/tags/GDA/"/>
    
    <category term="GIS" scheme="http://ictar.github.io/tags/GIS/"/>
    
  </entry>
  
  <entry>
    <title>GDA | 随机预测（Stochastic Prediction）</title>
    <link href="http://ictar.github.io/2020/12/25/gda-stochastic-prediction/"/>
    <id>http://ictar.github.io/2020/12/25/gda-stochastic-prediction/</id>
    <published>2020-12-25T02:57:50.000Z</published>
    <updated>2021-01-26T03:04:38.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据模拟">数据模拟</h2><p>模拟一个信号 \( S(\underline{t}_N, \overline{w})\)，其中，\(\underline{t}_N \) 是一个规律性分布的点的集合，点集大小为 \(N\)。 <span class="math display">\[\begin{equation}\underline{t}_N = \begin{bmatrix}0\\ 1\\ ...\\ N-1\end{bmatrix}\end{equation}\]</span> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sample size</span></span><br><span class="line">N = <span class="number">1000</span></span><br><span class="line"><span class="comment"># observation epochs (we assume to sample the signal on a regular basis</span></span><br><span class="line">t = np.arange(<span class="number">0</span>, N, <span class="number">1</span>).reshape((N, <span class="number">1</span>)) <span class="comment"># a column vector</span></span><br></pre></td></tr></table></figure> 假设该信号平稳（stationary），则该信号的协方差函数为（指数模型 ）： <span class="math display">\[\begin{equation}C_S(|t-t&#39;|) = A_0e^{(-\alpha_0|t-t&#39;|)}\end{equation}\]</span></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># signal covariance model</span></span><br><span class="line"><span class="comment"># variance of the random signal</span></span><br><span class="line">A0 = <span class="number">9</span></span><br><span class="line"><span class="comment"># decay speed of the covariance model</span></span><br><span class="line">a0 = <span class="number">1</span>/<span class="number">100</span></span><br><span class="line"><span class="comment"># exponential model</span></span><br><span class="line">cf = A0 * np.exp(-a0*t) <span class="comment"># a column vector</span></span><br></pre></td></tr></table></figure><p>对应的协方差矩阵为: <span class="math display">\[\begin{equation}\begin{aligned}C_{S_{N\times N}} &amp;= \begin{bmatrix}C_S(0) &amp; C_S(1) &amp; C_S(2) &amp; ... &amp; C_S(N-1) \\ C_S(1) &amp; C_S(0) &amp; C_S(1) &amp; ... &amp; C_S(N-2) \\  ... \\ C_S(N-1) &amp; C_S(N-2) &amp; C_S(N-3) &amp; ... &amp; C_S(0)\end{bmatrix} \\&amp;= \begin{bmatrix} A_0 &amp; A_0e^{-\alpha_0\times 1} &amp; A_0e^{-\alpha_0\times 2} &amp; ... &amp; A_0e^{-\alpha_0\times (N-1))} \\  A_0e^{-\alpha_0\times 1} &amp; A_0 &amp; A_0e^{-\alpha_0\times 1} &amp; ... &amp; A_0e^{-\alpha_0\times (N-2))} \\  ... \\ A_0e^{-\alpha_0\times (N-1))} &amp; A_0e^{-\alpha_0\times (N-2))} &amp; A_0e^{-\alpha_0\times (N-2))} &amp; ... &amp; A_0\end{bmatrix}\end{aligned}\end{equation}\]</span></p><p>由于数据规律性分布（\(\triangle = 1\)），因此，其协方差矩阵是 T 型矩阵。</p><blockquote><p>T型矩阵（Toeplitz matrix）：主对角线上的元素相等，平行于主对角线的线上的元素也相等；矩阵中的各元素关于次对角线对称，即T型矩阵为次对称矩阵。</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.linalg <span class="keyword">import</span> toeplitz</span><br><span class="line"><span class="comment"># covariance matrix of the given N-dimensional sample variable </span></span><br><span class="line">C = toeplitz(cf)</span><br></pre></td></tr></table></figure><p>将协方差矩阵进行 Cholesky 分解：\(C_S = L\times L^+ \)</p><blockquote><p>Cholesky 分解：把一个对称正定的矩阵表示成一个下三角矩阵 L 和其转置的乘积的分解。它要求矩阵的所有特征值必须大于零，故分解的下三角的对角元也是大于零的。</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cholesky decomposition C=LxL&#x27; (L=lower triangular matrix)</span></span><br><span class="line">L = np.linalg.cholesky(C)</span><br></pre></td></tr></table></figure><p>假设 \(\underline{X}_N\) 是一个满足正态分布的随机变量，具有以下性质： <span class="math display">\[\begin{equation}\begin{aligned}E\{\underline{X}_N\} &amp;= 0 \\C_{\underline{X}\underline{X}} &amp;= I\end{aligned}\end{equation}\]</span></p><p>令随机变量 \( S(\underline{t}_N, w)\) 为 \(\underline{X}_N\) 的一个线性变换： <span class="math display">\[\begin{equation}S(\underline{t}_N, w) = L\times \underline{X}_N\end{equation}\]</span> 则其具有以下性质： <span class="math display">\[\begin{equation}\begin{aligned}E\{S(\underline{t}_N, w)\} &amp;= L\times E\{\underline{X}_N\} \\&amp;= \underline{0} \\C_{SS} &amp;= L\times C_{\underline{X}\underline{X}}\times L^{+} \\&amp;= L\times L^{+} (\text{满足上面的 Cholesky 分解})\end{aligned}\end{equation}\]</span></p><p>故而模拟的信号可以由以下等式给出： <span class="math display">\[\begin{equation}S(\underline{t}_N) = L\times {\underline{x}_N}^{0}\end{equation}\]</span></p><p>其中，\({\underline{x}_N}^{0}\) 是 \(\underline{X}_N\) 的一个样本</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># signal sampling simulation </span></span><br><span class="line">y = L.dot(np.random.randn(N, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>增加随机白噪声（random white-noise）\(\underline{v}\)，其方差为 \(\sigma_v^2\)。 <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># noise standard deviation 40% of signal</span></span><br><span class="line">sigma_v = <span class="number">0.4</span> * np.sqrt(cf[<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="comment"># white noise generation (normal white noise)</span></span><br><span class="line">v = sigma_v * np.random.randn(N,<span class="number">1</span>)</span><br></pre></td></tr></table></figure> 该白噪声与信号不相关（Uncorrelated）。</p><p>因此，最终模拟的数据为： <span class="math display">\[\begin{equation}\underline{y}_0 = S(\underline{t}_N) + \underline{v}\end{equation}\]</span></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># observations (sampled signal + white noise</span></span><br><span class="line">y0 = y + v</span><br></pre></td></tr></table></figure><p>绘图查看： <img src="/img/gda_20201225-224446.jpg" /></p><h2 id="估测经验协方差函数estimation-of-the-ecf">估测经验协方差函数（ESTIMATION OF THE ECF）</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># observation mean removal</span></span><br><span class="line">y0_m = y0 - np.mean(y0)</span><br><span class="line"><span class="comment"># max length for ecf evaluation</span></span><br><span class="line">N2 = <span class="built_in">int</span>(N/<span class="number">2</span>)</span><br><span class="line"><span class="comment"># ecf: xcorr(y0_m, N2)</span></span><br><span class="line">ecf = np.correlate(y0_m.T[<span class="number">0</span>], y0_m.T[<span class="number">0</span>], mode=<span class="string">&quot;full&quot;</span>)[<span class="built_in">len</span>(y0_m)-<span class="number">1</span>-N2:<span class="built_in">len</span>(y0_m)+N2]</span><br></pre></td></tr></table></figure><p><img src="/img/gda_20201229-154342.jpg" /></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ecf = ecf[N2:<span class="number">2</span>*N2+<span class="number">1</span>].reshape((N2+<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># biased, definite postive</span></span><br><span class="line">ecf = ecf / N</span><br></pre></td></tr></table></figure><p><img src="/img/gda_20201229-154540.jpg" /></p><blockquote><p>注意：每次运行得到的协方差系数是不一样的，而我们用于计算的模型基于观测值（样本）和噪音。因此，不同的观测值（样本）得到的模型不同。</p></blockquote><h2 id="插值法interpolation-of-the-ecf估测协方差函数-hatcf">插值法（INTERPOLATION OF THE ECF）估测协方差函数 \(\hat{CF}\)</h2><p>这里，我们使用指数模型： <span class="math display">\[\begin{equation}CF = A_0e^{(-\alpha_0(|t-t&#39;|))}\end{equation}\]</span></p><p>使用最小二乘法（LS）估测参数 \(\hat{A_0}\) 和 \(\hat{\alpha_0}\)。</p><h3 id="确定参数的近似值-widetildea-和-widetildealpha">1. 确定参数的近似值 \(\widetilde{A}\) 和 \(\widetilde{\alpha}\)</h3><p>利用第 2 和 第 3 个协方差系数来估算 \(\widetilde{A}\)，利用相关长度（correlation length）估算 \(\widetilde{\alpha}\) <span class="math display">\[\begin{equation}\begin{aligned}\widetilde{A} &amp;= 2 \times CF(1) - CF(2) \\\hat{\sigma _{0}}^{2} &amp;= CF(0) - \widetilde{A} \\\frac{\widetilde{A}}{2} &amp;= \widetilde{A}*e^{(-\widetilde{\alpha}(|\bar{\tau }|))} \\ln{\frac{1}{2}} &amp;= -\widetilde{\alpha}(|\bar{\tau }|) \\-ln{2} &amp;= -\widetilde{\alpha}(|\bar{\tau }|) \\\widetilde{\alpha} &amp;= \frac{ln2}{|\bar{\tau }|}\end{aligned}\end{equation}\]</span></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># approximated values of the parameters for linearization</span></span><br><span class="line"><span class="comment">## intersection with t=0 of the straight line</span></span><br><span class="line"><span class="comment">## exactly interpolating the covariance</span></span><br><span class="line"><span class="comment">## coefficients at step 1 and 2</span></span><br><span class="line">Ast01 = <span class="number">2</span>*ecf[<span class="number">1</span>,<span class="number">0</span>] - ecf[<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">Ast0 = Ast01</span><br><span class="line"><span class="comment"># noise variance estimate</span></span><br><span class="line">sigma2st0_v = ecf[<span class="number">0</span>,<span class="number">0</span>] - Ast0</span><br><span class="line"></span><br><span class="line">ecf_05 = Ast0/<span class="number">2</span></span><br><span class="line">i_lcorr = np.argwhere(ecf-ecf_05&lt;=<span class="number">0</span>).<span class="built_in">min</span>(<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">t_lcorr = t[i_lcorr-<span class="number">1</span>,<span class="number">0</span>] <span class="comment"># correlation length</span></span><br><span class="line"><span class="comment"># assumption: A/ecf(lcorr) = 2</span></span><br><span class="line">ast01 = np.log(<span class="number">2</span>)/t_lcorr</span><br><span class="line"></span><br><span class="line"><span class="comment"># approximated cf model</span></span><br><span class="line">ecm01 = Ast0 * np.exp(-ast01*t)</span><br></pre></td></tr></table></figure><p><img src="/img/gda_20201229-165545.jpg" /></p><h3 id="迭代估测">2. 迭代估测</h3><p>这里，我们仅迭代五次： <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">i_up = np.argwhere(ecf[<span class="number">1</span>:]-ecf[:-<span class="number">1</span>]&gt;=<span class="number">0</span>).<span class="built_in">min</span>(<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">t_up = t[i_up,<span class="number">0</span>]</span><br><span class="line"><span class="comment">#print(i_up, t[1:i_up+1])</span></span><br><span class="line"><span class="comment"># point selection for LS interpolation</span></span><br><span class="line">t0 = t[<span class="number">1</span>:i_up+<span class="number">1</span>] <span class="comment"># confusion here!!!</span></span><br><span class="line"><span class="comment"># ecf values to be interpolated</span></span><br><span class="line">ecf0 = ecf[<span class="number">1</span>:i_up+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># first iteration</span></span><br><span class="line">Ast = Ast01</span><br><span class="line">ast = ast01</span><br><span class="line"></span><br><span class="line"><span class="comment"># cf</span></span><br><span class="line">ecm = Ast * np.exp(-ast*t)</span><br><span class="line">plt.plot(t[:M+<span class="number">1</span>], ecm[:M+<span class="number">1</span>], <span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;ecm&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># design matrix (Jacobian)</span></span><br><span class="line">    A = np.hstack([np.exp(-ast*t0),-Ast*t0*np.exp(-ast*t0)])</span><br><span class="line">    <span class="comment"># known terms vector</span></span><br><span class="line">    a = np.asmatrix(Ast * np.exp(-ast*t0))</span><br><span class="line">    <span class="comment">#print(A, A.shape, a.shape, ecf0.shape, t0.shape)</span></span><br><span class="line">    <span class="comment"># estimated parameters</span></span><br><span class="line">    xst = inv(A.T.dot(A)).dot(A.T).dot(ecf0-a)</span><br><span class="line">    <span class="comment">#print(xst, xst.shape)</span></span><br><span class="line">    <span class="comment"># i-th iteration</span></span><br><span class="line">    Ast += xst[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    ast += xst[<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#print(Ast, ast, M)</span></span><br><span class="line">    <span class="comment"># cf</span></span><br><span class="line">    ecm = Ast * np.exp(-ast*t)</span><br><span class="line">    <span class="comment">#print(t.shape, ecm.shape)</span></span><br><span class="line">    plt.plot(t[:M], ecm[:M], <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">sigma2st_v = ecf[<span class="number">0</span>,<span class="number">0</span>] - Ast</span><br></pre></td></tr></table></figure> <img src="/img/gda_20201230-152900.jpg" /></p><h2 id="使用观测值和协方差函数-hatcf-预测指定点集的信号值">使用观测值和协方差函数 \(\hat{CF}\) 预测指定点集的信号值</h2><ul><li>观测值：\( \underline{y}_0 \)</li><li>协方差函数： <span class="math display">\[\begin{equation}\hat{CF} = \hat{A_0}e^{(-\hat{\alpha_0}(|t-t&#39;|))}\end{equation}\]</span></li><li>预测： <span class="math display">\[\begin{equation}\hat{y} = C_{yy} \times (C_{yy}+k\times(\hat{\sigma _{0}}^{2}\times I_{N\times N}))^{-1} \times y_0\end{equation}\]</span></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># number of observations to filter</span></span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Covariance matrix of the sampled signal</span></span><br><span class="line">Cyy = toeplitz(ecm[:n+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Covariance matrix of the sampled signal + noise</span></span><br><span class="line">Cy0y0 = Cyy + np.eye(n+<span class="number">1</span>)*sigma2st_v</span><br><span class="line"></span><br><span class="line"><span class="comment"># filtered signal</span></span><br><span class="line">yst = Cyy.dot(inv(Cy0y0)).dot(y0_m[:n+<span class="number">1</span>])</span><br><span class="line">est = y[:n+<span class="number">1</span>] - yst</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">estimation error:</span></span><br><span class="line"><span class="string">   mean\t\t= &#123;&#125;</span></span><br><span class="line"><span class="string">   std\t\t= &#123;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.<span class="built_in">format</span>(np.mean(est), np.std(est)))</span><br></pre></td></tr></table></figure><p><img src="/img/gda_20201230-162015.jpg" /></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Covariance matrix of the sampled signal</span></span><br><span class="line">Cyy = toeplitz(ecm[:n+<span class="number">1</span>])</span><br><span class="line"><span class="comment"># Covariance matrix of the sampled signal + noise</span></span><br><span class="line">Cy0y0 = Cyy + <span class="number">9</span>*np.eye(n+<span class="number">1</span>)*sigma2st_v</span><br><span class="line"></span><br><span class="line"><span class="comment"># filtered signal</span></span><br><span class="line">yst = Cyy.dot(inv(Cy0y0)).dot(y0_m[:n+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">est = y[:n+<span class="number">1</span>] - yst</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">estimation error:</span></span><br><span class="line"><span class="string">   mean\t\t= &#123;&#125;</span></span><br><span class="line"><span class="string">   std\t\t= &#123;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.<span class="built_in">format</span>(np.mean(est), np.std(est)))</span><br></pre></td></tr></table></figure><p><img src="/img/gda_20201230-162225.jpg" /></p><p>可以看出，<code>k</code> 值越大，noise 的方差越大，估测信号越平滑。</p><p>如果我们修改相关长度（correlation length）的大小： <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ecmErr = Ast * np.exp(-<span class="number">0.1</span>*ast*t)</span><br><span class="line">Cyy = toeplitz(ecmErr[:n+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Covariance matrix of the sampled signal + noise</span></span><br><span class="line">Cy0y0 = Cyy + <span class="number">9</span>*np.eye(n+<span class="number">1</span>)*sigma2st_v <span class="comment"># smoother</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># filtered signal</span></span><br><span class="line">yst = Cyy.dot(inv(Cy0y0)).dot(y0_m[:n+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">est = y[:n+<span class="number">1</span>] - yst</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">estimation error:</span></span><br><span class="line"><span class="string">   mean\t\t= &#123;&#125;</span></span><br><span class="line"><span class="string">   std\t\t= &#123;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.<span class="built_in">format</span>(np.mean(est), np.std(est)))</span><br></pre></td></tr></table></figure> <img src="/img/gda_20201230-163538.jpg" /></p><p>可以看出，相关长度越大，估测信号越平滑；相关长度越小，用以估测信号的观测值越少，估测信号越接近观测值，过滤能力越弱。</p>]]></content>
    
    
    <summary type="html">数据模拟
模拟一个信号 \( S(\underline{t}_N, \overline{w})\)，其中，\(\underline{t}_N \) 是一个规律性分布的点的集合，点集大小为 \(N\)。 \[\begin{equation} \underline{t}_N = \begin{bmatrix} 0\\ 1\\ ...\\ N-1 \end{bmatrix} \end{equation}\] 1
2
3
4


# sample size
N = 1000
# observation epochs (we assume to sample the signal on a regula</summary>
    
    
    
    <category term="GIS" scheme="http://ictar.github.io/categories/GIS/"/>
    
    
    <category term="GDA" scheme="http://ictar.github.io/tags/GDA/"/>
    
    <category term="GIS" scheme="http://ictar.github.io/tags/GIS/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Go | 内存管理：栈</title>
    <link href="http://ictar.github.io/2020/04/26/dive-into-go-memory-stack/"/>
    <id>http://ictar.github.io/2020/04/26/dive-into-go-memory-stack/</id>
    <published>2020-04-26T01:04:45.000Z</published>
    <updated>2021-01-26T03:35:55.328Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于 Go 1.14</p></blockquote><p>应用程序的内存分为： * 堆区。程序在运行期间可以主动向堆区申请内存，这些内存由内存分配器分配并由垃圾收集器负责回收。 * 栈区。由编译器自动进行分配和释放，存储函数的入参以及局部变量。这些参数会随着函数的创建而创建，函数的返回而消亡。</p><p>Go 语言使用 goroutine 作为执行上下文，而 goroutine 的初始栈内存时 2KB，比线程小很多。</p><h2 id="分段栈">分段栈</h2><p><img src="/img/divego_memory_stack_1.svg" /></p><h2 id="连续栈">连续栈</h2><p>Go 1.3 开始使用的栈策略，不再将栈分段。 <img src="/img/divego_memory_stack_2.svg" /></p><h2 id="参考">参考</h2><ul><li><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#%E6%A0%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4">栈内存管理 by draveness</a></li></ul>]]></content>
    
    
    <summary type="html">基于 Go 1.14

应用程序的内存分为： * 堆区。程序在运行期间可以主动向堆区申请内存，这些内存由内存分配器分配并由垃圾收集器负责回收。 * 栈区。由编译器自动进行分配和释放，存储函数的入参以及局部变量。这些参数会随着函数的创建而创建，函数的返回而消亡。

Go 语言使用 goroutine 作为执行上下文，而 goroutine 的初始栈内存时 2KB，比线程小很多。

分段栈


连续栈
Go 1.3 开始使用的栈策略，不再将栈分段。 

参考
 * 栈内存管理 by draveness</summary>
    
    
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
    <category term="源码解析" scheme="http://ictar.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Go | 内存管理：垃圾收集（GC）</title>
    <link href="http://ictar.github.io/2020/04/25/dive-into-go-memory-gc/"/>
    <id>http://ictar.github.io/2020/04/25/dive-into-go-memory-gc/</id>
    <published>2020-04-25T09:33:09.000Z</published>
    <updated>2021-01-26T03:40:56.084Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于 Go 1.14</p></blockquote><h2 id="概述">概述</h2><p>用户程序（Mutator）通过内存分配器（Allocator）在堆（Heap）上申请内存空间，而垃圾收集器（Collector）则负责回收不再使用的对象和内存空间。 <img src="/img/divego_memory_gc_0.svg" /></p><h3 id="标记清除mark-sweep算法">标记清除（Mark-Sweep）算法</h3><p>标记清除算法是最常见的垃圾收集算法，分为标记阶段和清除阶段。在整个垃圾收集的过程中，用户程序都是处于暂停（Stop the world, STW）状态。 <img src="/img/divego_memory_gc_1.svg" /></p><h3 id="三色标记法">三色标记法</h3><p>为了解决原始的标记清除算法带来的长时间 STW 问题，三色标记法应运而生，它能缩短 STW 的时间。</p><p><img src="/img/divego_memory_gc_2.svg" /></p><h3 id="增量垃圾收集和并发垃圾收集">增量垃圾收集和并发垃圾收集</h3><p>为了减少应用程序暂停的最长时间以及垃圾收集的总暂停时间，会使用增量垃圾收集或者并发垃圾收集这两种策略来优化垃圾收集器。</p><p><img src="/img/divego_memory_gc_3.svg" /></p><h3 id="go-语言垃圾收集器的演进过程">Go 语言垃圾收集器的演进过程</h3><p><img src="/img/divego_memory_gc_4.svg" /></p><h2 id="go-语言的具体实现">Go 语言的具体实现</h2><p><img src="/img/divego_memory_gc_5.svg" /></p><h3 id="涉及的一些结构体和全局变量">涉及的一些结构体和全局变量</h3><p><img src="/img/divego_memory_gc_6.svg" /></p><h3 id="垃圾收集的触发">垃圾收集的触发</h3><p><img src="/img/divego_memory_gc_7.svg" /></p><h3 id="垃圾收集的启动">垃圾收集的启动</h3><p><img src="/img/divego_memory_gc_8.svg" /></p><h3 id="标记阶段">标记阶段</h3><p><img src="/img/divego_memory_gc_9.svg" /></p><h3 id="标记终止">标记终止</h3><p><img src="/img/divego_memory_gc_10.svg" /></p><h3 id="内存清理">内存清理</h3><p><img src="/img/divego_memory_gc_11.svg" /></p><h2 id="参考">参考</h2><ul><li><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#722-%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B">垃圾收集器 by draveness</a></li></ul>]]></content>
    
    
    <summary type="html">基于 Go 1.14

概述
用户程序（Mutator）通过内存分配器（Allocator）在堆（Heap）上申请内存空间，而垃圾收集器（Collector）则负责回收不再使用的对象和内存空间。 

标记清除（Mark-Sweep）算法
标记清除算法是最常见的垃圾收集算法，分为标记阶段和清除阶段。在整个垃圾收集的过程中，用户程序都是处于暂停（Stop the world, STW）状态。 

三色标记法
为了解决原始的标记清除算法带来的长时间 STW 问题，三色标记法应运而生，它能缩短 STW 的时间。



增量垃圾收集和并发垃圾收集
为了减少应用程序暂停的最长时间以及垃圾收集的总暂停时间，</summary>
    
    
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
    <category term="源码解析" scheme="http://ictar.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Go | 内存管理：内存分配</title>
    <link href="http://ictar.github.io/2020/04/20/dive-into-go-memory-alloc/"/>
    <id>http://ictar.github.io/2020/04/20/dive-into-go-memory-alloc/</id>
    <published>2020-04-20T09:33:09.000Z</published>
    <updated>2021-01-26T03:38:25.750Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于 Go 1.14 <img src="/img/divego_memory_0.svg" /></p></blockquote><p>Golang 的内存分配器借鉴了 TCMalloc，在多级缓存的基础上，根据对象大小所属类别，实施不同分配策略。</p><h2 id="内存管理">内存管理</h2><h3 id="管理组件">管理组件</h3><ul><li>内存管理单元 <code>runtime.mspan</code>：Go 语言内存管理的基本单元，管理多个页<ul><li>页大小：8KB</li></ul></li><li>线程缓存 <code>runtime.mcache</code>：与线程上的处理器一一绑定，无需锁</li><li>中心缓存 <code>runtime.mcentral</code>：需要锁</li><li>页堆 <code>runtime.mheap</code>：一个 Go 语言程序只会存在一个全局的页堆</li></ul><p><img src="/img/divego_memory_alloc_0.svg" /></p><h3 id="管理">管理</h3><p>从线程缓存到操作系统内存，遵循一种模式： * 如果在当前内存管理组件获取不到可用内存，则会向下一级组件申请内存并进行扩容 * 如果最后到操作系统都申请不到内存的话，则说明宿主机上内存耗尽，程序会终止。</p><p><img src="/img/divego_memory_alloc_2.svg" /></p><h2 id="内存分配">内存分配</h2><p>堆上所有的对象都会通过 <code>runtime.newobject()</code> 来分配内存。</p><p>根据申请对象的大小执行不同的策略： * 微对象 <code>0 &lt; size &lt; 16B</code>：线程缓存中的微对象分配器 ——&gt; 线程缓存 ——&gt; 中心缓存 ——&gt; 页堆 * 小对象 <code>16B &lt;= size &lt;= 32KB</code>：线程缓存 ——&gt; 中心缓存 ——&gt; 页堆 * 大对象 <code>size &gt; 32KB</code>：直接在堆上进行分配</p><p><img src="/img/divego_memory_alloc_3.svg" /></p><h2 id="附">附</h2><h3 id="内存管理组件代码">内存管理组件代码</h3><p><img src="/img/divego_memory_alloc_1.svg" /></p><h3 id="参考">参考：</h3><ul><li><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#712-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BB%84%E4%BB%B6">内存分配器 by draveness</a></li></ul>]]></content>
    
    
    <summary type="html">基于 Go 1.14 

Golang 的内存分配器借鉴了 TCMalloc，在多级缓存的基础上，根据对象大小所属类别，实施不同分配策略。

内存管理
管理组件
 * 内存管理单元 runtime.mspan：Go 语言内存管理的基本单元，管理多个页 * 页大小：8KB
   
   
 * 线程缓存 runtime.mcache：与线程上的处理器一一绑定，无需锁
 * 中心缓存 runtime.mcentral：需要锁
 * 页堆 runtime.mheap：一个 Go 语言程序只会存在一个全局的页堆



管理
从线程缓存到操作系统内存，遵循一种模式： * 如果在当前内存管理组件获取不到可</summary>
    
    
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
    <category term="源码解析" scheme="http://ictar.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Go | 调度：GMP 模型（第三部分）</title>
    <link href="http://ictar.github.io/2020/04/14/dive-into-go-schedule-gpm-part3/"/>
    <id>http://ictar.github.io/2020/04/14/dive-into-go-schedule-gpm-part3/</id>
    <published>2020-04-14T07:41:21.000Z</published>
    <updated>2021-01-26T03:43:14.439Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/divego_schedule_gmp_schedtrig.svg" /></p><blockquote><p>以下基于 Go 1.14</p></blockquote><p>Go 程序中，在下面几种情况下都有可能触发调度（即调用 <code>runtime.schedule()</code>）： * 创建一个新的线程时 * goroutine 执行结束的时候 * 主动挂起 * 协作式调度 * 基于函数调用的抢占式调度 * 基于信号的抢占式调度（Go 1.14 新特性） * 系统调用</p><p>前面已经提到过前面两种，下面看下其他几种情况的行为方式。</p><h3 id="主动挂起">主动挂起</h3><p>当有诸如 <code>time.Sleep()</code>、锁、channel 之类的操作时，就会主动挂起 goroutine。而 goroutine 的主动挂起和唤醒分别是通过 <code>runtime.gopark()</code> 和 <code>runtime.goready()</code> 实现的：</p><p><img src="/img/divego_schedule_gmp_gopark.svg" /></p><h3 id="系统调用">系统调用</h3><p>不是所有的系统调用都会触发调度，只有那些需要运行时参与的系统调用（<code>syscall.Syscall()</code>）才有可能触发调度：</p><p><img src="/img/divego_schedule_gmp_syscall.svg" /></p><h3 id="协作式调度">协作式调度</h3><p>协作式调度指的是 goroutine 主动让出处理器，从而允许其他 goroutine 运行：</p><p><img src="/img/divego_schedule_gmp_gosched.svg" /></p><h3 id="抢占式调度">抢占式调度</h3><p>Go 语言的抢占式调度是在分段栈的机制上实现的。编译器会在分段栈上插入函数，这样，所有的 goroutine 在进行函数调用的时候都有机会进入运行时检查是否需要抢占。</p><p>但是，这种机制对于诸如轮询计算这种没有函数调用的 goroutine 来说，是无法抢占成功的。因此，Go 1.14 版本引入了基于信号的抢占式调度。</p><p><img src="/img/divego_schedule_gmp_gopreempt.svg" /></p>]]></content>
    
    
    <summary type="html">以下基于 Go 1.14

Go 程序中，在下面几种情况下都有可能触发调度（即调用 runtime.schedule()）： * 创建一个新的线程时 * goroutine 执行结束的时候 * 主动挂起 * 协作式调度 * 基于函数调用的抢占式调度 * 基于信号的抢占式调度（Go 1.14 新特性） * 系统调用

前面已经提到过前面两种，下面看下其他几种情况的行为方式。

主动挂起
当有诸如 time.Sleep()、锁、channel 之类的操作时，就会主动挂起 goroutine。而 goroutine 的主动挂起和唤醒分别是通过 runtime.gopark() 和 runtime.g</summary>
    
    
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
    <category term="源码解析" scheme="http://ictar.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Go | 调度：GMP 模型（第二部分）</title>
    <link href="http://ictar.github.io/2020/04/14/dive-into-go-schedule-gpm-part2/"/>
    <id>http://ictar.github.io/2020/04/14/dive-into-go-schedule-gpm-part2/</id>
    <published>2020-04-14T02:59:57.000Z</published>
    <updated>2021-01-26T03:42:28.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="启动调度器">启动调度器</h2><p>Go 程序启动之后，在进入 <code>main()</code> 之前，会调用 <code>runtime.schedinit()</code> 启动调度器：</p><p><img src="/img/divego_schedule_gmp_schedinit.svg" /></p><h2 id="调度循环">调度循环</h2><p>调度器启动后，Go 运行时就会调用 <code>runtime.mstart()</code> 初始化一个新线程，然后调用 <code>runtime.schedule()</code> 进入调度循环（永不返回）。调度循环会查找一个可运行的 goroutine，然后在当前线程上执行这个 goroutine。</p><p>可运行 goroutine 的来源有： * 全局可运行队列 * 与处理器 P 绑定的本地可运行队列 * netpoll * 从其他处理器 P 的本地可运行队列中窃取</p><p><img src="/img/divego_schedule_gmp_goexit.svg" /></p><h2 id="创建-goroutine">创建 goroutine</h2><p>在编译阶段，<code>go fn()</code> 会转换成运行时调用 <code>runtime.newproc()</code>。这个函数在从（本地/全局）空闲 goroutine 列表从获取不到一个可用的 goroutine 才会新建一个。并且，会将 fn 调用的参数和 <code>runtime.goexit()</code> 的 PC 保存在 goroutine 的栈中。</p><p><img src="/img/divego_schedule_gmp_gofn.svg" />&gt;</p><h2 id="goroutine-执行完毕">goroutine 执行完毕</h2><p>在调度 goroutine 运行的时候，<code>runtime.goexit()</code> 位于调用栈的顶端，因此，当 goroutine 对应的函数运行完毕后，就会跳转执行 <code>runtime.goexit()</code>：</p><p><img src="/img/divego_schedule_gmp_gofn.svg" /></p>]]></content>
    
    
    <summary type="html">启动调度器
Go 程序启动之后，在进入 main() 之前，会调用 runtime.schedinit() 启动调度器：



调度循环
调度器启动后，Go 运行时就会调用 runtime.mstart() 初始化一个新线程，然后调用 runtime.schedule() 进入调度循环（永不返回）。调度循环会查找一个可运行的 goroutine，然后在当前线程上执行这个 goroutine。

可运行 goroutine 的来源有： * 全局可运行队列 * 与处理器 P 绑定的本地可运行队列 * netpoll * 从其他处理器 P 的本地可运行队列中窃取



创建 goroutine
在编</summary>
    
    
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
    <category term="源码解析" scheme="http://ictar.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Go | 调度：GMP 模型（第一部分）</title>
    <link href="http://ictar.github.io/2020/04/13/dive-into-go-schedule-gpm-part1/"/>
    <id>http://ictar.github.io/2020/04/13/dive-into-go-schedule-gpm-part1/</id>
    <published>2020-04-13T11:15:31.000Z</published>
    <updated>2021-01-26T03:41:50.608Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下基于 Go 1.14</p></blockquote><p><img src="/img/divego_schedule_gmp_0.svg" /></p><p>Golang 中的调度是基于 GMP 模型来实现的： * G：表示 Goroutine，一个待执行的任务。 * 它对于 Go 运行时调度可以看做线程对于操作系统调度 * 在 Go 语言中使用 <code>runtime.g</code> 结构表示 * M：表示操作系统线程，由操作系统调度以及管理 * 调度器最多可以创建 10000 个线程，最多只会有 <code>GOMAXPROCS</code> 个活跃活跃线程 * 在 Go 语言中使用 <code>runtime.m</code> 结构表示 * P：表示处理器 * Go 程序的处理器数量一定是 <code>GOMAXPROCS</code> 个，在调度器启动的时候就会创建 * 在 Go 语言中使用 <code>runtime.p</code> 结构表示</p><p>一些全局变量说明：</p><p><img src="/img/divego_schedule_gmp_globalvar.svg" /></p><h2 id="附数据结构">附：数据结构</h2><p><img src="/img/divego_schedule_gmp_datastruct.svg" /></p>]]></content>
    
    
    <summary type="html">以下基于 Go 1.14



Golang 中的调度是基于 GMP 模型来实现的： * G：表示 Goroutine，一个待执行的任务。 * 它对于 Go 运行时调度可以看做线程对于操作系统调度 * 在 Go 语言中使用 runtime.g 结构表示 * M：表示操作系统线程，由操作系统调度以及管理 * 调度器最多可以创建 10000 个线程，最多只会有 GOMAXPROCS 个活跃活跃线程 * 在 Go 语言中使用 runtime.m 结构表示 * P：表示处理器 * Go 程序的处理器数量一定是 GOMAXPROCS 个，在调度器启动的时候就会创建 * 在 Go 语言中使用 runtim</summary>
    
    
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
    <category term="源码解析" scheme="http://ictar.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Go | channel 类型</title>
    <link href="http://ictar.github.io/2020/04/04/dive-into-go-channel-type/"/>
    <id>http://ictar.github.io/2020/04/04/dive-into-go-channel-type/</id>
    <published>2020-04-04T01:37:30.000Z</published>
    <updated>2021-01-26T03:36:49.576Z</updated>
    
    <content type="html"><![CDATA[<p>channel 是 go 语言实现 CSP 并发模型的一个非常重要的要素。</p><blockquote><p>以下基于 Go 1.14</p></blockquote><h2 id="数据结构-runtime.hchan">数据结构 <code>runtime.hchan</code></h2><p><img src="/img/divego_channel_struct.svg" /></p><h2 id="channel-操作">channel 操作</h2><p>预警！！！！一大批示意图即将来临！！！！！！</p><h3 id="创建-channel">创建 channel</h3><p><img src="/img/divego_makechan.svg" /></p><h3 id="发送数据">发送数据</h3><p><img src="/img/divego_chansend.svg" /></p><h3 id="接收数据">接收数据</h3><p><img src="/img/divego_chanrecv.svg" /></p><h3 id="关闭-channel">关闭 channel</h3><p><img src="/img/divego_closechan.svg" /></p>]]></content>
    
    
    <summary type="html">channel 是 go 语言实现 CSP 并发模型的一个非常重要的要素。

以下基于 Go 1.14

数据结构 runtime.hchan


channel 操作
预警！！！！一大批示意图即将来临！！！！！！

创建 channel


发送数据


接收数据


关闭 channel</summary>
    
    
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
    <category term="源码解析" scheme="http://ictar.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Go | select ... case ... default</title>
    <link href="http://ictar.github.io/2020/04/02/dive-into-go-select-case/"/>
    <id>http://ictar.github.io/2020/04/02/dive-into-go-select-case/</id>
    <published>2020-04-02T08:48:41.000Z</published>
    <updated>2021-01-26T03:43:37.331Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下基于 Go 1.14</p></blockquote><h2 id="编译时">编译时</h2><p><img src="/img/divego_select_case_compile.svg" /></p><h2 id="runtime.selectgo-的行为"><code>runtime.selectgo()</code> 的行为</h2><p><img src="/img/divego_select_case_selectgo.svg" /></p>]]></content>
    
    
    <summary type="html">以下基于 Go 1.14

编译时


runtime.selectgo() 的行为</summary>
    
    
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
    <category term="源码解析" scheme="http://ictar.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Go | panic 和 recover</title>
    <link href="http://ictar.github.io/2020/04/01/dive-into-go-panic-recover/"/>
    <id>http://ictar.github.io/2020/04/01/dive-into-go-panic-recover/</id>
    <published>2020-04-01T09:01:01.000Z</published>
    <updated>2021-01-26T03:41:17.389Z</updated>
    
    <content type="html"><![CDATA[<p>golang 中使用了以下两个内置函数来处理错误和恢复：</p><p><code>func panic(v interface&#123;&#125;)</code>： * 一旦调用： * 立刻停止执行函数其他代码 * 执行结束后，在当前 Goroutine 中递归执行调用方的延迟函数调用 defer * 允许在 defer 中嵌套多次调用</p><p><code>func recover() interface&#123;&#125;</code>： * 用于中止 panic 造成的程序崩溃 * 只能在 defer 中发挥作用（只有在 panic 之后调用才生效）</p><blockquote><p>基于 Go 1.14</p></blockquote><h3 id="数据结构">数据结构</h3><p><code>panic</code> 关键字在 golang 中由数据结构 <code>runtime._panic</code> 表示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A _panic holds information about an active panic.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is marked go:notinheap because _panic values must only ever</span></span><br><span class="line"><span class="comment">// live on the stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The argp and link fields are stack pointers, but don&#x27;t need special</span></span><br><span class="line"><span class="comment">// handling during stack growth: because they are pointer-typed and</span></span><br><span class="line"><span class="comment">// _panic values only live on the stack, regular stack pointer</span></span><br><span class="line"><span class="comment">// adjustment takes care of them.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:notinheap</span></span><br><span class="line"><span class="keyword">type</span> _panic <span class="keyword">struct</span> &#123;</span><br><span class="line">argp      unsafe.Pointer <span class="comment">// 指向 panic 期间运行的 defer 调用的参数</span></span><br><span class="line">arg       <span class="keyword">interface</span>&#123;&#125;    <span class="comment">// 调用 panic 时传入的参数</span></span><br><span class="line">link      *_panic        <span class="comment">// 指向更早调用的 panic</span></span><br><span class="line">pc        <span class="keyword">uintptr</span>        <span class="comment">// where to return to in runtime if this panic is bypassed</span></span><br><span class="line">sp        unsafe.Pointer <span class="comment">// where to return to in runtime if this panic is bypassed</span></span><br><span class="line">recovered <span class="keyword">bool</span>           <span class="comment">// 表示当前这个 panic 是否被 recover 恢复</span></span><br><span class="line">aborted   <span class="keyword">bool</span>           <span class="comment">// 表示当前这个 panic 是否被强行终止</span></span><br><span class="line">goexit    <span class="keyword">bool</span>          <span class="comment">// 当调用了 runtime.Goexit()，就会将该值修改为 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 编译时</p><p><img src="/img/divego_panic_recover_compile.svg" /></p><h3 id="运行时">运行时</h3><p><img src="/img/divego_panic_recover_runtime.svg" /></p>]]></content>
    
    
    <summary type="html">golang 中使用了以下两个内置函数来处理错误和恢复：

func panic(v interface{})： * 一旦调用： * 立刻停止执行函数其他代码 * 执行结束后，在当前 Goroutine 中递归执行调用方的延迟函数调用 defer * 允许在 defer 中嵌套多次调用

func recover() interface{}： * 用于中止 panic 造成的程序崩溃 * 只能在 defer 中发挥作用（只有在 panic 之后调用才生效）

基于 Go 1.14

数据结构
panic 关键字在 golang 中由数据结构 runtime._panic 表示： 1
2
3
4</summary>
    
    
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
    <category term="源码解析" scheme="http://ictar.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Go | for ... range</title>
    <link href="http://ictar.github.io/2020/04/01/dive-into-go-for-range/"/>
    <id>http://ictar.github.io/2020/04/01/dive-into-go-for-range/</id>
    <published>2020-04-01T08:01:01.000Z</published>
    <updated>2021-01-26T03:37:24.819Z</updated>
    
    <content type="html"><![CDATA[<p>golang 语法糖 <code>for ... = range</code> 是如何实现的呢？话不多说，直接上图：</p><p><img src="/img/divego_for_range.svg" /></p><blockquote><p>基于 Go 1.14</p></blockquote><p>参考： * <a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-for-range/">draveness: for 和 range</a></p>]]></content>
    
    
    <summary type="html">golang 语法糖 for ... = range 是如何实现的呢？话不多说，直接上图：



基于 Go 1.14

参考： * draveness: for 和 range</summary>
    
    
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
    <category term="源码解析" scheme="http://ictar.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Go | defer</title>
    <link href="http://ictar.github.io/2020/03/25/dive-into-go-defer/"/>
    <id>http://ictar.github.io/2020/03/25/dive-into-go-defer/</id>
    <published>2020-03-25T11:18:47.000Z</published>
    <updated>2020-12-25T08:20:41.006Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下基于 Go 1.14</p></blockquote><p>Go 语言中的 <code>defer</code> 常用来进行资源释放。它有以下几个特点： * 向 <code>defer</code> 传入的函数会在当前函数或者方法返回之前运行。 * 函数中调用的多个 <code>defer</code> 会以先调用后执行的方式进行 * 在调用 <code>defer</code> 时，就会对函数传入的参数进行计算。</p><h2 id="defer-类型"><code>defer</code> 类型</h2><p>有三种类型的 <code>defer</code></p><p>编译器的 ssa 过程中会确认当前 <code>defer</code> 的类型： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compile.internal.gc.state.stmt</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">stmt</span><span class="params">(n *Node)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> ODEFER:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> s.hasOpenDefers &#123;</span><br><span class="line">s.openDeferRecord(n.Left)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">d := callDefer</span><br><span class="line"><span class="keyword">if</span> n.Esc == EscNever &#123;</span><br><span class="line">d = callDeferStack</span><br><span class="line">&#125;</span><br><span class="line">s.call(n.Left, d)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 可以使用 <code>$ go tool compile -d defer hello.go</code> 来检查 <code>defer</code> 类型。</p><h3 id="open-coded">open-coded</h3><p>Go 1.14 引入，目的是优化 defer 的运行时间。编译器在 ssa 过程中，会将被延迟的方法直接插入到函数的尾部（inline），从而避免运行时的 <code>deferproc</code> 和 <code>deferprocStack</code> 操作，以及多次调用 <code>deferreturn</code>。</p><ul><li>以下情况不使用这种类型来处理 <code>defer</code>：<ul><li>函数中对 <code>defer</code> 的调用次数超过 8（这是为了最小化代码大小，只使用 1 个 byte 来辅助标识）（例如下面的 <code>f0</code> 和 <code>f1</code>）</li><li>函数中存在出现在循环中的 <code>defer</code>（例如下面的 <code>f2</code>、<code>f3</code>、<code>f4</code> 和 <code>f5</code>）<ul><li>包括使用 <code>for</code> 构造的和使用 label+<code>goto</code> 构造的</li></ul></li><li>函数中出现过多（返回语句次数 * defer 个数 &gt; 15）的返回语句<ul><li>因为会在每个返回点前插入被 defer 的函数调用</li></ul></li><li><code>gcflags</code> 无 N</li></ul></li></ul><p>举例说明： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 8 次 defer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f0</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer0&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defe1&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer2&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defe3&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer4&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defe5&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer6&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer7&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;f0&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123; <span class="comment">// 9 次 defer</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer0&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defe1&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer2&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defe3&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer4&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defe5&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer6&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer7&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer8&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;f1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> &#123; <span class="comment">// defer 没有出现在循环中(for)</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer0&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1</span>; i += <span class="number">1</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;f2&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span></span> &#123;<span class="comment">// defer 出现在循环中(for)</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1</span>; i += <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// heap-allocated defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer0&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;f3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f4</span><span class="params">()</span></span> &#123; <span class="comment">// defer 没有出现在循环中(label+goto)</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// open-coded defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer0&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">label:</span><br><span class="line">fmt.Println(<span class="string">&quot;f4&quot;</span>)</span><br><span class="line"><span class="keyword">goto</span> label</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f5</span><span class="params">()</span></span> &#123;<span class="comment">// defer 出现在循环中(label+goto)</span></span><br><span class="line">label:</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// heap-allocated defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer0&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;f5&quot;</span>)</span><br><span class="line"><span class="keyword">goto</span> label</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### stack-allocated Go 1.13 引入，用于优化性能，表示在栈上分配 <code>defer</code> 相关的结构体</p><p>那么，什么时候会在栈上分配呢？答案在下面这部分代码： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/gc/escape.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Escape)</span> <span class="title">augmentParamHole</span><span class="params">(k EscHole, call, where *Node)</span> <span class="title">EscHole</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Top level defers arguments don&#x27;t escape to heap, but they</span></span><br><span class="line"><span class="comment">// do need to last until end of function. Tee with a</span></span><br><span class="line"><span class="comment">// non-transient location to avoid arguments from being</span></span><br><span class="line"><span class="comment">// transiently allocated.</span></span><br><span class="line"><span class="keyword">if</span> where.Op == ODEFER &amp;&amp; e.loopDepth == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// force stack allocation of defer record, unless open-coded</span></span><br><span class="line"><span class="comment">// defers are used (see ssa.go)</span></span><br><span class="line">where.Esc = EscNever</span><br><span class="line"><span class="keyword">return</span> e.later(k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 举例说明： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f6</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// stack-allocated defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer2&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// heap-allocated defer</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer1&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### heap-allocated 表示在堆上分配 <code>defer</code> 相关的结构体，最原始的方式。</p><h2 id="实现原理">实现原理</h2><h3 id="一个数据结构">一个数据结构</h3><p>在 Go 中，<code>defer</code> 关键字对应的数据结构为 <code>runtime._defer</code>。这是一个用链表实现的栈。</p><h3 id="编译时">编译时</h3><ul><li>处理 <code>defer</code> 关键字<ul><li>如果是 <code>open-coded</code> 类型的 defer，则调用 <code>cmd/compile/internal/gc.state.openDeferRecord</code> 方法，</li><li>如果是 <code>stack-allocated</code> 类型，则转换成 <code>runtime.deferprocStack</code></li><li>如果是 <code>heap-allocated</code> 类型，则转换成 <code>runtime.deferproc</code></li></ul></li><li>在调用 <code>defer</code> 的函数返回之前插入 <code>runtime.deferreturn</code> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compile.internal.gc.state</span></span><br><span class="line"><span class="comment">// 处理任何需要在返回前生成的代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">exit</span><span class="params">()</span> *<span class="title">ssa</span>.<span class="title">Block</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.hasdefer &#123; <span class="comment">// 函数中存在 defer 调用</span></span><br><span class="line"><span class="keyword">if</span> s.hasOpenDefers &#123; <span class="comment">// 如果有 open-coded 类型的 defer</span></span><br><span class="line"><span class="keyword">if</span> shareDeferExits &amp;&amp; s.lastDeferExit != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(s.openDefers) == s.lastDeferCount &#123;</span><br><span class="line"><span class="keyword">if</span> s.curBlock.Kind != ssa.BlockPlain &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;Block for an exit should be BlockPlain&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">s.curBlock.AddEdgeTo(s.lastDeferExit)</span><br><span class="line">s.endBlock()</span><br><span class="line"><span class="keyword">return</span> s.lastDeferFinalBlock</span><br><span class="line">&#125;</span><br><span class="line">s.openDeferExit()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 对于其他类型的 defer，调用 </span></span><br><span class="line">s.rtcall(Deferreturn, <span class="literal">true</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// openDeferExit 生成 SSA，从而在退出的时候处理所有的 open-coded 类型的 defer。</span></span><br><span class="line"><span class="comment">// 这个过程会加载 deferBits 字段，然后检查这个字段的每个位，检查是否执行了对应的 defer 语句。</span></span><br><span class="line"><span class="comment">// 对于每一个打开的位，会进行相关的 defer 调用。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">openDeferExit</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 运行时</li><li>如果调用了 <code>runtime.deferprocStack</code> 或者 <code>runtime.deferproc</code>，那么它们都会将一个新的 <code>runtime._defer</code> 结构体（此时就会对函数参数进行计算）追加到当前 Goroutine 的 <code>_defer</code> 链表的头部</li><li><code>runtime.deferreturn</code> 会从 Goroutine 的 <code>_defer</code> 链表中取出 <code>runtime._defer</code> 结构并执行<ul><li>如果是 <code>open-coded</code> 类型的延迟调用，则会调用 <code>runtime.runOpenDeferFrame</code> 函数来运行该 <code>_defer</code> 结构中所有有效的延迟调用。</li><li>否则，它会调用 <code>runtime·jmpdefer</code> 函数。这个函数会跳到对应被延迟调用的函数并执行</li><li>会多次调用 <code>runtime.deferreturn</code>，直到所有的延迟调用都执行完毕。</li></ul></li></ul><h2 id="参考">参考</h2><ul><li><a href="https://github.com/golang/proposal/blob/master/design/34481-opencoded-defers.md">Proposal: Low-cost defers through inline code, and extra funcdata to manage the panic case</a></li><li><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#532-">draveness: defer</a></li></ul>]]></content>
    
    
    <summary type="html">以下基于 Go 1.14

Go 语言中的 defer 常用来进行资源释放。它有以下几个特点： * 向 defer 传入的函数会在当前函数或者方法返回之前运行。 * 函数中调用的多个 defer 会以先调用后执行的方式进行 * 在调用 defer 时，就会对函数传入的参数进行计算。

defer 类型
有三种类型的 defer

编译器的 ssa 过程中会确认当前 defer 的类型： 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19


// compile.internal.gc.state.stmt
func (s *state) stmt(</summary>
    
    
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
    <category term="源码解析" scheme="http://ictar.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Go | 函数调用</title>
    <link href="http://ictar.github.io/2020/03/24/dive-into-go-func-call/"/>
    <id>http://ictar.github.io/2020/03/24/dive-into-go-func-call/</id>
    <published>2020-03-24T12:11:39.000Z</published>
    <updated>2020-12-25T08:20:40.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>对于函数调用，Go 语言使用调用者预先分配的栈来传递参数和返回值，使得多值返回成为可能。</p><blockquote><p>以下基于 Go1.14</p></blockquote><p>考虑以下代码： <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b, a == b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">do(<span class="number">33</span>, <span class="number">66</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 然后运行以下命令查看对应的汇编指令： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ go tool compile -S -N -l hello.go</span><br><span class="line">....</span><br><span class="line"><span class="string">&quot;&quot;</span>.main STEXT size=68 args=0x0 locals=0x28</span><br><span class="line">0x0000 00000 (hello.go:7)TEXT<span class="string">&quot;&quot;</span>.main(SB), ABIInternal, <span class="variable">$40</span>-0</span><br><span class="line">0x0000 00000 (hello.go:7)MOVQ(TLS), CX</span><br><span class="line">0x0009 00009 (hello.go:7)CMPQSP, 16(CX)</span><br><span class="line">0x000d 00013 (hello.go:7)PCDATA<span class="variable">$0</span>, $-2</span><br><span class="line">0x000d 00013 (hello.go:7)JLS61</span><br><span class="line">0x000f 00015 (hello.go:7)PCDATA<span class="variable">$0</span>, $-1</span><br><span class="line">0x000f 00015 (hello.go:7)SUBQ<span class="variable">$40</span>, SP <span class="comment"># 分配 40 字节的栈空间</span></span><br><span class="line">0x0013 00019 (hello.go:7)MOVQBP, 32(SP) <span class="comment"># 保存基址指针 BP 到栈上</span></span><br><span class="line">0x0018 00024 (hello.go:7)LEAQ32(SP), BP <span class="comment"># 修改基址指针</span></span><br><span class="line">0x001d 00029 (hello.go:7)PCDATA<span class="variable">$0</span>, $-2</span><br><span class="line">0x001d 00029 (hello.go:7)PCDATA<span class="variable">$1</span>, $-2</span><br><span class="line">0x001d 00029 (hello.go:7)FUNCDATA<span class="variable">$0</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x001d 00029 (hello.go:7)FUNCDATA<span class="variable">$1</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x001d 00029 (hello.go:7)FUNCDATA<span class="variable">$2</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x001d 00029 (hello.go:8)PCDATA<span class="variable">$0</span>, <span class="variable">$0</span></span><br><span class="line">0x001d 00029 (hello.go:8)PCDATA<span class="variable">$1</span>, <span class="variable">$0</span></span><br><span class="line">0x001d 00029 (hello.go:8)MOVQ<span class="variable">$33</span>, (SP) <span class="comment"># 第一个参数</span></span><br><span class="line">0x0025 00037 (hello.go:8)MOVQ<span class="variable">$66</span>, 8(SP) <span class="comment"># 第二个参数</span></span><br><span class="line">0x002e 00046 (hello.go:8)CALL<span class="string">&quot;&quot;</span>.<span class="keyword">do</span>(SB) <span class="comment"># 将当前的 IP 压入栈中，然后调用函数 do</span></span><br><span class="line">0x0033 00051 (hello.go:9)MOVQ32(SP), BP <span class="comment"># 恢复基址指针</span></span><br><span class="line">0x0038 00056 (hello.go:9)ADDQ<span class="variable">$40</span>, SP <span class="comment"># 回收分配的栈空间</span></span><br><span class="line">0x003c 00060 (hello.go:9)RET</span><br><span class="line">......</span><br></pre></td></tr></table></figure> 从上面可以看出，在进行函数调用前，会为调用的函数分配栈空间（用于入参和返回值）、保存基址指针并修改其指向，然后将入参压入栈中（第一个参数在栈顶，以此类推）。</p><p>接着通过 <code>CALL</code> 指令，将 <code>main</code> 的返回地址压入栈中，然后进行函数调用。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.<span class="keyword">do</span> STEXT nosplit size=45 args=0x20 locals=0x0</span><br><span class="line">    ......</span><br><span class="line">0x0000 00000 (hello.go:3)MOVQ<span class="variable">$0</span>, <span class="string">&quot;&quot;</span>.~r2+24(SP) <span class="comment"># 初始化第一个返回值</span></span><br><span class="line">0x0009 00009 (hello.go:3)MOVB<span class="variable">$0</span>, <span class="string">&quot;&quot;</span>.~r3+32(SP) <span class="comment"># 初始化第二个返回值</span></span><br><span class="line">0x000e 00014 (hello.go:4)MOVQ<span class="string">&quot;&quot;</span>.a+8(SP), AX <span class="comment"># 获取第一个参数，AX = 33</span></span><br><span class="line">0x0013 00019 (hello.go:4)ADDQ<span class="string">&quot;&quot;</span>.b+16(SP), AX <span class="comment"># 做加法，AX = AX + 66 = 99</span></span><br><span class="line">0x0018 00024 (hello.go:4)MOVQAX, <span class="string">&quot;&quot;</span>.~r2+24(SP) <span class="comment"># 把计算结果保存在第一个返回值中，24(SP) = AX = 99</span></span><br><span class="line">0x001d 00029 (hello.go:4)MOVQ<span class="string">&quot;&quot;</span>.b+16(SP), AX <span class="comment"># AX = 66</span></span><br><span class="line">0x0022 00034 (hello.go:4)CMPQ<span class="string">&quot;&quot;</span>.a+8(SP), AX <span class="comment"># 8(SP) 和 AX 进行比较，即 AX - 8(SP) = 66 - 33 = 33</span></span><br><span class="line">0x0027 00039 (hello.go:4)SETEQ<span class="string">&quot;&quot;</span>.~r3+32(SP) <span class="comment"># 判断上一步的计算结果是否为 0，保存在第二个返回值中，32(SP) = 0</span></span><br><span class="line">0x002c 00044 (hello.go:4)RET <span class="comment"># 修改 IP，返回调用点</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure> 被调用的函数在执行的时候，会将调用栈里面保存返回值的位置初始化为 0，然后进行一系列的操作后，将返回值保存在栈中，最后返回该函数的调用点。</p><p><img src="/img/20200324212922.jpg" /></p><h2 id="参数传递">参数传递</h2><h3 id="变长参数">变长参数</h3><p>将 <code>do</code> 函数修改为支持变长参数，如下所示： <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(nums ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %v\n&quot;</span>, nums, nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">do() <span class="comment">// output: []int []</span></span><br><span class="line">do(<span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>) <span class="comment">// output: []int [33 44 55]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 可以看到，变长参数其实是一个语法糖，golang 会为这些变长参数隐式创建一个 slice，然后再把这个 slice 作为参数传入到调用的函数中。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.main STEXT size=196 args=0x0 locals=0x40</span><br><span class="line">    ……</span><br><span class="line">    <span class="comment"># do(33, 44, 55)</span></span><br><span class="line">    <span class="comment"># 创建一个大小为 3，容量为 3 的 slice，值为[33, 44, 55]</span></span><br><span class="line">0x0036 00054 (hello.go:11)LEAQ<span class="built_in">type</span>.[3]int(SB), AX </span><br><span class="line">0x003d 00061 (hello.go:11)PCDATA<span class="variable">$0</span>, <span class="variable">$0</span></span><br><span class="line">0x003d 00061 (hello.go:11)MOVQAX, (SP)</span><br><span class="line">0x0041 00065 (hello.go:11)CALLruntime.newobject(SB)</span><br><span class="line">0x0046 00070 (hello.go:11)PCDATA<span class="variable">$0</span>, <span class="variable">$1</span></span><br><span class="line">0x0046 00070 (hello.go:11)MOVQ8(SP), AX</span><br><span class="line">0x004b 00075 (hello.go:11)PCDATA<span class="variable">$1</span>, <span class="variable">$1</span></span><br><span class="line">0x004b 00075 (hello.go:11)MOVQAX, <span class="string">&quot;&quot;</span>..autotmp_1+24(SP)</span><br><span class="line">0x0050 00080 (hello.go:11)PCDATA<span class="variable">$0</span>, <span class="variable">$0</span></span><br><span class="line">0x0050 00080 (hello.go:11)MOVQ<span class="variable">$33</span>, (AX)</span><br><span class="line">0x0057 00087 (hello.go:11)PCDATA<span class="variable">$0</span>, <span class="variable">$1</span></span><br><span class="line">0x0057 00087 (hello.go:11)MOVQ<span class="string">&quot;&quot;</span>..autotmp_1+24(SP), AX</span><br><span class="line">0x005c 00092 (hello.go:11)TESTBAL, (AX)</span><br><span class="line">0x005e 00094 (hello.go:11)PCDATA<span class="variable">$0</span>, <span class="variable">$0</span></span><br><span class="line">0x005e 00094 (hello.go:11)MOVQ<span class="variable">$44</span>, 8(AX)</span><br><span class="line">0x0066 00102 (hello.go:11)PCDATA<span class="variable">$0</span>, <span class="variable">$1</span></span><br><span class="line">0x0066 00102 (hello.go:11)MOVQ<span class="string">&quot;&quot;</span>..autotmp_1+24(SP), AX</span><br><span class="line">0x006b 00107 (hello.go:11)TESTBAL, (AX)</span><br><span class="line">0x006d 00109 (hello.go:11)PCDATA<span class="variable">$0</span>, <span class="variable">$0</span></span><br><span class="line">0x006d 00109 (hello.go:11)MOVQ<span class="variable">$55</span>, 16(AX)</span><br><span class="line">0x0075 00117 (hello.go:11)PCDATA<span class="variable">$0</span>, <span class="variable">$1</span></span><br><span class="line">0x0075 00117 (hello.go:11)PCDATA<span class="variable">$1</span>, <span class="variable">$0</span></span><br><span class="line">0x0075 00117 (hello.go:11)MOVQ<span class="string">&quot;&quot;</span>..autotmp_1+24(SP), AX</span><br><span class="line">0x007a 00122 (hello.go:11)TESTBAL, (AX)</span><br><span class="line">0x007c 00124 (hello.go:11)JMP126</span><br><span class="line">0x007e 00126 (hello.go:11)MOVQAX, <span class="string">&quot;&quot;</span>..autotmp_0+32(SP)</span><br><span class="line">0x0083 00131 (hello.go:11)MOVQ<span class="variable">$3</span>, <span class="string">&quot;&quot;</span>..autotmp_0+40(SP)</span><br><span class="line">0x008c 00140 (hello.go:11)MOVQ<span class="variable">$3</span>, <span class="string">&quot;&quot;</span>..autotmp_0+48(SP)</span><br><span class="line">0x0095 00149 (hello.go:11)PCDATA<span class="variable">$0</span>, <span class="variable">$0</span></span><br><span class="line">0x0095 00149 (hello.go:11)MOVQAX, (SP)</span><br><span class="line">0x0099 00153 (hello.go:11)MOVQ<span class="variable">$3</span>, 8(SP)</span><br><span class="line">0x00a2 00162 (hello.go:11)MOVQ<span class="variable">$3</span>, 16(SP)</span><br><span class="line">    <span class="comment"># 调用 do 函数</span></span><br><span class="line">0x00ab 00171 (hello.go:11)CALL<span class="string">&quot;&quot;</span>.<span class="keyword">do</span>(SB)</span><br><span class="line">0x00b0 00176 (hello.go:12)MOVQ56(SP), BP</span><br><span class="line">0x00b5 00181 (hello.go:12)ADDQ<span class="variable">$64</span>, SP</span><br><span class="line">0x00b9 00185 (hello.go:12)RET</span><br></pre></td></tr></table></figure> ## 返回值 ### 命名返回值 我们将代码稍微修改下，命名函数 <code>do</code> 的返回值： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>, equal <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b, a == b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 然后查看汇编，可以发现，<code>main</code> 在进行函数调用的时候基本没有改动，但是被调用函数在执行的时候多了几项操作。<strong>在执行前，会申请额外的栈空间来存放临时返回值。</strong>然后，初始化命名返回值，进行一系列操作后，把返回结果保存在临时返回值中。最后，再使用临时返回值一一设置命名返回值。接着释放存放临时返回值的栈空间，返回到函数调用点。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.<span class="keyword">do</span> STEXT nosplit size=87 args=0x20 locals=0x18</span><br><span class="line">0x0000 00000 (hello.go:3)TEXT<span class="string">&quot;&quot;</span>.<span class="keyword">do</span>(SB), NOSPLIT|ABIInternal, <span class="variable">$24</span>-32</span><br><span class="line">0x0000 00000 (hello.go:3)SUBQ<span class="variable">$24</span>, SP // 申请空间存放临时返回值</span><br><span class="line">0x0004 00004 (hello.go:3)MOVQBP, 16(SP)</span><br><span class="line">0x0009 00009 (hello.go:3)LEAQ16(SP), BP</span><br><span class="line">0x000e 00014 (hello.go:3)PCDATA<span class="variable">$0</span>, $-2</span><br><span class="line">0x000e 00014 (hello.go:3)PCDATA<span class="variable">$1</span>, $-2</span><br><span class="line">0x000e 00014 (hello.go:3)FUNCDATA<span class="variable">$0</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x000e 00014 (hello.go:3)FUNCDATA<span class="variable">$1</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x000e 00014 (hello.go:3)FUNCDATA<span class="variable">$2</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x000e 00014 (hello.go:3)PCDATA<span class="variable">$0</span>, <span class="variable">$0</span></span><br><span class="line">0x000e 00014 (hello.go:3)PCDATA<span class="variable">$1</span>, <span class="variable">$0</span></span><br><span class="line">0x000e 00014 (hello.go:3)MOVQ<span class="variable">$0</span>, <span class="string">&quot;&quot;</span>.res+48(SP) // 初始化第一个返回值，res = 0</span><br><span class="line">0x0017 00023 (hello.go:3)MOVB<span class="variable">$0</span>, <span class="string">&quot;&quot;</span>.equal+56(SP) // 初始化第二个返回值，equal = 0</span><br><span class="line">0x001c 00028 (hello.go:4)MOVQ<span class="string">&quot;&quot;</span>.a+32(SP), AX // AX = a = 33</span><br><span class="line">0x0021 00033 (hello.go:4)ADDQ<span class="string">&quot;&quot;</span>.b+40(SP), AX // AX = AX + b = 33 + 66 = 99</span><br><span class="line">0x0026 00038 (hello.go:4)MOVQAX, <span class="string">&quot;&quot;</span>..autotmp_4+8(SP) // 计算结果保存在临时变量中</span><br><span class="line">0x002b 00043 (hello.go:4)MOVQ<span class="string">&quot;&quot;</span>.b+40(SP), AX</span><br><span class="line">0x0030 00048 (hello.go:4)CMPQ<span class="string">&quot;&quot;</span>.a+32(SP), AX</span><br><span class="line">0x0035 00053 (hello.go:4)SETEQ<span class="string">&quot;&quot;</span>..autotmp_5+7(SP) // 计算结果保存在临时变量中</span><br><span class="line">0x003a 00058 (hello.go:4)MOVQ<span class="string">&quot;&quot;</span>..autotmp_4+8(SP), AX</span><br><span class="line">0x003f 00063 (hello.go:4)MOVQAX, <span class="string">&quot;&quot;</span>.res+48(SP) // 用临时变量设置命名返回值</span><br><span class="line">0x0044 00068 (hello.go:4)MOVBLZX<span class="string">&quot;&quot;</span>..autotmp_5+7(SP), AX // 用临时变量设置命名返回值</span><br><span class="line">0x0049 00073 (hello.go:4)MOVBAL, <span class="string">&quot;&quot;</span>.equal+56(SP)</span><br><span class="line">0x004d 00077 (hello.go:4)MOVQ16(SP), BP</span><br><span class="line">0x0052 00082 (hello.go:4)ADDQ<span class="variable">$24</span>, SP</span><br><span class="line">0x0056 00086 (hello.go:4)RET</span><br></pre></td></tr></table></figure> 也就是说，如果对于非命名返回值，执行逻辑为： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    r1, r2 := a+b, a == b</span><br><span class="line">    <span class="keyword">return</span> r1, r2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 那么命名返回值的执行逻辑为： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>, equal <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    tmp1, tmp2 := a+b, a == b</span><br><span class="line">    res = tmp1</span><br><span class="line">    equal = tmp2</span><br><span class="line">    <span class="keyword">return</span> res, equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 总结 golang 的函数调用具有以下特征： * 参数完全通过栈传递，从参数列表右至左压栈（第一个参数在栈顶） * 返回值通过栈传递 * 调用者负责清理栈空间</p><h2 id="参考">参考</h2><ul><li><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/">函数调用（）</a></li><li><a href="https://mojotv.cn/2019/07/21/golang-stack-function">Go 函数调用 ━ 栈和寄存器视角</a></li></ul>]]></content>
    
    
    <summary type="html">概述
对于函数调用，Go 语言使用调用者预先分配的栈来传递参数和返回值，使得多值返回成为可能。

以下基于 Go1.14

考虑以下代码： 1
2
3
4
5
6
7
8
9


package main

func do(a, b int) (int, bool) {
	return a + b, a == b
}

func main() {
	do(33, 66)
}


然后运行以下命令查看对应的汇编指令： 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26


$ go tool compile -</summary>
    
    
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
    <category term="源码解析" scheme="http://ictar.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Go | make vs. new</title>
    <link href="http://ictar.github.io/2020/03/23/dive-into-go-make-new/"/>
    <id>http://ictar.github.io/2020/03/23/dive-into-go-make-new/</id>
    <published>2020-03-23T06:42:01.000Z</published>
    <updated>2020-12-25T08:20:40.956Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下基于 go 1.14</p></blockquote><h2 id="基本使用">基本使用</h2><p>在 golang 中，内置函数 <code>make</code> 和 <code>new</code> 都是用来分配内存的。<code>src/builtin/builtin.go</code> 中对 <code>make</code> 和 <code>new</code> 的声明如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The make built-in function allocates and initializes an object of type</span></span><br><span class="line"><span class="comment">// slice, map, or chan (only). Like new, the first argument is a type, not a</span></span><br><span class="line"><span class="comment">// value. Unlike new, make&#x27;s return type is the same as the type of its</span></span><br><span class="line"><span class="comment">// argument, not a pointer to it. The specification of the result depends on</span></span><br><span class="line"><span class="comment">// the type:</span></span><br><span class="line"><span class="comment">//Slice: The size specifies the length. The capacity of the slice is</span></span><br><span class="line"><span class="comment">//equal to its length. A second integer argument may be provided to</span></span><br><span class="line"><span class="comment">//specify a different capacity; it must be no smaller than the</span></span><br><span class="line"><span class="comment">//length. For example, make([]int, 0, 10) allocates an underlying array</span></span><br><span class="line"><span class="comment">//of size 10 and returns a slice of length 0 and capacity 10 that is</span></span><br><span class="line"><span class="comment">//backed by this underlying array.</span></span><br><span class="line"><span class="comment">//Map: An empty map is allocated with enough space to hold the</span></span><br><span class="line"><span class="comment">//specified number of elements. The size may be omitted, in which case</span></span><br><span class="line"><span class="comment">//a small starting size is allocated.</span></span><br><span class="line"><span class="comment">//Channel: The channel&#x27;s buffer is initialized with the specified</span></span><br><span class="line"><span class="comment">//buffer capacity. If zero, or the size is omitted, the channel is</span></span><br><span class="line"><span class="comment">//unbuffered.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The new built-in function allocates memory. The first argument is a type,</span></span><br><span class="line"><span class="comment">// not a value, and the value returned is a pointer to a newly</span></span><br><span class="line"><span class="comment">// allocated zero value of that type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure><h3 id="func-maket-type-size-...integertype-type"><code>func make(t Type, size ...IntegerType) Type</code></h3><p><code>make</code> 函数用来分配和初始化指定类型的对象。使用过程中，有几点是需要注意的： * 第一个参数指定了要创建的对象的<strong>类型</strong>。这里的类型只允许：切片、map 和 channel * 返回值是指定类型的对象</p><h4 id="如果指定类型为切片">如果指定类型为切片</h4><p><strong>第二个参数 <code>size</code> 一定要指定，否则会编译错误。</strong> <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>) <span class="comment">// compile error:  missing len argument to make([]int)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\t%d\n&quot;</span>, a, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br></pre></td></tr></table></figure> 如果第二个参数只提供了一个整数值，那么表示该切片的长度。此时，该切片的容量和长度一致。 <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\t%d\n&quot;</span>, b, b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line"><span class="comment">// []int   [0 0 0 0]       4       4</span></span><br></pre></td></tr></table></figure> 如果提供了第二个整数值，则该值指定切片的容量。<strong>这个值不能比第一个整数值小</strong>，否则会出现编译错误。 <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\t%d\n&quot;</span>, c, c, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c))</span><br><span class="line"><span class="comment">// []int   [0 0 0 0 0]     5       6</span></span><br><span class="line">d := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// compile error: len larger than cap in make([]int)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\t%d\n&quot;</span>, d, d, <span class="built_in">len</span>(d), <span class="built_in">cap</span>(d))</span><br></pre></td></tr></table></figure> #### 如果指定类型为 map 如果类型为 map，则可以省略第二个参数。 <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\n&quot;</span>, a, a, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="comment">// map[string]bool map[]   0</span></span><br><span class="line">b := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>, <span class="number">4</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\n&quot;</span>, b, b, <span class="built_in">len</span>(b))</span><br><span class="line"><span class="comment">// map[string]bool map[]   0</span></span><br></pre></td></tr></table></figure> 如果出现第二个整数值，会出现编译错误： <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// compile error: too many arguments to make(map[string]bool)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\n&quot;</span>, c, c, <span class="built_in">len</span>(c))</span><br></pre></td></tr></table></figure> 值得一提的是，map 在使用前一定要进行初始化，否则会出现错误。而初始化可以使用 <code>make</code> 来实现。 <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">a[<span class="string">&quot;bb&quot;</span>] = <span class="literal">false</span> <span class="comment">// panic: assignment to entry in nil map</span></span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>, <span class="number">5</span>)</span><br><span class="line">b[<span class="string">&quot;aa&quot;</span>] = <span class="literal">true</span></span><br><span class="line">fmt.Println(b, <span class="built_in">len</span>(b)) <span class="comment">// map[aa:true] 1</span></span><br></pre></td></tr></table></figure> #### 如果指定类型为 channel 如果不指定第二个参数，则创建一个无缓冲的 channel。 <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\t%d\n&quot;</span>, a, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line"><span class="comment">// chan bool       0xc00008c060    0       0</span></span><br></pre></td></tr></table></figure> 如果指定第二个参数，并且该参数的值不为 0，则创建一个带缓冲的 channel，缓冲大小由该参数指定。 <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">4</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\t%d\n&quot;</span>, b, b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line"><span class="comment">// chan bool       0xc0000b6000    0       4</span></span><br></pre></td></tr></table></figure> 不能指定第二个整数值，否则会报错。 <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// compile error: too many arguments to make(chan bool)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%d\t%d\n&quot;</span>, c, c, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c))</span><br></pre></td></tr></table></figure> ### <code>func new(Type) *Type</code> <code>new</code> 函数也是用来分配内存的。但是，相对 <code>make</code> 而言，<code>new</code> 函数简单多了： * 只接受一个参数，指明类型。类型无限制。 * 分配指定类型的内存，并设置为该类型的零值。 * 返回指向这块新分配内存的<strong>指针</strong>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%v\n&quot;</span>, a, a, *a)</span><br><span class="line"><span class="comment">// *int    0xc0000b2008    0</span></span><br><span class="line">b := <span class="built_in">new</span>(<span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%v\n&quot;</span>, b, b, *b)</span><br><span class="line"><span class="comment">// *bool   0xc0000b2018    false</span></span><br><span class="line">c := <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%v\t%d\n&quot;</span>, c, c, *c, <span class="built_in">len</span>(*c))</span><br><span class="line"><span class="comment">// *map[string]bool        &amp;map[]  map[]   0</span></span><br><span class="line">d := <span class="built_in">new</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\t%v\t%v\t%d\n&quot;</span>, d, d, *d, <span class="built_in">cap</span>(*d))</span><br><span class="line"><span class="comment">// *chan bool      0xc0000ac028    &lt;nil&gt;   0</span></span><br></pre></td></tr></table></figure><h2 id="实现原理">实现原理</h2><h3 id="make"><code>make</code></h3><p>编译时，编译器会对类型进行类型检查。在这个阶段，会根据 <code>make</code> 的第一个参数，将 <code>make</code> 在语法树上对应的 <code>OMAKE</code> 节点转换成 <code>OMAKESLICE</code>（切片）、<code>OMAKEMAP</code>（map）、<code>OMAKECHAN</code>（channel），并对 <code>make</code> 函数的剩余参数进行合法性校验。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数在 src/cmd/compile/internal/gc/typecheck.go 中定义</span></span><br><span class="line"><span class="comment">// 用来检查常量、类型、函数声明以及变量赋值语句的类型</span></span><br><span class="line"><span class="comment">// 这里一个 Node 指的是语法树上的一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="keyword">int</span>)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">// op 在 src/cmd/compile/internal/gc/syntax.go 中定义</span></span><br><span class="line">    <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">    <span class="keyword">case</span> OMAKE:</span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line">        <span class="comment">// 获取 make 函数的参数列表</span></span><br><span class="line">args := n.List.Slice()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">yyerror(<span class="string">&quot;missing argument to make&quot;</span>)</span><br><span class="line">n.Type = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 获取第一个参数</span></span><br><span class="line">n.List.Set(<span class="literal">nil</span>)</span><br><span class="line">l := args[<span class="number">0</span>]</span><br><span class="line">l = typecheck(l, ctxType)</span><br><span class="line">t := l.Type</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">n.Type = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> t.Etype &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TSLICE: <span class="comment">// 切片类型</span></span><br><span class="line">            <span class="comment">// 进行参数校验</span></span><br><span class="line">            <span class="comment">// 参数数量校验：至少要有两个参数，最多三个参数</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(args) &#123;</span><br><span class="line">yyerror(<span class="string">&quot;missing len argument to make(%v)&quot;</span>, t)</span><br><span class="line">n.Type = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 这里的 l 就是长度，r 是容量（如果指定的话）</span></span><br><span class="line">            <span class="comment">// 参数合法性校验</span></span><br><span class="line">l = args[i]</span><br><span class="line">i++</span><br><span class="line">l = typecheck(l, ctxExpr)</span><br><span class="line"><span class="keyword">var</span> r *Node</span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(args) &#123;</span><br><span class="line">r = args[i]</span><br><span class="line">i++</span><br><span class="line">r = typecheck(r, ctxExpr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> l.Type == <span class="literal">nil</span> || (r != <span class="literal">nil</span> &amp;&amp; r.Type == <span class="literal">nil</span>) &#123;</span><br><span class="line">n.Type = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !checkmake(t, <span class="string">&quot;len&quot;</span>, l) || r != <span class="literal">nil</span> &amp;&amp; !checkmake(t, <span class="string">&quot;cap&quot;</span>, r) &#123;</span><br><span class="line">n.Type = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果指定了长度和容量，则要求 长度 &lt;= 容量</span></span><br><span class="line"><span class="keyword">if</span> Isconst(l, CTINT) &amp;&amp; r != <span class="literal">nil</span> &amp;&amp; Isconst(r, CTINT) &amp;&amp; l.Val().U.(*Mpint).Cmp(r.Val().U.(*Mpint)) &gt; <span class="number">0</span> &#123;</span><br><span class="line">yyerror(<span class="string">&quot;len larger than cap in make(%v)&quot;</span>, t)</span><br><span class="line">n.Type = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n.Left = l</span><br><span class="line">n.Right = r</span><br><span class="line">n.Op = OMAKESLICE <span class="comment">// 修改当前节点的操作 op</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TMAP: <span class="comment">// map 类型</span></span><br><span class="line">            <span class="comment">// 参数数量：最少一个，最多两个</span></span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(args) &#123;</span><br><span class="line">                <span class="comment">// 如果指定了第二个参数，则当成 map 的初始大小。</span></span><br><span class="line">l = args[i]</span><br><span class="line">i++</span><br><span class="line">l = typecheck(l, ctxExpr)</span><br><span class="line">l = defaultlit(l, types.Types[TINT])</span><br><span class="line"><span class="keyword">if</span> l.Type == <span class="literal">nil</span> &#123;</span><br><span class="line">n.Type = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !checkmake(t, <span class="string">&quot;size&quot;</span>, l) &#123;</span><br><span class="line">n.Type = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line">n.Left = l</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果没有指定第二个参数，则默认大小为 0</span></span><br><span class="line">n.Left = nodintconst(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">n.Op = OMAKEMAP <span class="comment">// 修改当前节点的操作 op</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> TCHAN: <span class="comment">// channel 类型</span></span><br><span class="line">            l = <span class="literal">nil</span></span><br><span class="line">            <span class="comment">// 参数数量：最少一个，最多两个</span></span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(args) &#123;</span><br><span class="line">                <span class="comment">// 如果有第二个参数，则表示该 channel 的缓冲区大小</span></span><br><span class="line">l = args[i]</span><br><span class="line">i++</span><br><span class="line">l = typecheck(l, ctxExpr)</span><br><span class="line">l = defaultlit(l, types.Types[TINT])</span><br><span class="line"><span class="keyword">if</span> l.Type == <span class="literal">nil</span> &#123;</span><br><span class="line">n.Type = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !checkmake(t, <span class="string">&quot;buffer&quot;</span>, l) &#123;</span><br><span class="line">n.Type = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line">n.Left = l</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有第二个参数，则默认 channel 缓冲区大小为 0</span></span><br><span class="line">n.Left = nodintconst(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">n.Op = OMAKECHAN <span class="comment">// 修改当前节点的操作 op</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(args) &#123; <span class="comment">// 如果参数个数不符合类型要求，则报错。</span></span><br><span class="line">yyerror(<span class="string">&quot;too many arguments to make(%v)&quot;</span>, t)</span><br><span class="line">n.Op = OMAKE</span><br><span class="line">n.Type = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n.Type = t</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/20200323183935.jpg" /></p><h3 id="new"><code>new</code></h3><p>编译时，在生成中间代码之前，需要对语法树中的一些节点进行替换。此时，对于 <code>new</code> 函数调用，也就是对应的 <code>ONEW</code> 节点，会将其转化成 <code>ONEWOBJ</code> 节点。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/gc/walk.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkexpr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> ONEW:</span><br><span class="line"><span class="keyword">if</span> n.Esc == EscNone &#123; <span class="comment">// 对于不会逃逸到堆上的。这也说明了 new 方法可能会在栈上分配</span></span><br><span class="line"><span class="keyword">if</span> n.Type.Elem().Width &gt;= maxImplicitStackVarSize &#123;</span><br><span class="line">Fatalf(<span class="string">&quot;large ONEW with EscNone: %v&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line">r := temp(n.Type.Elem())</span><br><span class="line">r = nod(OAS, r, <span class="literal">nil</span>) <span class="comment">// zero temp</span></span><br><span class="line">r = typecheck(r, ctxStmt)</span><br><span class="line">init.Append(r)</span><br><span class="line">r = nod(OADDR, r.Left, <span class="literal">nil</span>)</span><br><span class="line">r = typecheck(r, ctxExpr)</span><br><span class="line">n = r</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 转换成 ONEWOBJ 节点</span></span><br><span class="line">n = callnew(n.Type.Elem())</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callnew</span><span class="params">(t *types.Type)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    n := nod(ONEWOBJ, typename(t), <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 指针类型</span></span><br><span class="line">n.Type = types.NewPtr(t)</span><br><span class="line">n.SetTypecheck(<span class="number">1</span>)</span><br><span class="line">n.SetNonNil(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在接下来的 SSA 生成阶段，会根据申请空间的大小进行不同的处理： * 如果申请的大小为 0，则会返回一个表示空指针的 <code>zerobase</code> 变量 * 否则，则转换成 <code>runtime.newobject</code> 函数调用 <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/gc/ssa.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">expr</span><span class="params">(n *Node)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> ONEWOBJ:</span><br><span class="line"><span class="keyword">if</span> n.Type.Elem().Size() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s.newValue1A(ssa.OpAddr, n.Type, zerobaseSym, s.sb)</span><br><span class="line">&#125;</span><br><span class="line">typ := s.expr(n.Left)</span><br><span class="line">vv := s.rtcall(newobject, <span class="literal">true</span>, []*types.Type&#123;n.Type&#125;, typ)</span><br><span class="line">        <span class="keyword">return</span> vv[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>runtime.newobject</code> 函数在 <code>src/runtime/malloc.go</code> 中定义，它会根据传入类型所占用的空间大小，调用 <code>runtime.mallocgc</code> 函数，在堆上申请内存，然后返回指向这个内存空间的指针。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implementation of new builtin</span></span><br><span class="line"><span class="comment">// compiler (both frontend and SSA backend) knows the signature</span></span><br><span class="line"><span class="comment">// of this function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/20200323183936.jpg" /></p><h2 id="总结">总结</h2><ul><li><code>make</code> 和 <code>new</code> 的相同点：都是用来申请内存</li><li><code>make</code> 和 <code>new</code> 的不同点<ul><li><code>make</code> 只能用来创建类型为 slice / map / chan 的数据结构，返回的是指定类型的对象</li><li><code>new</code> 可以接受任意类型，返回的是指向这个类型的一个内存空间的指针</li></ul></li><li><code>make</code> 的实现过程：在类型检查阶段，根据第一个参数，将 <code>OMAKE</code> 节点转换成<code>OMAKESLICE</code>（切片）、<code>OMAKEMAP</code>（map）、<code>OMAKECHAN</code>（channel）</li><li><code>new</code> 的实现过程：在中间代码生成阶段，（当需要在堆上分配时）将 <code>ONEW</code> 节点转换成 <code>ONEWOBJ</code>，然后（当申请的大小不为0时）在运行时调用 <code>newobject</code> 函数，利用 <code>mallocgc</code> 函数来分配内存。</li></ul><h2 id="参考">参考</h2><ul><li><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/">make 和 new</a></li></ul>]]></content>
    
    
    <summary type="html">以下基于 go 1.14

基本使用
在 golang 中，内置函数 make 和 new 都是用来分配内存的。src/builtin/builtin.go 中对 make 和 new 的声明如下：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23


// The make built-in function allocates and initializes an object of type
// slice, map, or chan (only). Like new, the first argument is </summary>
    
    
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
    <category term="源码解析" scheme="http://ictar.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>我在极光两三事（一）</title>
    <link href="http://ictar.github.io/2019/11/02/experience-in-jg-part-1/"/>
    <id>http://ictar.github.io/2019/11/02/experience-in-jg-part-1/</id>
    <published>2019-11-02T08:03:01.000Z</published>
    <updated>2020-12-25T08:20:40.971Z</updated>
    
    <content type="html"><![CDATA[<p>2016.03.07 ~ 2019.11.01。</p><p>这是我在 JG 待的日子。</p><p>这是我离开 HW 想当小码农后面的第一家公司。谁曾想，一待就是近四年。</p><p>那个时候，我对互联网公司都是咋玩的一点概念都没有。稀稀拉拉地学了一段时间的 python，刷了几道 leetcode，然后稀里糊涂地就进了 JG。后来，面试我的同事打趣道，要求不高，性别女，会写 <code>hello workd</code> 就行了。</p><p>在某些时候，幸运女神肯定是站在我身边的。</p><p>一入职，狂补知识。</p><p>Restful API 是啥？nginx+uwsgi 要咋用呀？RabbitMQ 是什么鬼东西？这个统计用 shell 咋写？Lua 半天从入门到改线上代码了解一下。客户找上门来找不到问题查不出原因怎么破？</p><p>当你打开新世界的大门后，走进去，一切的一切对于你而言都是新的。努力搞明白向前走，滚是不可能的。毕竟路是自己选的，跪着也要走下去。</p><p>当然，也没那么惨。没什么是不能谷歌的。谷歌不到肯定是你关键字不对。实在找不到关键字，可以请教同事。大多数时候，周围的人都是很愿意帮你的。</p><p>于是啃了许多入门书，看了许多文档，慢慢地也能够称职地当个 python 小开发。再慢慢地，能够当场撸线上代码直接发布。不得不说，ansible 救了我无数次。而学习的过程，挺过最开始的苦逼后，就是充实的愉悦了。</p><p>美滋滋的日子没过多久，便面临了量上来了，机器不能无限往上堆。怎么办？重构呗。于是面前两条路，要么两眼一闭安于现状，要么转学另一门语言。</p><p>To be or not to be, that's a question.</p><p>其实也没得选，学呗。</p><p>被 python 惯坏的我，学起 golang 那是真的痛苦。当然，痛苦之处不是基本语法，而是并发。幸好学来即用，看了几天语法书，便开始撸了第一版 API golang 版本。重构第一个 API 的时候不熟？没事，还有第二个第三个第四个……，第 N 个。后来回去看自己撸的第一版代码，真丑呀！埋了一片雷，goroutine 泄露，空间随意申请…… 简直愧对后来接手的兄弟。但不得不说，其性能确实吊打 python。此外，当你学会了怎么玩好 goroutine 和 channel，并发编程就成了一件极其简单的事情。</p><p>当然，python 仍然是我最喜欢的语言。需要写点无伤大雅的小工具的时候，它依然是我的首选。毕竟不是哪都性能至上的。</p><p>于是乎，从 python 开发工程师到 golang 开发工程师，也就是一个 API 重构的事情。</p>]]></content>
    
    
    <summary type="html">2016.03.07 ~ 2019.11.01。

这是我在 JG 待的日子。

这是我离开 HW 想当小码农后面的第一家公司。谁曾想，一待就是近四年。

那个时候，我对互联网公司都是咋玩的一点概念都没有。稀稀拉拉地学了一段时间的 python，刷了几道 leetcode，然后稀里糊涂地就进了 JG。后来，面试我的同事打趣道，要求不高，性别女，会写 hello workd 就行了。

在某些时候，幸运女神肯定是站在我身边的。

一入职，狂补知识。

Restful API 是啥？nginx+uwsgi 要咋用呀？RabbitMQ 是什么鬼东西？这个统计用 shell 咋写？Lua 半天从入门到</summary>
    
    
    
    <category term="这就是生活" scheme="http://ictar.github.io/categories/%E8%BF%99%E5%B0%B1%E6%98%AF%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="经历" scheme="http://ictar.github.io/tags/%E7%BB%8F%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>译 | 在 Go 1.13 处理错误</title>
    <link href="http://ictar.github.io/2019/10/21/trans-go1-13-errors/"/>
    <id>http://ictar.github.io/2019/10/21/trans-go1-13-errors/</id>
    <published>2019-10-21T14:18:58.000Z</published>
    <updated>2020-12-25T08:20:40.962Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://blog.golang.org/go1.13-errors">Working with Errors in Go 1.13</a></p><hr /><h4 id="介绍">介绍</h4><p>Go 将<a href="https://blog.golang.org/errors-are-values">错误视为值</a>的这种行为在过去十年为我们服务良好。虽然标准库对错误的支持很少（只有 <code>errors.New</code> 和 <code>fmt.Errorf</code> 函数，它们产生仅包含消息的错误），但是内置的 <code>error</code> 接口允许 Go 程序员添加所需的任何信息。仅需一个实现 <code>Error</code> 方法的类型即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> QueryError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Query <span class="keyword">string</span></span><br><span class="line">    Err   error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *QueryError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.Query + <span class="string">&quot;: &quot;</span> + e.Err.Error() &#125;</span><br></pre></td></tr></table></figure><p>像这样的错误类型无处不在，而它们存储的信息差异很大，从时间戳到文件名再到服务器地址。通常，该信息包含另一个较低层次的错误，这个错误提供额外的上下文。</p><p>在 Go 代码中，一个错误包含另一个错误的模式非常普遍，以至于经过<a href="https://golang.org/issue/29934">广泛讨论</a>，Go 1.13 为其添加了明确的支持。本文描述了标准库提供的支持：<code>errors</code> 包中的三个新函数，以及用于 <code>fmt.Errorf</code> 的一个新格式化动词。</p><p>在详细描述更改之前，让我们回顾一下在 Go 的早期版本中是如何检查和构造错误的。</p><h4 id="go-1.13-之前的错误">Go 1.13 之前的错误</h4><h4 id="检查错误">检查错误</h4><p>Go 的错误是值。程序通过几种方式，基于这些值来做出决定。最常见的方式是将错误与 <code>nil</code> 进行比较，以查看操作是否失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// something went wrong</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时，我们会将错误与一个已知的 <em>标记</em> 值进行比较，以查看是否发生了特定的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrNotFound = errors.New(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == ErrNotFound &#123;</span><br><span class="line">    <span class="comment">// something wasn&#x27;t found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个错误值可以是任意类型，只要它满足了语言定义的 <code>error</code> 接口。程序可以使用类型断定或者类型选择，将错误值视为更具体的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NotFoundError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *NotFoundError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.Name + <span class="string">&quot;: not found&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e, ok := err.(*NotFoundError); ok &#123;</span><br><span class="line">    <span class="comment">// e.Name wasn&#x27;t found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加信息">添加信息</h4><p>通常，函数沿调用栈传递错误，同时向其添加信息，例如对错误发生时的情况的简要概述。一种简单的实现方式是构造一个包含上一个错误的文本的新错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decompress %v: %v&quot;</span>, name, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>fmt.Errorf</code> 创建新错误会丢弃除了文本外原始错误中的所有所有内容。正如从上面的 <code>QueryError</code> 所看到的，有时，我们可能想要定义一个包含底层错误的新的错误类型，并将其保留以供代码检查。下面又是 <code>QueryError</code>： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> QueryError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Query <span class="keyword">string</span></span><br><span class="line">    Err   error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 程序可以查看 <code>*QueryError</code> 的值，然后基于底层错误进行决策。有时，你会看到这被成为“解封”错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission &#123;</span><br><span class="line">    <span class="comment">// query failed because of a permission problem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准库中的 <code>os.PathError</code> 类型是一个错误包含另一个错误的又一个例子。</p><h4 id="go-1.13-中的错误">Go 1.13 中的错误</h4><h4 id="unwrap-方法">Unwrap 方法</h4><p>Go 1.13 为 <code>errors</code> 和 <code>fmt</code> 标准库包引入了新特性，以简化处理包含另一个错误的错误。其中最重要的是约定而不是更改：包含另一个错误的错误可以实现 <code>Unwrap</code> 方法，返回底层错误。如果 <code>e1.Unwrap()</code> 返回 <code>e2</code>，那么我们说 <code>e1</code> _封装__ 了 <code>e2</code>，并且你可以 <em>解封</em> <code>e1</code> 以获得 <code>e2</code>。</p><p>遵循此约定，我们可以为上面的 <code>QueryError</code> 类型提供一个 <code>Unwrap</code> 方法，该方法返回包含的错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *QueryError)</span> <span class="title">Unwrap</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> e.Err &#125;</span><br></pre></td></tr></table></figure><p>解封错误的结果可能本身包含 <code>Unwrap</code> 方法。我们称由重复解封产生的错误序列为 <em>错误链</em>。</p><h4 id="使用-is-和-as-函数检查错误">使用 Is 和 As 函数检查错误</h4><p>Go 1.13 的 <code>errors</code> 包包含了两个用来检查错误的新函数：<code>Is</code> 和 <code>As</code>。</p><p><code>errors.Is</code> 函数将一个错误与另一个值进行比较。 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Similar to:</span></span><br><span class="line"><span class="comment">//   if err == ErrNotFound &#123; … &#125;</span></span><br><span class="line"><span class="keyword">if</span> errors.Is(err, ErrNotFound) &#123;</span><br><span class="line">    <span class="comment">// something wasn&#x27;t found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 而 <code>As</code> 函数测试错误是否为特定的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Similar to:</span></span><br><span class="line"><span class="comment">//   if e, ok := err.(*QueryError); ok &#123; … &#125;</span></span><br><span class="line"><span class="keyword">var</span> e *QueryError</span><br><span class="line"><span class="keyword">if</span> errors.As(err, &amp;e) &#123;</span><br><span class="line">    <span class="comment">// err is a *QueryError, and e is set to the error&#x27;s value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最简单的情况下，<code>errors.Is</code> 函数的行为类似于与标记值的比较，而 <code>errors.As</code> 函数的行为类似于类型声明。但是，在处理封装错误时，这些函数会考虑错误链中的所有错误。我们再看看上面的例子，解封 <code>QueryError</code> 以检查底层错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission &#123;</span><br><span class="line">    <span class="comment">// query failed because of a permission problem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>errors.Is</code> 函数，我们可以这样写： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> errors.Is(err, ErrPermission) &#123;</span><br><span class="line">    <span class="comment">// err, or some error that it wraps, is a permission problem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>errors</code> 包还包含了一个新的 <code>Unwrap</code> 函数，它返回错误的 <code>Unwrap</code> 方法的调用结果，或者在错误没有 <code>Unwrap</code> 方法时返回 <code>nil</code>。通常，最好使用 <code>errors.Is</code> 或者 <code>errors.As</code>，因为这些函数将在一次调用中检查整个链。</p><h4 id="使用-w-封装错误">使用 %w 封装错误</h4><p>如前所述，通常我们会使用 <code>fmt.Errorf</code> 函数来给错误添加额外的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decompress %v: %v&quot;</span>, name, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Go 1.13 中，<code>fmt.Errorf</code> 函数支持一个新的动词：<code>%w</code>。当存在该动词时，<code>fmt.Errorf</code> 返回的错误将带有一个 <code>Unwrap</code> 方法，这个方法会返回 <code>%w</code> 的参数，而这个参数必须是一个错误。除此之外，<code>%w</code> 与 <code>%v</code> 相同。 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Return an error which unwraps to err.</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decompress %v: %w&quot;</span>, name, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 使用 <code>%w</code> 来封装错误也使其可用于 <code>errors.Is</code> 和 <code>errors.As</code>： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">err := fmt.Errorf(<span class="string">&quot;access denied: %w”, ErrPermission)</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">if errors.Is(err, ErrPermission) ...</span></span><br></pre></td></tr></table></figure> #### 是否封装</p><p>无论是通过 <code>fmt.Errorf</code> 还是实现自定义类型，当为错误添加额外的上下文时，你都需要确定新的错误是否应该封装原始错误。这个问题并没有唯一的答案。它取决于创建新错误的上下文。封装错误已将其暴露给调用者。当封装会暴露实现细节时，不要封装。</p><p>举个例子，假设有一个 <code>Parse</code> 函数，它从 <code>io.Reader</code> 读取复杂结构的数据。如果发生错误，我们希望可能报告错误发生代码行号和列号。如果在从 <code>io.Reader</code> 读取数据的时候发生了错误，那么我们会想要封装这个错误以检查底层错误。由于调用者给函数提供 <code>io.Reader</code>，因此，暴露它所产生的错误是有意义的。</p><p>相反，一个对数据库进行多次调用的函数可能不应该返回封装了这些调用某个结果的错误。如果函数使用的数据库是实现细节，那么暴露这些错误则违反了抽象。例如，如果你的包 <code>pkg</code> 的 <code>LookupUser</code> 函数使用了 Go 的 <code>database/sql</code> 包，那么它可能会遇到 <code>sql.ErrNoRows</code> 错误。如果你用 <code>fmt.Errorf("accessing DB: %v", err)</code> 来返回错误，那么调用者无法检查底层信息以查找 <code>sql.ErrNoRows</code>。但如果反过来，函数返回 <code>fmt.Errorf("accessing DB: %w", err)</code>，那么调用者可以合理地这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err := pkg.LookupUser(...)</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, sql.ErrNoRows) …</span><br></pre></td></tr></table></figure><p>此时，如果你不想影响到客户端的话，该函数必须始终返回 <code>sql.ErrNoRows</code>，即使切换到其他数据库包也必须返回。换句话说，封装一个错误会使得这个错误成为你的 API 的一部分。如果你不想将来把这个错误作为 API 的一部分来支持，则不应该封装这个错误。</p><p>重要的是记住，无论封装与否，错误文本都将相同。无论哪种方式，试图理解错误的 <em>人</em> 都将获得相同的信息；对于封装的选择是关于是否要为 <em>程序</em> 提供额外的信息，以便他们可以做出更明智的决定；还是隐瞒该信息以保留抽象层。</p><h4 id="利用-is-和-as-方法自定义错误测试">利用 Is 和 As 方法自定义错误测试</h4><p><code>errors.Is</code> 函数检查链中的每个错误，以查找与目标值匹配的错误。默认情况下，如果错误和目标相等，那么二者匹配。此外，链中的错误可能会通过实现 <code>Is</code> <em>方法</em> 来声明它与目标匹配。</p><p>例如，考虑这个受 <a href="https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html">Upspin 错误包</a> 启发的错误，它将错误与模板进行比较，并且仅考虑模板中那些非零字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Error <span class="keyword">struct</span> &#123;</span><br><span class="line">    Path <span class="keyword">string</span></span><br><span class="line">    User <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Error)</span> <span class="title">Is</span><span class="params">(target error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    t, ok := target.(*Error)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (e.Path == t.Path || t.Path == <span class="string">&quot;&quot;</span>) &amp;&amp;</span><br><span class="line">           (e.User == t.User || t.User == <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> errors.Is(err, &amp;Error&#123;User: <span class="string">&quot;someuser&quot;</span>&#125;) &#123;</span><br><span class="line">    <span class="comment">// err&#x27;s User field is &quot;someuser&quot;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>errors.As</code> 函数在 <code>As</code> 方法存在的情况下行为类似。</p><h4 id="错误和包-api">错误和包 API</h4><p>返回错误的包（大部分都会返回）应该描述程序员可能依赖的那些错误的属性。一个经过精心设计的包也要避免返回那些带有不应该依赖的属性的错误。</p><p>最简单的规范是说，操作成功或者失败，分别返回 nil 或者非 nil 的错误值。在许多情况下，不需要进一步的信息。</p><p>如果我们希望函数返回可识别的错误条件，例如“找不到项目”，那么我们可以返回封装了标记值的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrNotFound = errors.New(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FetchItem returns the named item.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If no item with the name exists, FetchItem returns an error</span></span><br><span class="line"><span class="comment">// wrapping ErrNotFound.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FetchItem</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Item, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> itemNotFound(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;%q: %w&quot;</span>, name, ErrNotFound)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有其他提供错误的模式：可以由调用方进行语义检查，例如直接返回标记值，特定类型或者可以使用判定函数检查的值。</p><p>在所有情况下，都应该注意，不要向用户公开内部细节。正如我们在上面的“是否要封装”中提到的那样，当你从另一个包中返回错误时，你应该将错误转换为不暴露底层错误的形式，除非你愿意将来再返回该特定错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// The *os.PathError returned by os.Open is an internal detail.</span></span><br><span class="line">    <span class="comment">// To avoid exposing it to the caller, repackage it as a new</span></span><br><span class="line">    <span class="comment">// error with the same text. We use the %v formatting verb, since</span></span><br><span class="line">    <span class="comment">// %w would permit the caller to unwrap the original *os.PathError.</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数被定义为返回一个封装某些标记或者类型的错误，请不要直接返回底层错误。 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrPermission = errors.New(<span class="string">&quot;permission denied&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoSomething returns an error wrapping ErrPermission if the user</span></span><br><span class="line"><span class="comment">// does not have permission to do something.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !userHasPermission() &#123;</span><br><span class="line">        <span class="comment">// If we return ErrPermission directly, callers might come</span></span><br><span class="line">        <span class="comment">// to depend on the exact error value, writing code like this:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//     if err := pkg.DoSomething(); err == pkg.ErrPermission &#123; … &#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// This will cause problems if we want to add additional</span></span><br><span class="line">        <span class="comment">// context to the error in the future. To avoid this, we</span></span><br><span class="line">        <span class="comment">// return an error wrapping the sentinel so that users must</span></span><br><span class="line">        <span class="comment">// always unwrap it:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//     if err := pkg.DoSomething(); errors.Is(err, pkg.ErrPermission) &#123; ... &#125;</span></span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w&quot;</span>, ErrPermission)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 总结</p><p>尽管我们所讨论的更改仅包含三个函数和一个格式化动词，但我们希望它们能对改善 Go 程序中的错误处理的方式有所帮助。我们希望通过封装来提供额外的上下文这种行为变得常见，从而帮助程序做出更好的决策，并帮助程序员更快地发现错误。</p><p>正如 Russ Cox 在他的 <a href="https://blog.golang.org/experiment">GopherCon 2019 主题演讲</a>中所说的那样，在通往 Go 2 的路上，我们实验、简化和发布。现在，我们已经发布了这些更改，期待接下来的实验。</p>]]></content>
    
    
    <summary type="html">原文：Working with Errors in Go 1.13




介绍
Go 将错误视为值的这种行为在过去十年为我们服务良好。虽然标准库对错误的支持很少（只有 errors.New 和 fmt.Errorf 函数，它们产生仅包含消息的错误），但是内置的 error 接口允许 Go 程序员添加所需的任何信息。仅需一个实现 Error 方法的类型即可：

1
2
3
4
5
6


type QueryError struct {
    Query string
    Err   error
}

func (e *QueryError) Error() string { retur</summary>
    
    
    
    <category term="golang" scheme="http://ictar.github.io/categories/golang/"/>
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
    <category term="没事翻着玩" scheme="http://ictar.github.io/tags/%E6%B2%A1%E4%BA%8B%E7%BF%BB%E7%9D%80%E7%8E%A9/"/>
    
  </entry>
  
  <entry>
    <title>译 | 如何优雅地关闭 Go 中的工作 goroutine</title>
    <link href="http://ictar.github.io/2019/10/19/trans-go-worker-cancellation/"/>
    <id>http://ictar.github.io/2019/10/19/trans-go-worker-cancellation/</id>
    <published>2019-10-19T02:49:44.000Z</published>
    <updated>2020-12-25T08:20:40.932Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://callistaenterprise.se/blogg/teknik/2019/10/05/go-worker-cancellation/">Go - graceful shutdown of worker goroutines</a></p><hr /><p>在这篇博文中，我们将看看 Go 程序的优雅关闭。这类 Go 程序有一些执行任务的工作 goroutine，要求在程序关闭之前，这些工作 goroutine 必须完成任务。</p><h1 id="介绍">介绍</h1><p>在一个最近的项目中，我们有一个使用场景：一个基于 Go 的微服务不断地消费另一个第三方库发出的事件。这些事件在调用外部服务之前，会进行一些处理。而外部服务处理每个请求的速度都相当慢，但另一方面，它能够处理许多并发请求。因此，我们实现了一个简单的 worker 池，将输入事件扇出为几个并发执行的 goroutine。</p><p>总的来说，它看起来像这样：</p><figure><img src="https://callistaenterprise.se/assets/blogg/goblog/other/blog-oct2019-1.png" alt="figure 1" /><figcaption aria-hidden="true">figure 1</figcaption></figure><p>然而，我们需要保证在该微服务关闭的时候，当前任何正在运行的对外部服务的请求必须完成，并且请求结果在我们的内部后端持久化。</p><h2 id="worker-池和终止信号处理">worker 池和终止信号处理</h2><p><a href="https://gobyexample.com/worker-pools">worker 池模式</a>是一个有名的关于 worker 池的 Go 模式。此外，还有大量关于如何进行<a href="https://gobyexample.com/signals">基于 SIGTERM 通知的优雅关闭</a>的例子。但我们意识到，我们的一些需求使得使用场景有点更复杂。</p><p>当程序接收到 SIGTERM 或者 SIGINT 信号（例如，因容器编排器缩容到一定数目的副本数而产生的）时，在终止整个程序之前，必须允许当前任何工作中的 worker goroutine 完成它们长期运行的工作。</p><p>让事情稍微复杂些的是，我们对生产者端的库没有任何控制权。一开始我们会注册一个回调函数，每当生产端的库有了一个（我们需要的）事件，就会调用这个回调函数。该库会处于阻塞状态，直到回调函数结束执行。然后，当有更多事件产生时，库会再次调用这个函数。</p><p>worker-pool 的诸多 goroutine 通过使用标准的“对 channel 进行 range 操作”结构，来不断处理事件，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workerFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> event := <span class="keyword">range</span> jobsChan &#123; <span class="comment">// 阻塞直到接收到一个事件，或者该 channel 被关闭。</span></span><br><span class="line">        <span class="comment">// handle the event...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这意味着，让一个 worker “结束”最干净的方式是关闭名为 “jobsChan” 的 channel。</p><h2 id="在生产者端进行关闭">在生产者端进行关闭</h2><p>你首先学到的关于在 Go 中关闭 channel 的第一件事情之一是，如果向已关闭的 channel 发送数据，程序就会 panic。这归结于一个非常简单的规则：</p><blockquote><p>“总是在生产者端关闭一个 channel（Always close a channel on the producer side）”</p></blockquote><p>不管怎样，什么是生产者端呢？嗯，一般是那个将事件发送到 channel 里的 <em>goroutine</em>： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callbackFunc</span><span class="params">(event <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">jobsChan&lt;-event</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 上面是我们的回调函数 callbackFunc，我们将其注册到外部库中，外部库就会将事件传给我们。<em>（为了让这些例子简单些，我将真实的事件替换为一个简单的整形，以作为负载。）</em></p><p>你要如何 <em>安全地</em> 保护上面的代码免于给已关闭的 channel 发送数据呢？一路沿着 Mutex、布尔型标志和 if 语句以确定是否一些_其他_ goroutine 关闭了 channel，以及控制是否应该允许发送数据，这并不简单。多留心潜在的竞争条件和不确定行为。</p><p>我们的解决方法是引入一个中间 channel 和一个内部的“消费者”，后者作为回调和任务 channel 之间的代理：</p><figure><img src="https://callistaenterprise.se/assets/blogg/goblog/other/blog-oct2019-2.png" alt="figure 2" /><figcaption aria-hidden="true">figure 2</figcaption></figure><p>消费者函数看起来像这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startConsumer</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Loop until a ctx.Done() is received. Note that select&#123;&#125; blocks until either case happens</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> event := &lt;-intermediateChan:</span><br><span class="line">                jobsChan &lt;- event</span><br><span class="line">            <span class="keyword">case</span> _ &lt;- ctx.Done():</span><br><span class="line">                <span class="built_in">close</span>(jobsChan)</span><br><span class="line">                <span class="keyword">return</span>             <span class="comment">// exit this function so we don&#x27;t consume anything more from the intermediate chan</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好了，等下。这个 “select” 和 “ctx.Done()” 是啥？</p><p>恕我直言，<a href="https://gobyexample.com/select">select</a> 语句是 Go 最神奇的东西之一。它允许多个 channel 的等待和协同。在这种情况下，我们或者会从中间 channel 那里收到事件，然后将其传到 jobsChan，又或者会从 <a href="https://golang.org/pkg/context/#WithCancel">context.Context</a> 接收到取消信号。</p><p>关闭 jobsChan 之后的 <em>return</em> 语句将让我们离开 for 循环和函数，这确保了 <em>不会有新事件被传递给</em> jobsChan,并且不会从 intermediateChan 消费到 <em>任何事件</em>。</p><p>所以，要么是传递事件到 jobsChan（worker 从这里消费），要么在作为生产者的 <em>同一个 goroutine 中</em> 关闭 jobsChan。</p><p>关闭 jobsChan 意味着消费端的所有 worker 将会停止遍历 jobsChan：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> event := <span class="keyword">range</span> jobsChan &#123; <span class="comment">// &lt;- on the close(jobsChan), all goroutines waiting for jobs here will exit the for-loop</span></span><br><span class="line">    <span class="comment">// handle the event...</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="发出取消信号">发出取消信号</h2><p>等待 Go 程序退出是一种有名的模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ... rest of program ...</span><br><span class="line">    </span><br><span class="line">    termChan := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">    &lt;-termChan <span class="comment">// Blocks here until either SIGINT or SIGTERM is received.</span></span><br><span class="line">    <span class="comment">// 接下来呢？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 “接下来呢？” 这一部分，捕获到 SIGINT 或者 SIGTERM 后，主 goroutine 恢复执行。我们需要告诉将事件从 intermediateChan 传到 jobsChan 的消费者，跨 goroutine 边界关闭 jobsChan。</p><p>再次，使用 Mutex 和条件语句来解决这个问题，技术上是可行的，但是相当难搞并且容易出错。作为替代，我们会利用前面提及的 context.Context 的取消支持。</p><p>在 <em>func main()</em> 的某个地方，我们设置了一个带取消支持的根 background context：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancelFunc := context.WithCancel(ctx.Background())</span><br><span class="line">    <span class="comment">// ... some omitted code ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> startConsumer(ctx) <span class="comment">// pass the cancellable context to the consumer function</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... some more omitted code ...</span></span><br><span class="line">    &lt;-termChan</span><br><span class="line">    </span><br><span class="line">    cancelFunc() <span class="comment">// call the cancelfunc to notify the consumer it&#x27;s time to shut stuff down.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这就是 <em>&lt; -ctx.Done()</em> 这一 select case 如何被调用的，它开始优雅拆卸 channel 和 worker。</p><h2 id="使用-waitgroup">使用 WaitGroup</h2><p>上面这个方法只有一个问题：调用 <em>cancelFunc()</em> 后，程序会立即退出，这意味着，正在动态调用中的工作 goroutine 将没有时间执行完毕，这使得我们系统中的处理有可能处于中间态。</p><p>我们需要停止关闭，直到所有的 worker 都报告说它们完成了工作。现在，我们进入 <a href="https://golang.org/pkg/sync/#WaitGroup">sync.WaitGroup</a>，它允许我们等待任意数目的 goroutine 结束！</p><p>当启动 worker 时，我们传递一个指向在 <em>func main()</em> 中创建的 WaitGroup 的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numberOfWorkers = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ... omitted ...</span></span><br><span class="line">    wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(numberOfWorkers)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Start [workerPoolSize] workers</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerPoolSize; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> workerFunc(wg)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... more omitted stuff ...</span></span><br><span class="line">    </span><br><span class="line">    &lt;-termChan    <span class="comment">// wait for SIGINT / SIGTERM</span></span><br><span class="line">    cancelFunc()  <span class="comment">// send the shutdown signal through the context.Context</span></span><br><span class="line">    wg.Wait()     <span class="comment">// program will wait here until all worker goroutines have reported that they&#x27;re done</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Workers done, shutting down!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这会稍微改变我们的 worker 启动函数： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workerFunc</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done() <span class="comment">// Mark this goroutine as done! once the function exits</span></span><br><span class="line">    <span class="keyword">for</span> event := <span class="keyword">range</span> jobsChan &#123;</span><br><span class="line">        <span class="comment">// handle the event...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> <em>wg.Done()</em> 将 waitgroup 减一，一旦内部计数器变成 0，那么主 goroutine 将继续执行 <em>wg.Wait()</em> 之下的语句。这就完成了优雅关闭！</p><h3 id="运行">运行</h3><p>最终程序的源代码在下一个部分。在此其中，我添加了一些日志，这样就能看看该过程发生了什么。</p><p>下面是一个带有 4 个工作 goroutine 的程序的执行输出，这里，我使用 Ctrl+C 来停止程序： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span> </span><br><span class="line">  Worker <span class="number">3</span> starting</span><br><span class="line">  Worker <span class="number">2</span> starting</span><br><span class="line">  Worker <span class="number">1</span> starting</span><br><span class="line">  Worker <span class="number">0</span> starting</span><br><span class="line">  Worker <span class="number">3</span> finished processing job <span class="number">0</span></span><br><span class="line">  Worker <span class="number">0</span> finished processing job <span class="number">3</span></span><br><span class="line">  ^C*********************************     &lt;-- HERE I PRESS CTRL+C</span><br><span class="line">  Shutdown signal received</span><br><span class="line">  *********************************</span><br><span class="line">  Worker <span class="number">3</span> finished processing job <span class="number">4</span></span><br><span class="line">  Worker <span class="number">2</span> finished processing job <span class="number">1</span></span><br><span class="line">  Worker <span class="number">1</span> finished processing job <span class="number">2</span></span><br><span class="line">  Consumer received cancellation signal, closing jobsChan!   &lt;-- Here, the consumer receives the &lt;-ctx.Done()</span><br><span class="line">  Worker <span class="number">3</span> finished processing job <span class="number">6</span></span><br><span class="line">  Worker <span class="number">0</span> finished processing job <span class="number">5</span></span><br><span class="line">  Worker <span class="number">1</span> finished processing job <span class="number">8</span></span><br><span class="line">  Worker <span class="number">2</span> finished processing job <span class="number">7</span></span><br><span class="line">  Worker <span class="number">0</span> finished processing job <span class="number">10</span></span><br><span class="line">  Worker <span class="number">0</span> interrupted                    &lt;-- Worker <span class="number">0</span> has finished job #<span class="number">10</span>, <span class="number">3</span> left</span><br><span class="line">  Worker <span class="number">2</span> finished processing job <span class="number">12</span></span><br><span class="line">  Worker <span class="number">2</span> interrupted                    &lt;-- Worker <span class="number">2</span> has finished job #<span class="number">12</span>, <span class="number">2</span> left</span><br><span class="line">  Worker <span class="number">3</span> finished processing job <span class="number">9</span></span><br><span class="line">  Worker <span class="number">3</span> interrupted                    &lt;-- Worker <span class="number">3</span> has finished job #<span class="number">9</span>, <span class="number">1</span> left</span><br><span class="line">  Worker <span class="number">1</span> finished processing job <span class="number">11</span></span><br><span class="line">  Worker <span class="number">1</span> interrupted                    &lt;-- Worker <span class="number">1</span> has finished job #<span class="number">11</span>, all done</span><br><span class="line">  All workers done, shutting down!</span><br><span class="line"></span><br></pre></td></tr></table></figure> 有人可能会观察到，消费者接收到 <em>&lt; -ctx.Done()</em> 的时间点实际上是不确定的，这是因为 Go 运行时调度 channel 上的通信到 select 语句的方法。Go 规范是这样说的： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“如果可以处理一个或多个通信，那么选择进行处理的那个 chanel 是通过统一的伪随机选择的。（If one or more of the communications can proceed, a single one that can proceed is chosen via a uniform pseudo-random selection）”。</span><br><span class="line"></span><br></pre></td></tr></table></figure> 这就是为什么即使在按下 CTRL+C 之后，任务也可以被传给 worker。</p><p>另一个特别的事情是，似乎即使在关闭了 jobsChan <em>之后</em>，任务（任务 9-12）还是被传给 worker 了。恩，它们实际是在该 channel 被关闭 <em>之前</em> 被传给 worker 的。这个现象会发生是因为我们使用了一个带有 4 个“槽” 的缓存 channel。这意味着，假定我们第三方生产者以比我们的 worker 可以处理的速度更快地不断传递新事件，如果所有四个 worker 都从 channel 中消费了一个任务并且处理它们，那么该 channel 里就可能会有四个新的事件正等待被消费。关闭 channel 并不会影响那些已经缓存到 channel 里的数据 —— Go 允许消费者消费它们。</p><p>如果我们将 jobsChan 修改为无缓存的： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jobsChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure> 然后再次运行： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">.... omitted <span class="keyword">for</span> brevity ....</span><br><span class="line">^C*********************************</span><br><span class="line">Shutdown signal received</span><br><span class="line">*********************************</span><br><span class="line">Worker <span class="number">3</span> finished processing job <span class="number">3</span></span><br><span class="line">Worker <span class="number">3</span> started job <span class="number">5</span></span><br><span class="line">Worker <span class="number">0</span> finished processing job <span class="number">4</span></span><br><span class="line">Worker <span class="number">0</span> started job <span class="number">6</span></span><br><span class="line">Consumer received cancellation signal, closing jobsChan! &lt;-- again, it may take some time until the consumer is handed &lt;-ctx.Done()</span><br><span class="line">Consumer closed jobsChan</span><br><span class="line">Worker <span class="number">1</span> finished processing job <span class="number">1</span>     &lt;-- From here on, we see that each worker finishes exactly one job before being interrupted.</span><br><span class="line">Worker <span class="number">1</span> interrupted</span><br><span class="line">Worker <span class="number">2</span> finished processing job <span class="number">2</span></span><br><span class="line">Worker <span class="number">2</span> interrupted</span><br><span class="line">Worker <span class="number">0</span> finished processing job <span class="number">6</span></span><br><span class="line">Worker <span class="number">0</span> interrupted</span><br><span class="line">Worker <span class="number">3</span> finished processing job <span class="number">5</span></span><br><span class="line">Worker <span class="number">3</span> interrupted</span><br><span class="line">All workers done, shutting down!</span><br><span class="line"></span><br></pre></td></tr></table></figure> 这一次，在 channel 关闭后，我们就没有看到任何“不期望的”任务被 worker 消费了。然而，让 channel 缓存跟 worker 数相同的数据，是在不必要拖慢生产端的情况下，让 worker 保持处理数据的常见优化手法。</p><h1 id="完整的程序">完整的程序</h1><p>上面的代码片段在某些地方进行了简化，以使得它们尽可能简洁。带有某些结构以封装和模拟第三方生产者的完整程序如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;os/signal&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> workerPoolSize = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建消费者</span></span><br><span class="line">consumer := Consumer&#123;</span><br><span class="line">ingestChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line">jobsChan:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, workerPoolSize),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟外部库：每秒发送 10 个事件</span></span><br><span class="line">producer := Producer&#123;callbackFunc: consumer.callbackFunc&#125;</span><br><span class="line"><span class="keyword">go</span> producer.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置取消 context 和 waitgroup</span></span><br><span class="line">ctx, cancelFunc := context.WithCancel(context.Background())</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递取消 context 以启动消费者</span></span><br><span class="line"><span class="keyword">go</span> consumer.startConsumer(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 worker，并添加 [workerPoolSize] 到 WaitGroup</span></span><br><span class="line">wg.Add(workerPoolSize)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerPoolSize; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> consumer.workerFunc(wg, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理终止信号，并等待 termChan 信号</span></span><br><span class="line">termChan := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line"></span><br><span class="line">&lt;-termChan         <span class="comment">// 这里阻塞直到接收到信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理关闭</span></span><br><span class="line">fmt.Println(<span class="string">&quot;*********************************\nShutdown signal received\n*********************************&quot;</span>)</span><br><span class="line">cancelFunc()       <span class="comment">// 向 context.Context 发送取消信号</span></span><br><span class="line">wg.Wait()          <span class="comment">// 这里阻塞直至所有 worker 完成</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;All workers done, shutting down!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消费者结构： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -- 从这里起，下面是 Consumer！</span></span><br><span class="line"><span class="keyword">type</span> Consumer <span class="keyword">struct</span> &#123;</span><br><span class="line">ingestChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">jobsChan   <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每当外部库传递一个事件给我们，就会调用 callbackFunc。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Consumer)</span> <span class="title">callbackFunc</span><span class="params">(event <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">c.ingestChan &lt;- event</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// workerFunc 启动一个 worker 函数，它会遍历 jobsChan，直到该 channel 关闭。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Consumer)</span> <span class="title">workerFunc</span><span class="params">(wg *sync.WaitGroup, index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d starting\n&quot;</span>, index)</span><br><span class="line"><span class="keyword">for</span> eventIndex := <span class="keyword">range</span> c.jobsChan &#123;</span><br><span class="line"><span class="comment">// 模拟工作执行 1 ~ 3 秒</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d started job %d\n&quot;</span>, index, eventIndex)</span><br><span class="line">time.Sleep(time.Millisecond * time.Duration(<span class="number">1000</span>+rand.Intn(<span class="number">2000</span>)))</span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d finished processing job %d\n&quot;</span>, index, eventIndex)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d interrupted\n&quot;</span>, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// startConsumer 作为 ingestChan 和 jobsChan 之间的代理，使用 select 语句以支持优雅关闭。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Consumer)</span> <span class="title">startConsumer</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> job := &lt;-c.ingestChan:</span><br><span class="line">c.jobsChan &lt;- job</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;Consumer received cancellation signal, closing jobsChan!&quot;</span>)</span><br><span class="line"><span class="built_in">close</span>(c.jobsChan)</span><br><span class="line">fmt.Println(<span class="string">&quot;Consumer closed jobsChan&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 最后，模拟外部库的生产者结构： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -- Producer 模拟一个外部库，每 100ms 有新数据时simulates an external library that invokes the </span></span><br><span class="line"><span class="comment">// 它会调用注册的回调函数。</span></span><br><span class="line"><span class="keyword">type</span> Producer <span class="keyword">struct</span> &#123;</span><br><span class="line">    callbackFunc <span class="function"><span class="keyword">func</span><span class="params">(event <span class="keyword">int</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Producer)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    eventIndex := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p.callbackFunc(eventIndex)</span><br><span class="line">        eventIndex++</span><br><span class="line">        time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> # 总结</p><p>我希望这篇小博文提供了一个简单的例子，说明了基于 goroutine 的 worker 池，以及如何使用基于 context 的取消、WaitGroup 和生产端 channel 关闭，来优雅关闭这些 goroutine。</p>]]></content>
    
    
    <summary type="html">原文：Go - graceful shutdown of worker goroutines




在这篇博文中，我们将看看 Go 程序的优雅关闭。这类 Go 程序有一些执行任务的工作 goroutine，要求在程序关闭之前，这些工作 goroutine 必须完成任务。

介绍
在一个最近的项目中，我们有一个使用场景：一个基于 Go 的微服务不断地消费另一个第三方库发出的事件。这些事件在调用外部服务之前，会进行一些处理。而外部服务处理每个请求的速度都相当慢，但另一方面，它能够处理许多并发请求。因此，我们实现了一个简单的 worker 池，将输入事件扇出为几个并发执行的 goroutine。
</summary>
    
    
    
    <category term="golang" scheme="http://ictar.github.io/categories/golang/"/>
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
    <category term="没事翻着玩" scheme="http://ictar.github.io/tags/%E6%B2%A1%E4%BA%8B%E7%BF%BB%E7%9D%80%E7%8E%A9/"/>
    
  </entry>
  
  <entry>
    <title>Golang/JSON | DisallowUnknownFields 和自定义结构的序列化方法</title>
    <link href="http://ictar.github.io/2019/05/15/golang-json-custom-marshal-unmarshal/"/>
    <id>http://ictar.github.io/2019/05/15/golang-json-custom-marshal-unmarshal/</id>
    <published>2019-05-15T13:11:36.000Z</published>
    <updated>2020-12-25T08:20:40.997Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 中，对于自定义结构的序列化和反序列化存在几个问题。</p><h2 id="q1如何保证待反序列化的字符串只包含所定义的结构中的字段">Q1：如何保证待反序列化的字符串只包含所定义的结构中的字段？</h2><p>从 <strong>Go 1.10</strong> 起，标准库 <code>encoding/json</code> 提供了方法 <a href="https://golang.org/pkg/encoding/json/#Decoder.DisallowUnknownFields"><code>func (*Decoder) DisallowUnknownFields</code></a>。调用该方法表示，当目标是一个结构，并且输入流中包含任何<em>不匹配</em>该结构的非忽略的导出字段时，<code>Decoder</code> 会返回一个错误。</p><p>举个例子： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> jsonStream = <span class="string">`&#123;&quot;Name&quot;: &quot;Ed&quot;, &quot;Text&quot;: &quot;Knock knock.&quot;&#125;`</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">dec := json.NewDecoder(strings.NewReader(jsonStream))</span><br><span class="line">dec.DisallowUnknownFields()</span><br><span class="line"><span class="keyword">var</span> m Message</span><br><span class="line">err := dec.Decode(&amp;m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, m.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在上面的例子中，<code>jsonStream</code> 定义了一个结构 <code>Message</code> 不存在的字段 <code>"Text"</code>。接下来，声明一个 <code>Decoder</code>，并且调用 <code>DisallowUnknownFields</code> 方法。</p><p><a href="https://play.golang.org/p/lubiUUVHlG1">运行</a>会发现，反序列化失败： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2009</span>/<span class="number">11</span>/<span class="number">10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> json: unknown field <span class="string">&quot;Text&quot;</span></span><br></pre></td></tr></table></figure> 如果结构 <code>Message</code> 中有一个忽略的导出 <code>Text</code> 字段，又会发生什么呢？稍微改动下上面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> jsonStream = <span class="string">`&#123;&quot;Name&quot;: &quot;Ed&quot;, &quot;Text&quot;: &quot;Knock knock.&quot;&#125;`</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Text <span class="keyword">string</span> <span class="string">`json:&quot;-&quot;`</span> <span class="comment">// 增加一个字段定义</span></span><br><span class="line">&#125;</span><br><span class="line">dec := json.NewDecoder(strings.NewReader(jsonStream))</span><br><span class="line">dec.DisallowUnknownFields()</span><br><span class="line"><span class="keyword">var</span> m Message</span><br><span class="line">err := dec.Decode(&amp;m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, m.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://play.golang.org/p/590Y_ajap11">运行</a>，得到同样的错误： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2009</span>/<span class="number">11</span>/<span class="number">10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> json: unknown field <span class="string">&quot;Text&quot;</span></span><br></pre></td></tr></table></figure> 同理，如果 <code>Text</code> 字段变成未导出字段，也会出现相同的报错： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> jsonStream = <span class="string">`&#123;&quot;Name&quot;: &quot;Ed&quot;, &quot;Text&quot;: &quot;Knock knock.&quot;&#125;`</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">text <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">dec := json.NewDecoder(strings.NewReader(jsonStream))</span><br><span class="line">dec.DisallowUnknownFields()</span><br><span class="line"><span class="keyword">var</span> m Message</span><br><span class="line">err := dec.Decode(&amp;m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, m.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <a href="https://play.golang.org/p/BmT5xEpTyu5">运行</a> 验证一下吧。</p><h2 id="q2如何判断某个字段是否存在">Q2：如何判断某个字段是否存在？</h2><p>Go 结构的零值导致了我们无法通过判断字段值是否等于某个值来确定 JSON 字符串中是否存在某个字段。</p><p>此外，如果将字段类型定义为指针的话，则无法区分该字段的值就是 <code>null</code> 的场景。</p><p>当然，我们并非无计可施。<code>encoding/json</code> 允许我们为自定义结构定义序列化和反序列化方法。只要分别实现 <code>MarshalJSON() ([]byte, error)</code> 和 <code>UnmarshalJSON([]byte) error</code> 方法即可。</p><p>来看下如何通过 <code>MarshalJSON</code> 方法来判断某个字段是否存在： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Int <span class="keyword">struct</span> &#123;</span><br><span class="line">Valid <span class="keyword">bool</span> <span class="comment">// 表示是否为有效值</span></span><br><span class="line">Set   <span class="keyword">bool</span> <span class="comment">// 表示是否设置</span></span><br><span class="line">Value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义反序列化方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *Int)</span> <span class="title">UnmarshalJSON</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果调用了该方法，说明设置了该值</span></span><br><span class="line">i.Set = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">string</span>(data) == <span class="string">&quot;null&quot;</span> &#123;</span><br><span class="line"><span class="comment">// 表明该字段的值为 null</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> temp <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(data, &amp;temp); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">i.Value = temp</span><br><span class="line">i.Valid = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义序列化方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Int)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">byte</span>(strconv.Itoa(i.Value)), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在上面的例子中，我们定义了一个结构体 <code>Int</code> 来替代基本结构 <code>int</code>。并且定义了两个字段来表示是否设置及是否有效。这样，在序列化之后，我们就可以通过这两个字段来检查了。</p><p>此外，因为不希望序列化后出现这两个布尔值，因此还需要自定义序列化方法 <code>MarshalJSON</code>。</p><p>下面，简单测试一下： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123; Val Int &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(bytes []<span class="keyword">byte</span>)</span> <span class="params">(A, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">struct</span>&#123; Val Int &#125;</span><br><span class="line">err := json.Unmarshal(bytes, &amp;a)</span><br><span class="line"><span class="keyword">return</span> a, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">notSet := []<span class="keyword">byte</span>(<span class="string">`&#123;&#125;`</span>)</span><br><span class="line">setNull := []<span class="keyword">byte</span>(<span class="string">`&#123;&quot;val&quot;: null&#125;`</span>)</span><br><span class="line">setValid := []<span class="keyword">byte</span>(<span class="string">`&#123;&quot;val&quot;: 123&#125;`</span>)</span><br><span class="line">setWrongType := []<span class="keyword">byte</span>(<span class="string">`&#123;&quot;val&quot;: &quot;123&quot;&#125;`</span>)</span><br><span class="line"></span><br><span class="line">a, err := do(notSet)</span><br><span class="line">log.Printf(<span class="string">&quot;NotSet|set:%t|valid:%t|err: %v\n&quot;</span>, a.Val.Set, a.Val.Valid, err)</span><br><span class="line"></span><br><span class="line">a, err = do(setNull)</span><br><span class="line">log.Printf(<span class="string">&quot;SetNull|set:%t|valid:%t|err: %v\n&quot;</span>, a.Val.Set, a.Val.Valid, err)</span><br><span class="line"></span><br><span class="line">a, err = do(setValid)</span><br><span class="line">log.Printf(<span class="string">&quot;SetValid|set:%t|valid:%t|err: %v\n&quot;</span>, a.Val.Set, a.Val.Valid, err)</span><br><span class="line"></span><br><span class="line">a, err = do(setWrongType)</span><br><span class="line">log.Printf(<span class="string">&quot;SetWrongType|set:%t|valid:%t|err: %v\n&quot;</span>, a.Val.Set, a.Val.Valid, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 可以<a href="https://play.golang.org/p/ILMMdgIVlAg">运行</a>一下查看结果。</p><h2 id="q3如何让-omitempty-选项对自定义结构体生效">Q3：如何让 <code>omitempty</code> 选项对自定义结构体生效？</h2><p>如果对字段使用了 <code>omitempty</code> 选项，那么在序列化过程中，如果该字段具有零值（即 false、0、nil 指针、nil 接口值和任何空数组、空 slice、空 map 或者空字符串），那么会忽略该字段。</p><p>但是，当前最新的 Go 版本（Go）下，这个选项对于自定义结构是不生效的。</p><p>举个例子： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> Text <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">int</span></span><br><span class="line">Content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Content Text<span class="string">`json:&quot;content,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m Message</span><br><span class="line">m.Name = <span class="string">&quot;test&quot;</span></span><br><span class="line">bytes, err := json.Marshal(m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="keyword">string</span>(bytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在上面的例子中，我们定义了一个结构体 <code>Message</code>，它包含一个字段 <code>Content</code>，类型为自定义的 <code>Text</code>，并打上 <code>omitempty</code> 选项。然后，声明一个实例并给 <code>Message</code> 的另一个字段赋值。接着序列化该实例。</p><p>期待序列化结果为 <code>&#123;"Name":"test"&#125;</code>。但是<a href="https://play.golang.org/p/PFtRDIH_TAr">运行</a>之后却得到以下结果： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;Name&quot;</span>:<span class="string">&quot;test&quot;</span>,<span class="attr">&quot;content&quot;</span>:&#123;<span class="attr">&quot;ID&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;Content&quot;</span>:<span class="string">&quot;&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure> 查看 <code>encoding/json</code> 相关代码会发现，该库在字段使用了 <code>omitempty</code> 选项时，对于空值的判断确实仅限于文档中描述的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// encode.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmptyValue</span><span class="params">(v reflect.Value)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.Array, reflect.Map, reflect.Slice, reflect.String: <span class="comment">// 空数组、空 Map、空 slice、空字符串</span></span><br><span class="line"><span class="keyword">return</span> v.Len() == <span class="number">0</span></span><br><span class="line"><span class="keyword">case</span> reflect.Bool: <span class="comment">// false</span></span><br><span class="line"><span class="keyword">return</span> !v.Bool()</span><br><span class="line"><span class="keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">return</span> v.Int() == <span class="number">0</span></span><br><span class="line"><span class="keyword">case</span> reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr: <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">return</span> v.Uint() == <span class="number">0</span></span><br><span class="line"><span class="keyword">case</span> reflect.Float32, reflect.Float64: <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">return</span> v.Float() == <span class="number">0</span></span><br><span class="line"><span class="keyword">case</span> reflect.Interface, reflect.Ptr: <span class="comment">// nil 指针、nil interface 值</span></span><br><span class="line"><span class="keyword">return</span> v.IsNil()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，此判断逻辑不适用于自定义结构（非指针的情况下）。并且，<strong>除了在使用自定义结构的时候使用指针</strong>，没有其他任何方法可以让 <code>omitempty</code> 选项对自定义结构体生效！！</p><p><a href="https://github.com/golang/go/issues/11939">Issue 11939</a> 提出并跟踪了这个问题。这个 Issue 从 2015 年 7 月份提出至今仍未有确定的解决时间 (`д´)</p><h2 id="参考">参考</h2><ul><li><a href="https://golang.org/pkg/encoding/json/">encoding/json</a></li></ul>]]></content>
    
    
    <summary type="html">在 Go 中，对于自定义结构的序列化和反序列化存在几个问题。

Q1：如何保证待反序列化的字符串只包含所定义的结构中的字段？
从 Go 1.10 起，标准库 encoding/json 提供了方法 func (*Decoder) DisallowUnknownFields。调用该方法表示，当目标是一个结构，并且输入流中包含任何不匹配该结构的非忽略的导出字段时，Decoder 会返回一个错误。

举个例子： 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23


package main

import (
	&quot;encoding</summary>
    
    
    
    <category term="golang" scheme="http://ictar.github.io/categories/golang/"/>
    
    
    <category term="Golang" scheme="http://ictar.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>译|Go 的工具箱综述</title>
    <link href="http://ictar.github.io/2019/05/14/an-overview-of-go-tooling/"/>
    <id>http://ictar.github.io/2019/05/14/an-overview-of-go-tooling/</id>
    <published>2019-05-14T12:31:01.000Z</published>
    <updated>2020-12-25T08:20:41.011Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://www.alexedwards.net/blog/an-overview-of-go-tooling">An Overview of Go's Tooling</a></p><hr /><p>偶尔会有人问我，<em>“为什么你会喜欢用 Go 呢？”</em> 在我的回答中，有一个我经常提到的原因，那就是和 Go 一起存在的那些好用的工具，并且它们是作为 <code>go</code> 命令的一部分存在的。其中有一些工具我每天都在用，例如 <code>go fmt</code> 和 <code>go build</code>。而其他像 <code>go tool pprof</code> 这样的工具，则只在解决特定问题的时候会用到。但是无论如何，我很感激它们，让我的项目管理和维护变得更加容易。</p><p>在这篇文章中，我希望说明一些我认为最有用的工具的背景和使用场景。更重要的是，解释清楚可以如何将其用于典型项目的工作流程中。如果你刚接触 Go，那么，我希望这篇文章可以给你一个良好的开始。</p><p>或者，如果你已经使用 Go 一段时间了，那么你可能已经对这些东西很熟悉了，但是，我希望你仍旧可以从本文中发现一个从前不知道的命令或者标志 : )</p><p>本文基于 Go 1.12，并且假设你的项目已经 <a href="https://github.com/golang/go/wiki/Modules#quick-start">启用了 modules</a>。</p><h2 id="安装工具">安装工具</h2><p>在这篇文章中，我将主要关注作为 <code>go</code> 命令一部分的工具。但是，我还会提到那些不属于标准的 Go 1.12 版本的工具。</p><p>要在使用 Go 1.12 的情况下安装这些工具，首先，你需要确保当前位置_不在_启用 module 的目录下（通常，我会切到 <code>/tmp</code>）。然后，你就可以使用 <code>GO111MODULE=on go get</code> 命令来安装工具了。例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /tmp</span><br><span class="line">$ GO111MODULE=on go get golang.org<span class="regexp">/x/</span>tools<span class="regexp">/cmd/</span>stress</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的操作将会下载相关的包和依赖项，构建可执行文件，然后将其添加到你的 <code>GOBIN</code> 目录下。如果没有显式设置 <code>GOBIN</code> 目录，那么，可执行文件将会被添加到 <code>GOPATH/bin</code> 目录下。无论何种方式，都应该保证系统路径中有相应的目录。</p><p>注意：这个过程有点笨重，希望在未来的 Go 版本中有所改进。<a href="https://github.com/golang/go/issues/30515">Issue 30515</a> 正在跟踪关于这件事的讨论。</p><h2 id="查看环境信息">查看环境信息</h2><p>可以使用 <code>go env</code> 工具来展示当前 Go 操作环境的信息。当你正在使用不熟悉的机器的时候，这个命令尤为有用。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ go env</span><br><span class="line">GOARCH=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">GOBIN=<span class="string">&quot;&quot;</span></span><br><span class="line">GOCACHE=<span class="string">&quot;/home/alex/.cache/go-build&quot;</span></span><br><span class="line">GOEXE=<span class="string">&quot;&quot;</span></span><br><span class="line">GOFLAGS=<span class="string">&quot;&quot;</span></span><br><span class="line">GOHOSTARCH=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">GOHOSTOS=<span class="string">&quot;linux&quot;</span></span><br><span class="line">GOOS=<span class="string">&quot;linux&quot;</span></span><br><span class="line">GOPATH=<span class="string">&quot;/home/alex/go&quot;</span></span><br><span class="line">GOPROXY=<span class="string">&quot;&quot;</span></span><br><span class="line">GORACE=<span class="string">&quot;&quot;</span></span><br><span class="line">GOROOT=<span class="string">&quot;/usr/local/go&quot;</span></span><br><span class="line">GOTMPDIR=<span class="string">&quot;&quot;</span></span><br><span class="line">GOTOOLDIR=<span class="string">&quot;/usr/local/go/pkg/tool/linux_amd64&quot;</span></span><br><span class="line">GCCGO=<span class="string">&quot;gccgo&quot;</span></span><br><span class="line">CC=<span class="string">&quot;gcc&quot;</span></span><br><span class="line">CXX=<span class="string">&quot;g++&quot;</span></span><br><span class="line">CGO_ENABLED=<span class="string">&quot;1&quot;</span></span><br><span class="line">GOMOD=<span class="string">&quot;&quot;</span></span><br><span class="line">CGO_CFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">CGO_CPPFLAGS=<span class="string">&quot;&quot;</span></span><br><span class="line">CGO_CXXFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">CGO_FFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">CGO_LDFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">PKG_CONFIG=<span class="string">&quot;pkg-config&quot;</span></span><br><span class="line">GOGCCFLAGS=<span class="string">&quot;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build245740092=/tmp/go-build -gno-record-gcc-switches&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你对特定值感兴趣，那么可以将其作为参数传给 <code>go env</code>。例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go env GOPATH GOOS GOARCH</span><br><span class="line"><span class="regexp">/home/</span>alex/go</span><br><span class="line">linux</span><br><span class="line">amd64</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>想要显示所有 <code>go env</code> 变量和值的文档，可以运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">help</span> environment</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="开发">开发</h2><h3 id="运行代码">运行代码</h3><p>开发过程中，<code>go run</code> 工具是一种试用代码的便捷方式。它其实是一个快捷方式，用于一步编译代码，在 <code>/tmp</code> 目录下创建可执行的二进制文件，然后运行该二进制文件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="keyword">run</span><span class="bash"> .          <span class="comment"># Run the package in the current directory</span></span></span><br><span class="line">$ go <span class="keyword">run</span><span class="bash"> ./cmd/foo  <span class="comment"># Run the package in the ./cmd/foo directory</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：从 Go 1.11 起，你可以像上面一样，将 <a href="https://golang.org/doc/go1.11#run">一个包的路径</a> 传给 <code>go run</code>。这意味着，不再需要使用像 <code>go run *.go</code> 通配符扩展这样的变通方式，就能运行多个文件了。我超爱这项改进！</p><h3 id="获取依赖项">获取依赖项</h3><p>假设<a href="https://github.com/golang/go/wiki/Modules#quick-start">启用了 modules</a>，那么，当使用 <code>go run</code>（或者与此有关的 <code>go test</code> 或者 <code>go build</code>）时，任何外部依赖将会自动（递归）地下载，以满足代码中的 <code>import</code> 语句。默认情况下，会下载依赖项的最新标志版本。如果没有可用的标志版本，则会下载最新提交的。</p><p>如果事先知道需要特定版本的依赖项（而不是 Go 默认会获取的那个版本），那么可以在使用 <code>go get</code> 的时候带上相关的版本号或者提交哈希值。例如：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/foo/bar@v1.<span class="number">2.3</span></span><br><span class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/foo/bar@<span class="number">8</span>e1b8d3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果提取的依赖项带有 <code>go.mod</code> 文件，那么，<em>它的依赖项_将不会被列入_你的</em> <code>go.mod</code> 文件中。相反，如果你在下载的依赖项没有 <code>go.mod</code> 文件，那么，它的依赖项_将_被列入_你的_ <code>go.mod</code> 文件中，并且在其之下会有一个 <code>// indirect</code> 注释。</p><p>这意味着，你的 <code>go.mod</code> 文件不一定会在一个地方显示项目的所有依赖项。相反，可以像这样使用 <code>go list</code> 工具来查看所有依赖项：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> go list -m <span class="keyword">all</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有时，你可能会想知道_为什么它会是一个依赖项？_此时，可以使用 <code>go mod why</code> 命令来解惑。这个命令将显示从主模块中的包到给定依赖项的最短路径。例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go mod why -m golang.org<span class="regexp">/x/</span>sys</span><br><span class="line"># golang.org<span class="regexp">/x/</span>sys</span><br><span class="line">github.com<span class="regexp">/alexedwards/</span>argon2id</span><br><span class="line">golang.org<span class="regexp">/x/</span>crypto/argon2</span><br><span class="line">golang.org<span class="regexp">/x/</span>sys/cpu</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：<code>go mod why</code> 命令将返回大多数（并非所有）依赖项之所以为依赖的原因。<a href="https://github.com/golang/go/issues/27900">Issue 27900</a> 正在跟踪此问题。</p><p>如果你对分析或者可视化应用的依赖项感兴趣，那么，你可能会想看看 <code>go mod graph</code> 工具。<a href="https://github.com/go-modules-by-example/index/tree/master/018_go_list_mod_graph_why">这里</a> 有一个很棒的生成可视化的教程和示例代码。</p><p>最后，下载下来的依赖项会保存在位于 <code>GOPATH/pkg/mod</code> 的_模块缓存_中。如果需要清除模块缓存，那么可以使用 <code>go clean</code> 工具。但是请注意：这个工具将会移除机器上_所有项目_的已下载依赖项。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>go clean -modcache</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="重构代码">重构代码</h3><p>可能你熟悉使用 <code>gofmt</code> 工具来自动格式化代码。但是，这个工具也支持_重写规则_，这样，就可以用它来重构代码了。我会证明给你看。</p><p>假设你有以下代码，然后你想将 <code>foo</code> 变量修改为 <code>Foo</code> 以便于将其导出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo = <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了达到这个目的，可以这样使用 <code>gofmt</code> ：带上 <code>-r</code> 标志来实现一条重写规则，带上 <code>-d</code> 标志来显示变更的差异，并且带上 <code>-w</code> 标志来_就地_进行变更。就像这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gofmt -d -w -r <span class="string">&#x27;foo -&gt; Foo&#x27;</span> .</span><br><span class="line">-<span class="keyword">var</span> foo <span class="keyword">int</span></span><br><span class="line">+<span class="keyword">var</span> Foo <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">-foo = <span class="number">1</span></span><br><span class="line">+Foo = <span class="number">1</span></span><br><span class="line"> fmt.Println(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意到了吗？这是不是比查找替换更智能？ <code>foo</code> 变量已经更改，但是 <code>fmt.Println()</code> 语句中的 <code>"foo"</code> 字符串则保持不变。另外需要注意的是，<code>gofmt</code> 命令是以递归的方式工作的，因此，上面这条命令将操作当前目录和子目录中的所有 <code>*.go</code> 文件。</p><p>如果想要使用此功能，我推荐首先_不带_ <code>-w</code> 标志运行重写规则，然后先检查差异，以确保对代码所做的修改正如你所愿。</p><p>我们来看个稍微复杂点的例子。假设你想要更新代码以使用新的 Go 1.12 <a href="https://golang.org/pkg/strings/#ReplaceAll">strings.ReplaceAll()</a> 的函数来替代 <a href="https://golang.org/pkg/strings/#Replace">strings.Replace()</a>。要进行更改，可以这样运行：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gofmt -w -r &#x27;strings.<span class="constructor">Replace(<span class="params">a</span>, <span class="params">b</span>, <span class="params">c</span>, -1)</span> -&gt; strings.<span class="constructor">ReplaceAll(<span class="params">a</span>, <span class="params">b</span>, <span class="params">c</span>)</span>&#x27; .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在重写规则里，单个小写字母会被用作匹配任意表达式的通配符，而这些表达式将会在替换过程中被替换。</p><h3 id="查看-go-文档">查看 Go 文档</h3><p>你可以通过在终端使用 <code>go doc</code> 工具，查看标准库包的文档。我经常在开发的时候使用这个工具来快速检查某些东西，例如某个特定函数的名字或者函数签名。我发现，这比浏览<a href="https://golang.org/pkg">基于 web 的文档</a> 更快，并且总是可以离线使用。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go doc strings            # <span class="keyword">View</span> simplified documentation <span class="keyword">for</span> the strings package</span><br><span class="line">$ go doc -<span class="keyword">all</span> strings       # <span class="keyword">View</span> <span class="keyword">full</span> documentation <span class="keyword">for</span> the strings package</span><br><span class="line">$ go doc strings.Replace    # <span class="keyword">View</span> documentation <span class="keyword">for</span> the strings.Replace <span class="keyword">function</span></span><br><span class="line">$ go doc <span class="keyword">sql</span>.DB             # <span class="keyword">View</span> documentation <span class="keyword">for</span> the <span class="keyword">database</span>/<span class="keyword">sql</span>.DB <span class="keyword">type</span></span><br><span class="line">$ go doc <span class="keyword">sql</span>.DB.Query       # <span class="keyword">View</span> documentation <span class="keyword">for</span> the <span class="keyword">database</span>/<span class="keyword">sql</span>.DB.Query <span class="keyword">method</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还可以使用 <code>-src</code> 标志来展示相关的 Go 源代码。例如：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>go doc -src strings.Replace   <span class="comment"># View the source code for the strings.Replace function</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="测试">测试</h2><h3 id="运行测试">运行测试</h3><p>可以像这样，使用 <code>go test</code> 工具来运行项目中的测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> .          <span class="comment"># Run all tests in the current directory</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> ./...      <span class="comment"># Run all tests in the current directory and sub-directories</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> ./foo/bar  <span class="comment"># Run all tests in the ./foo/bar directory</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通常，我会在启用 Go 的<a href="https://golang.org/doc/articles/race_detector.html">竞争检测器</a> 的情况下运行测试。这有助于帮助我找出在实际使用的过程中可能会出现的_一些_数据竞争。就像这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> -race ./...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>必须注意的是，启用竞争检测器将会增加测试的总体运行时间。所以，如果经常在 TDD 工作流程中运行测试，那么，你可能更愿意只在进行预提交测试的时候使用竞争检测器。</p><p>从 1.10 开始，Go 会<a href="https://golang.org/doc/go1.10#test">缓存包级别的测试结果</a>。如果在两次测试运行期间都没有发生改变，并且在使用 <code>go test</code> 时带了相同的可缓存标志，那么，就会展示缓存的测试结果，并且旁边会有一个 <code>"(cached)"</code>。对于大型代码库，这大大加速了测试运行时间。如果要强制运行所有测试（并避免缓存），那么，可以是有 <code>-count=1</code> 标志，或者通过使用 <code>go clean</code> 工具来清除所有缓存的测试结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> -count=1 ./...    <span class="comment"># Bypass the test cache when running tests</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go clean -testcache       <span class="comment"># Delete all cached test results</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：缓存的测试结果与缓存的构建结果一并存储在 <code>GOCACHE</code> 目录下。如果不确定它在你机器上的哪个位置，可以运行 <code>go env GOCACHE</code> 来检查。</p><p>可以通过使用 <code>-run</code> 标志来限制 <code>go test</code> 运行特定的测试（和自测试）。这个标志的参数是一个正则表达式，只有名字匹配到这个正则表达式的用例才会运行。我喜欢将它与 <code>-v</code> 标志（启用详细模式）结合使用，这样，就会显示运行中的测试和子测试的名字。这个一种很有用的方式，它确保了我没有写错这个正则表达式，并且期待运行的测试实际上确实在运行！</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v -<span class="keyword">run</span><span class="bash">=^TestFooBar$ .          <span class="comment"># Run the test with the exact name TestFooBar</span></span></span><br><span class="line">$ go test -v -<span class="keyword">run</span><span class="bash">=^TestFoo .              <span class="comment"># Run tests whose names start with TestFoo</span></span></span><br><span class="line">$ go test -v -<span class="keyword">run</span><span class="bash">=^TestFooBar$/^Baz$ .    <span class="comment"># Run the Baz subtest of the TestFooBar test only</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>值得注意的其他几个标志是 <code>-short</code>（用来<a href="https://golang.org/pkg/testing/#hdr-Skipping">跳过长时间运行的测试</a>）和 <code>-failfast</code>（在碰到第一个失败后会停止进一步的测试）。注意，<code>-failfast</code> 将不会缓存测试结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> -short ./...      <span class="comment"># Skip long running tests</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> -failfast ./...   <span class="comment"># Don&#x27;t run further tests after a failure.</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分析测试覆盖率">分析测试覆盖率</h3><p>你可以在运行测试的时候，通过使用 <code>-cover</code> 标志来启用覆盖率分析。这将会输出每一个包的测试所覆盖的代码百分比，类似于：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go test -cover ./...</span><br><span class="line">ok  github.com<span class="regexp">/alexedwards/</span>argon2id<span class="number">0.467</span>scoverage: <span class="number">78.6</span>% of statements</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你还可以使用 <code>-coverprofile</code> 标志来生成一份_覆盖程序剖析文件_，然后像这样使用 <code>go tool cover -html</code> 命令，在 web 浏览器中查看：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go test <span class="attribute">-coverprofile</span>=/tmp/profile.out ./<span class="built_in">..</span>.</span><br><span class="line">$ go<span class="built_in"> tool </span>cover <span class="attribute">-html</span>=/tmp/profile.out</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://www.alexedwards.net/static/images/tooling-1.png" /></p><p>这将为你提供所有测试文件的可导航列表，其中，测试覆盖到的代码显示为绿色，而没被覆盖到的则显示为红色。</p><p>如果想更进一步，可以设置 <code>-covermode=count</code> 标志，让覆盖程序剖析文件记录测试期间每个语句被执行的确切_次数_。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go test <span class="attribute">-covermode</span>=count <span class="attribute">-coverprofile</span>=/tmp/profile.out ./<span class="built_in">..</span>.</span><br><span class="line">$ go<span class="built_in"> tool </span>cover <span class="attribute">-html</span>=/tmp/profile.out</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在浏览器中查看时，执行得更频繁的语句会以更饱和的绿色阴影显示，类似于：</p><p><img src="https://www.alexedwards.net/static/images/tooling-2.png" /></p><p>注意：如果测试中使用了 <code>t.Parallel()</code> 命令，那么，应该使用标志 <code>-covermode=atomic</code> 来替代 <code>-covermode=count</code>，以确保准确计数。</p><p>最后，如果没有可供查看覆盖剖析文件的 web 浏览器，那么，可以在终端使用如下命令，按函数或者方法，查看测试测试覆盖率的细分信息：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go tool cover -<span class="keyword">func</span>=<span class="regexp">/tmp/</span>profile.out</span><br><span class="line">github.com<span class="regexp">/alexedwards/</span>argon2id/argon2id.go:<span class="number">77</span>:CreateHash<span class="number">87.5</span>%</span><br><span class="line">github.com<span class="regexp">/alexedwards/</span>argon2id/argon2id.go:<span class="number">96</span>:ComparePasswordAndHash<span class="number">85.7</span>%</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="压力测试">压力测试</h3><p>可以使用 <code>go test -count</code> 命令来连续多次运行一个测试。这在想要检查偶发或者间歇性失败的时候很有用。例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go test <span class="attribute">-run</span>=^TestFooBar$ <span class="attribute">-count</span>=500 .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>TestFooBar</code> 测试将连续重复 500 次。但是，必须注意的是，测试将_串行_重复（即使它包含了 <code>t.Parallel()</code> 指令）。所以，如果你的测试在做一些相对较慢的事情，例如与数据库、硬盘或者互联网进行一次交互，那么，运行大量测试可能需要相当长的一段时间。</p><p>在这种情况下，你也许希望使用 <a href="golang.org/x/tools/cmd/stress"><code>stress</code></a> 工具来以_并行_的方式多次执行相同的用例。可以像这样安装它：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /tmp</span><br><span class="line">$ GO111MODULE=on go get golang.org<span class="regexp">/x/</span>tools<span class="regexp">/cmd/</span>stress</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 <code>stress</code> 工具，首先需要为想要测试的特定包编译_测试二进制文件_。这可以使用 <code>go test -c</code> 命令来完成。例如，在当前目录下的包创建一个测试二进制文件：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go test -c -o=<span class="regexp">/tmp/</span>foo.test .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，测试二进制文件将会输出为 <code>/tmp/foo.test</code>。稍后，你就可以像这样，使用 <code>stress</code> 工具来为这个测试二进制文件执行特定的测试了：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ stress -p=4 /tmp/foo.<span class="keyword">test</span> -<span class="keyword">test</span>.<span class="keyword">run</span>=^TestFooBar$</span><br><span class="line">60 runs <span class="keyword">so</span> far, 0 failures</span><br><span class="line">120 runs <span class="keyword">so</span> far, 0 failures</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：在上面的例子中，我用了 <code>-p</code> 标志来限制 <code>stress</code> 使用的并行进程的个数为 4。如果不带这个标志，该工具默认会使用个数为 <code>runtime.NumCPU()</code> 的进程。</p><h3 id="测试所有依赖">测试所有依赖</h3><p>在为发布或者部署可执行文件，或者是公开分发代码之前，你可能会想要运行 <code>go test all</code> 命令：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> go test <span class="keyword">all</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个命令将会对模块中的所有包和所有依赖项运行测试（包括测试_测试依赖_以及必要的_标准库包_）。并且它能够帮助验证所使用的依赖项的确切版本是否彼此兼容。这可能需要运行相当长的时间，但是，结果会得到缓存，因此，未来任何后续测试应该都会运行得比较快。如果需要的话，还可以使用 <code>go test -short all</code>，跳过任何长时间运行的测试。</p><h2 id="预提交检查">预提交检查</h2><h3 id="格式化代码">格式化代码</h3><p>Go 提供了两种工具来根据 Go 约定自动格式化代码：<code>gofmt</code> 和 <code>go fmt</code>。使用这些工具有助于让你的文件的项目中的代码保持一致。另外，如果在提交代码之前使用这些工具，那么就有助于在检查文件版本间差异的时候减少噪音。</p><p>我喜欢在使用 <code>gofmt</code> 工具的时候带以下标志：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>gofmt -w -s -d foo.go  <span class="comment"># 格式化 foo.go 文件</span></span><br><span class="line"><span class="variable">$ </span>gofmt -w -s -d .       <span class="comment"># 递归格式化当前目录和子目录下的所有文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这些命令中，<code>-w</code> 标志指示工具就地重写文件；<code>-s</code> 标志指示工具在可能的情况下<a href="https://golang.org/cmd/gofmt/#hdr-The_simplify_command">简化</a>代码；而 <code>-d</code> 标志指示工具输出改动的差异（因为我很好奇更改了啥）。如果你只是想要看看改动了哪些文件而不是具体差异，那么，可以将 <code>-d</code> 标志改为 <code>-l</code>。</p><p>注意：<code>gofmt</code> 命令以递归的方式工作。如果你给它传递一个目录，例如 <code>.</code> 或者 <code>./cmd/foo</code>，那么，它只会格式化这个目录下的所有 <code>.go</code> 文件。</p><p>另一个格式化工具 <code>go fmt</code> 是对 <code>gofmt</code> 的一个封装，它基本上等同于对指定的文件或者目录调用了 <code>gofmt -l -w</code>。你可以像这样使用它：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>go fmt ./...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="执行静态分析">执行静态分析</h3><p><code>go vet</code> 工具会对你的代码进行静态分析，然后对_可能_出现（编译器可能无法获取）的代码错误进行示警。像是无法访问的代码、不必要的赋值和错误格式的构建标记等问题。可以像这样使用它：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> vet foo.<span class="keyword">go</span>     # Vet the foo.<span class="keyword">go</span> <span class="keyword">file</span></span><br><span class="line">$ <span class="keyword">go</span> vet .          # Vet <span class="keyword">all</span> <span class="keyword">files</span> in the current directory</span><br><span class="line">$ <span class="keyword">go</span> vet ./...      # Vet <span class="keyword">all</span> <span class="keyword">files</span> in the current directory <span class="built_in">and</span> sub-directories</span><br><span class="line">$ <span class="keyword">go</span> vet ./foo/bar  # Vet <span class="keyword">all</span> <span class="keyword">files</span> in the ./foo/bar directory</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在背后，<code>go vet</code> 会运行一系列不同的分析器（<a href="https://golang.org/cmd/vet/">列在这里</a>）。你可以根据具体情况禁用特定的分析器。例如，你可以这样禁用 <code>composite</code> 分析器：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>go vet -composites=<span class="keyword">false</span> ./...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://godoc.org/golang.org/x/tools">golang.org/x/tools</a> 中有一些实验分析器，或许你会想要试一试：<a href="https://godoc.org/golang.org/x/tools/go/analysis/passes/nilness/cmd/nilness">nilness</a>（检查冗余或者不可能为 nil 的比较）和 <a href="https://godoc.org/golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow">shadow</a>（检查可能意外会出现的变量遮蔽）。如果想要使用它们，那么需要单独安装和运行这些工具。例如，要安装 <code>nilness</code> 工具，可以这样运行：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /tmp</span><br><span class="line">$ GO111MODULE=on go get golang.org<span class="regexp">/x/</span>tools<span class="regexp">/go/</span>analysis<span class="regexp">/passes/</span>nilness<span class="regexp">/cmd/</span>nilness</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，就可以像这样使用它：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go vet -vettool=<span class="constructor">$(<span class="params">which</span> <span class="params">nilness</span>)</span> ./...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：当使用了 <code>-vettool</code> 标志，<code>go vet</code> 将_只会_运行指定的分析器，这意味着将不会运行所有其他 <code>go vet</code> 分析器。</p><p>作为旁注，从 Go 1.10 开始，在运行任何测试之前，<code>go test</code> 工具将自动执行一个小的高可信的 <code>go vet</code> 测试子集。你可以在运行测试的时候关掉这种行为，就像这样：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="keyword">test</span> -vet=<span class="keyword">off</span> ./...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="linting-code">Linting Code</h3><p>可以使用 <code>golint</code> 工具来识别代码中的_样式错误_。和 <code>go vet</code> 不一样，它不关系代码的_正确性_，而是帮助你将代码与 <a href="https://golang.org/doc/effective_go.html">Effective Go</a> 和 Go <a href="https://golang.org/wiki/CodeReviewComments">CodeReviewComments</a> 中的样式约定对齐。</p><p>这个工具并不是标准库的一部分，因此，需要像这样安装它：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /tmp</span><br><span class="line">$ <span class="attribute">GO111MODULE</span>=on go <span class="builtin-name">get</span> golang.org/x/lint/golint</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，就可以像下面一样运行它了：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>golint foo.go     <span class="comment"># Lint the foo.go file</span></span><br><span class="line"><span class="variable">$ </span>golint .          <span class="comment"># Lint all files in the current directory</span></span><br><span class="line"><span class="variable">$ </span>golint ./...      <span class="comment"># Lint all files in the current directory and sub-directories</span></span><br><span class="line"><span class="variable">$ </span>golint ./foo/bar  <span class="comment"># Lint all files in the ./foo/bar directory</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="整理和验证依赖关系">整理和验证依赖关系</h3><p>在提交代码任意改动之前，我建议你运行以下两个命令来整理和验证依赖项：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> go <span class="built_in">mod</span> tidy</span><br><span class="line"><span class="symbol">$</span> go <span class="built_in">mod</span> verify</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>go mod tidy</code> 命令将会修剪 <code>go.mod</code> 和 <code>go.sum</code> 文件中未使用的依赖项，然后更新文件，以包含用于所有可能的构建标签/操作系统/架构组合的依赖项（注意：<code>go run</code>、<code>go test</code>、<code>go build</code> 等都是“懒惰的”，它们只会获取当前构建标签/操作系统/架构所需的包）。在每次提交前运行这个命令，会让你更容易在查看版本控制历史时，确定哪些代码更改负责添加或者删除哪些依赖项。</p><p>我还推荐使用 <code>go mod verify</code> 命令来检查计算机上的依赖项自下载后没有被意外（或者故意）更改，并且它们匹配 <code>go.sum</code> 文件中的加密哈希值。运行此命令有助于确保所使用的依赖项确确实实是你所期望的，并且以后对该提交的任何构建都能重现。</p><h2 id="构建和部署">构建和部署</h2><h3 id="构建可执行文件">构建可执行文件</h3><p>你可以使用 <code>go build</code> 工具来编译 <code>main</code> 包，并创建一个可执行的二进制文件。通常，我会将其与 <code>-o</code> 标志结合使用，明确设置输出目录和二进制文件的名字，就像这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go build -o=<span class="regexp">/tmp/</span>foo .            <span class="comment"># 在当前目录下编译包</span></span><br><span class="line">$ go build -o=<span class="regexp">/tmp/</span>foo .<span class="regexp">/cmd/</span>foo    <span class="comment"># 在 ./cmd/foo 目录下编译包</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这些示例中，<code>go build</code> 将会_编译_特定的包（和任何依赖包），然后调用_链接器_来生成一个可执行的二进制文件，并将其输出到 <code>/tmp/foo</code>。</p><p>值得注意的是，从 Go 1.10 开始，<code>go build</code> 工具会将构建输出缓存到_<a href="https://golang.org/cmd/go/#hdr-Build_and_test_caching">构建缓存</a>_中。这缓存的输出将在未来的构建中的适当时机重新使用。这就可以显著加快整体的构建时间。这种新的缓存行为意味着，“相比 <code>go build</code>，宁可 <code>go install</code>” 的“<a href="https://peter.bourgon.org/go-best-practices-2016/#build-and-deploy">古训</a>”不再适用。</p><p>如果不确定构建缓存位于何处，那么可以运行 <code>go env GOCACHE</code> 命令来检查：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go env GOCACHE</span><br><span class="line"><span class="regexp">/home/</span>alex<span class="regexp">/.cache/g</span>o-build</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用构建缓存时需要<a href="https://golang.org/pkg/cmd/go/internal/help/">特别注意</a>：它并不会检查使用 <code>cgo</code> 导入的 C 库的改动。因此，如果你的代码通过 <code>cgo</code> 来导入一个 C 库，并且自上次构建后又对其进行了更改，那么需要使用 <code>-a</code> 标志来强制所有的包重新构建。或者，可以使用 <code>go clean</code> 来清除缓存：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>go build -a -o=<span class="regexp">/tmp/foo</span> .     <span class="comment"># 强制重新构建所有包</span></span><br><span class="line"><span class="variable">$ </span>go clean -cache               <span class="comment"># 清除构建缓存</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：运行 <code>go clean -cache</code> 将也会删除缓存的测试结果。</p><p>如果你对 <code>go build</code> 的幕后操作感兴趣，那么可能会想要使用以下命令：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>go list -deps . | sort -u     <span class="comment"># 列出所有用来构建可执行文件的包</span></span><br><span class="line"><span class="variable">$ </span>go build -a -x -o=<span class="regexp">/tmp/foo</span> .  <span class="comment"># 重构所有东西，并且显示所运行的命令</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，如果在非 <code>main</code> 包上运行 <code>go build</code> 命令，那么将会在临时位置编译这个包，并且结果将会被存储在构建缓存中。不会生成任何可执行文件。</p><h3 id="交叉编译">交叉编译</h3><p>这是我最喜欢的 Go 功能之一。</p><p>默认情况下，<code>go build</code> 将会输出一个适用于当前操作系统和架构的二进制文件。但它也支持交叉编译，这样，你就可以生成适合在不同机器上使用的二进制文件了。如果你在一个操作系统上开发，却在另一个操作系统上部署，那么这特别有用。</p><p>可以分别设置 <code>GOOS</code> 和 <code>GOARCH</code> 环境变量来指定希望为何种操作系统和架构创建二进制文件。例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">GOOS</span>=linux <span class="attribute">GOARCH</span>=amd64 go build <span class="attribute">-o</span>=/tmp/linux_amd64/foo .</span><br><span class="line">$ <span class="attribute">GOOS</span>=windows <span class="attribute">GOARCH</span>=amd64 go build <span class="attribute">-o</span>=/tmp/windows_amd64/foo.exe .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要查看所有支持的操作系统和架构组合列表，可以运行 <code>go tool dist list</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ go tool dist list</span><br><span class="line">aix&#x2F;ppc64</span><br><span class="line">android&#x2F;386</span><br><span class="line">android&#x2F;amd64</span><br><span class="line">android&#x2F;arm</span><br><span class="line">android&#x2F;arm64</span><br><span class="line">darwin&#x2F;386</span><br><span class="line">darwin&#x2F;amd64</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>提示：可以使用 Go 的交叉编译来<a href="https://github.com/golang/go/wiki/WebAssembly">创建 WebAssembly 二进制文件</a>。</p><p>有关交叉编译的更深入的信息，推荐阅读<a href="https://rakyll.org/cross-compilation/">这篇优秀的博文</a>。</p><h3 id="使用编译器和链接器标志">使用编译器和链接器标志</h3><p>在构建自己的可执行文件时，可以使用 <code>-gcflags</code> 标志来更改编译器的行为，并查看执行的详细信息。可以通过运行以下命令，查看可用编译器标志的完整列表：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">go</span> tool <span class="built_in">compile</span> -help</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中一个你可能会感兴趣的标志是 <code>-m</code>，带上了这个标志会触发打印编译期间所进行的优化决策。可以这样使用它：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go build -gcflags=<span class="string">&quot;-m -m&quot;</span> -o=<span class="regexp">/tmp/</span>foo . <span class="comment"># 输出优化决策信息</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的例子中，我用了 <code>-m</code> 标志两次，表示我想要打印量级深度的决策信息。你可以通过使用一次来获得简单点的输出。</p><p>此外，从 Go 1.10 开始，编译器标志只适用于传给 <code>go build</code> 的指定包，在上面的例子中就是当前目录下的包（由 <code>.</code> 表示）。如果你想打印所有包的优化决策（包括依赖项），那么可以用这个命令替代：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go build <span class="attribute">-gcflags</span>=<span class="string">&quot;all=-m&quot;</span> <span class="attribute">-o</span>=/tmp/foo .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从 Go 1.11 开始，你应该会发现比之前<a href="https://golang.org/doc/go1.11#debugging">更容易调试优化过的二进制文件</a>了。然而，如果有需要的话，仍然可以使用标志 <code>-N</code> 来禁用优化，使用 <code>-l</code> 来禁用内联。例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go build -gcflags=<span class="string">&quot;all=-N -l&quot;</span> -o=<span class="regexp">/tmp/</span>foo .  <span class="comment"># 禁用优化和内联</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以运行以下命令来查看可用的链接器标志列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go tool link -<span class="built_in">help</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，可能最有名的就是 <code>-X</code> 标志了，它允许你将一个（字符串）值“烧入”应用里指定的变量。这通常用于<a href="https://blog.alexellis.io/inject-build-time-vars-golang/">添加版本号或者提交哈希</a>。例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go build <span class="attribute">-ldflags</span>=<span class="string">&quot;-X main.version=1.2.3&quot;</span> <span class="attribute">-o</span>=/tmp/foo .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多关于 <code>-X</code> 标志和示例代码的信息，请参阅<a href="https://stackoverflow.com/questions/11354518/golang-application-auto-build-versioning">这个 StackOverflow 问题</a> 和本文以及<a href="https://blog.alexellis.io/inject-build-time-vars-golang/">这篇文章</a>。</p><p>你可能还有兴趣使用 <code>-s</code> 和 <code>-w</code> 标志来删除二进制文件中的调试信息。这通常会让生成的二进制文件减少 25% 的大小。例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go build -ldflags=<span class="string">&quot;-s -w&quot;</span> -o=<span class="regexp">/tmp/</span>foo .  <span class="comment"># 删除二进制文件中的调试信息</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：如果需要优化二进制文件大小，那么或许会想要使用 <a href="https://upx.github.io/">upx</a> 来压缩它。更多信息，请参阅<a href="https://blog.filippo.io/shrink-your-go-binaries-with-this-one-weird-trick/">这篇文章</a>。</p><h2 id="诊断问题和优化">诊断问题和优化</h2><h3 id="运行和比较基准">运行和比较基准</h3><p>Go 的一个很好的功能是，它让你可以轻松对代码进行基准测试。如果你不熟悉编写基准的一般过程，那么，<a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go">这里</a>和<a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go">这这里</a>有不错的指南。</p><p>要运行基准测试，你需要使用 <code>go test</code> 工具，并且将 <code>-bench</code> 标志设置为一个可以匹配你想要执行的基准测试的正则表达式。例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go test <span class="attribute">-bench</span>=. ./<span class="built_in">..</span>.                        # 运行所有基准测试和基本测试</span><br><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=. ./<span class="built_in">..</span>.                # 运行所有基准测试（不运行基本测试）</span><br><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=^BenchmarkFoo$ ./<span class="built_in">..</span>.   # 只运行 BenchmarkFoo 这个基准测试（不运行基本测试）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我几乎总用 <code>-benchmem</code> 标志来运行基准测试，这会强制输出内存分配统计信息。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  go test <span class="attribute">-bench</span>=. -benchmem ./<span class="built_in">..</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认情况下，每个基准测试都会运行至少一秒，并且只运行一次。可以使用 <code>-benchtime</code> 和 <code>-count</code> 标志来更改此行为。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go test <span class="attribute">-bench</span>=. <span class="attribute">-benchtime</span>=5s ./<span class="built_in">..</span>.       # 每个基准测试至少运行 5 秒</span><br><span class="line">$ go test <span class="attribute">-bench</span>=. <span class="attribute">-benchtime</span>=500x ./<span class="built_in">..</span>.     # 每个基准测试运行 500 次迭代</span><br><span class="line">$ go test <span class="attribute">-bench</span>=. <span class="attribute">-count</span>=3 ./<span class="built_in">..</span>.            # 每个基准测试重复 3 次</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果进行基准测试的代码使用了并发，那么，可以使用 <code>-cpu</code> 标志来查看更改 <code>GOMAXPROCS</code> 值对性能产生的影响（实际上，是可以同时执行 Go 代码的 OS 线程数）。例如，将 <code>GOMAXPROCS</code> 设置为 1，4 和 8，运行基准测试：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go test <span class="attribute">-bench</span>=. <span class="attribute">-cpu</span>=1,4,8 ./<span class="built_in">..</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要比较基准测试之间的变动，你可能需要使用 <a href="https://godoc.org/golang.org/x/tools/cmd/benchcmp">benchcmp</a> 工具。这个工具不属于标准的 <code>go</code> 命令，所以需要像这样安装它：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /tmp</span><br><span class="line">$ GO111MODULE=on go get golang.org<span class="regexp">/x/</span>tools<span class="regexp">/cmd/</span>benchcmp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，可以像这样使用它：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ go test -run=^$ -bench=. -benchmem .<span class="regexp">/... &gt; /</span>tmp/old.txt</span><br><span class="line"># make changes</span><br><span class="line">$ go test -run=^$ -bench=. -benchmem .<span class="regexp">/... &gt; /</span>tmp/<span class="keyword">new</span>.txt</span><br><span class="line">$ benchcmp <span class="regexp">/tmp/</span>old.txt <span class="regexp">/tmp/</span><span class="keyword">new</span>.txt</span><br><span class="line">benchmark              old ns<span class="regexp">/op     new ns/</span>op     delta</span><br><span class="line">BenchmarkExample-<span class="number">8</span>     <span class="number">21234</span>         <span class="number">5510</span>          -<span class="number">74.05</span>%</span><br><span class="line"></span><br><span class="line">benchmark              old allocs     <span class="keyword">new</span> allocs     delta</span><br><span class="line">BenchmarkExample-<span class="number">8</span>     <span class="number">17</span>             <span class="number">11</span>             -<span class="number">35.29</span>%</span><br><span class="line"></span><br><span class="line">benchmark              old bytes     <span class="keyword">new</span> bytes     delta</span><br><span class="line">BenchmarkExample-<span class="number">8</span>     <span class="number">8240</span>          <span class="number">3808</span>          -<span class="number">53.79</span>%</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分析和跟踪">分析和跟踪</h3><p>Go 可以让你创建关于 CPU 使用、内存使用、goroutine 阻塞和互斥锁争用的诊断性_程序剖析文件_。你可以使用它们来深入挖掘应用，以确切了解应用是如何使用（或者等待）资源的。</p><p>有三种生成程序剖析文件的方法：</p><ul><li>如果是 web 应用，那么可以导入 <a href="https://golang.org/pkg/net/http/pprof/"><code>net/http/pprof</code></a> 包。这个操作将向 <code>http.DefaultServeMux</code> 注册一些处理函数。这样，你就可以为运行中的应用生成并下载程序剖析文件了。<a href="https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/">这篇文章</a> 对其进行了很好的解释，并且提供了一些示例代码。</li><li>对于其他类型的应用，则可以使用 <code>pprof.StartCPUProfile()</code> 和 <code>pprof.WriteHeapProfile()</code> 函数来生成运行中的程序剖析文件。<a href="https://golang.org/pkg/runtime/pprof/"><code>runtime/pprof</code></a> 文档中有一些示例代码可供参考。</li><li>或者，你可以在运行基准测试或者基础测试的时候生成程序剖析文件，只需像这样使用各种 <code>-***profile</code> 标志即可：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=^BenchmarkFoo$ <span class="attribute">-cpuprofile</span>=/tmp/cpuprofile.out .</span><br><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=^BenchmarkFoo$ <span class="attribute">-memprofile</span>=/tmp/memprofile.out .</span><br><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=^BenchmarkFoo$ <span class="attribute">-blockprofile</span>=/tmp/blockprofile.out .</span><br><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=^BenchmarkFoo$ <span class="attribute">-mutexprofile</span>=/tmp/mutexprofile.out .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：运行基准测试或者基础测试的时候使用 <code>-***profile</code> 标志，当前目录下会生成一个测试二进制文件。如果你想将其输出到另一个地方，那么应该使用 <code>-o</code> 标志，就像这样：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=^BenchmarkFoo$ <span class="attribute">-o</span>=/tmp/foo.test <span class="attribute">-cpuprofile</span>=/tmp/cpuprofile.out .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无论使用何种方式来生成程序剖析文件，当启用了程序剖析，Go 程序每秒将停止大约 100 次，并在停止的时刻创建程序快照。根据这些 <em>样本</em> 生成一份_程序剖析文件_，然后就可以使用 <code>pprof</code> 文件进行分析了。</p><p>我最喜欢的检查剖析文件的方式是，使用 <code>go tool pprof -http</code> 命令来将其在 web 浏览器中打开。例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go<span class="built_in"> tool </span>pprof <span class="attribute">-http</span>=:5000 /tmp/cpuprofile.out</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://www.alexedwards.net/static/images/tooling-3.png" /></p><p>这个操作将会默认显示一个_图表_，展示了应用在采样情况下的执行树。这让你可以快速了解任何资源的使用“热点”。在上面的图中，我们可以看到，CPU 使用率方面的热点是来源于 <code>ioutil.ReadFile()</code> 的两个系统调用。</p><p>你还可以导航到剖析文件的其他_视图_，包括函数和源代码的最高使用情况。</p><p><img src="https://www.alexedwards.net/static/images/tooling-4.png" /></p><p>如果信息量太大，那么，或许你会想要使用 <code>--nodefraction</code> 标志，忽略小于样本一定百分比的节点。例如，要忽略那些少于样本 10% 的节点，可以这样运行 <code>pprof</code>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go<span class="built_in"> tool </span>pprof <span class="attribute">--nodefraction</span>=0.1 <span class="attribute">-http</span>=:5000 /tmp/cpuprofile.out</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://www.alexedwards.net/static/images/tooling-5.png" /></p><p>这会让生成的图不那么“嘈杂”。此时，如果<a href="https://www.alexedwards.net/static/images/tooling-5b.svg">放大这张屏幕截图</a>，那么就可以更清楚地看到并了解 CPU 使用热点在哪里。</p><p>分析和优化资源使用是一项大但是细微的主题，而这里我只涉及皮毛。如果你对此感兴趣，并想了解更多，那么建议你阅读以下文章：</p><ul><li><a href="https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/">分析和优化 Go web 应用</a></li><li><a href="https://github.com/golang/go/wiki/Performance">调试 Go 程序中的性能问题</a></li><li><a href="https://medium.com/@hackintoshrao/daily-code-optimization-using-benchmarks-and-profiling-in-golang-gophercon-india-2016-talk-874c8b4dc3c5">使用基准测试和程序剖析进行日常代码优化</a></li><li><a href="https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/">使用 pprof 分析 Go 程序</a></li></ul><p>另一个可以用来协助诊断问题的工具是_运行时执行跟踪器_。它可以让你了解 Go 是如何创建和调度 goroutine 运行的，垃圾收集器何时运行，以及关于阻塞系统调用/网络/sync 操作的信息。</p><p>同样的，你也可以从基础测试和基准测试中生成跟踪文件，或者使用 <code>net/http/pprof</code> 来创建并下载应用的跟踪文件。然后，就可以使用 <code>go tool trace</code>，像这样在 web 浏览器中查看输出了：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go test <span class="attribute">-run</span>=^$ <span class="attribute">-bench</span>=^BenchmarkFoo$ <span class="attribute">-trace</span>=/tmp/trace.out .</span><br><span class="line">$ go<span class="built_in"> tool </span>trace /tmp/trace.out</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重要提示：目前，只能在 Chrome 或者 Chromium 中查看。</p><p><img src="https://www.alexedwards.net/static/images/tooling-6.png" /></p><p>关于 Go 的执行跟踪器以及如何解释输出的更多信息，请看 <a href="https://www.youtube.com/watch?v=mmqDlbWk_XA">Rhys Hiltner 的 dotGo 2016 演讲</a> 和这篇<a href="https://making.pusher.com/go-tool-trace/">优秀的博客</a>。</p><h3 id="检查竞争条件">检查竞争条件</h3><p>我前面谈过使用 <code>go test -race</code>，在测试过程中启用 Go 的竞争检测器。但是，你也可以在构建可执行文件的过程中，为运行中的程序启用它，就像这样：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go build -race -o=<span class="regexp">/tmp/</span>foo .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>非常值得注意的是，启用了竞争检测器的二进制文件将比正常情况下使用更多的 CPU 和内存。因此，在正常情况下，构建用于生产环境的二进制文件时，不应该使用 <code>-race</code> 标志。</p><p>但是，你可能希望在服务器池中的某台服务器上面部署启用了竞争检测器的二进制文件。或者用它来跟踪可疑的竞争条件，方法是使用负载测试工具，对启用了竞争检测器的二进制文件并发施压。</p><p>默认情况下，在二进制文件运行过程中，如果检测到了竞争，那么会对 <code>stderr</code> 写入一条日志。如果必要，你可以通过使用 <code>GORACE</code> 环境变量来改变这种行为。例如，要运行位于 <code>/tmp/foo</code> 的二进制文件，并将竞争日志写到 <code>/tmp/race.&lt;pid&gt;</code>，则可以这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ GORACE=<span class="string">&quot;log_path=/tmp/race&quot;</span> <span class="regexp">/tmp/</span>foo</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="管理依赖关系">管理依赖关系</h2><p>可以使用 <code>go list</code> 工具来检查指定的依赖项是否有更新版本，如下所示：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go list -m -u github.com<span class="regexp">/alecthomas/</span>chroma</span><br><span class="line">github.com<span class="regexp">/alecthomas/</span>chroma v0.<span class="number">6.2</span> [v0.<span class="number">6.3</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这将输出当前使用的依赖项的名字和版本，如果存在较新的版本，那么后面会跟着方括号 <code>[]</code>，里面是最新的版本。还可以使用 <code>go list</code> 来检查所有依赖项（和子依赖项）的更新。如下所示：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> go list -m -u <span class="keyword">all</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以升级（或者降级）一个依赖项至最新的版本，只需像这样在 <code>go get</code> 命令后指定发布标记或者提交哈希即可：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/foo/bar@latest</span><br><span class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/foo/bar@v1.<span class="number">2.3</span></span><br><span class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/foo/bar@<span class="number">7</span>e0369f</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你正在更新的依赖项带有 <code>go.mod</code> 文件，那么，根据这份 <code>go.mod</code> 文件的信息，如果有需要的话，还将下载_子依赖项_的更新。如果使用 <code>go get -u</code> 标志，那么将忽略 <code>go.mod</code> 文件的内容，然后所有子依赖项将会被升级至最新的次要或者补丁版本（即使 <code>go.mod</code> 指定了不同的版本。）。</p><p>升级或者降级任何依赖项后，最好整理你的 mod 文件。可能你还会希望运行所有包的测试，从而检查兼容性。就像这样：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> go <span class="built_in">mod</span> tidy</span><br><span class="line"><span class="symbol">$</span> go test <span class="keyword">all</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有时，你可能想使用本地版本的依赖项（例如，在上游合并补丁之前，需要使用本地分支）。为此，可以使用 <code>go mod edit</code> 命令，将 <code>go.mod</code> 文件中的依赖项替代为本地版本。例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go mod edit -replace=github.com<span class="regexp">/alexedwards/</span>argon2id=<span class="regexp">/home/</span>alex<span class="regexp">/code/</span>argon2id</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这将像这样为你的 <code>go.mod</code> 文件添加一个_替代规则_。然后。未来的 <code>go run</code> 和 <code>go build</code> 等操作将会使用本地版本。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>File: go.mod</span><br><span class="line">    module alexedwards.net/example</span><br><span class="line">    </span><br><span class="line">    go <span class="number">1.12</span></span><br><span class="line">    </span><br><span class="line">    require github.com<span class="regexp">/alexedwards/</span>argon2id v0.<span class="number">0.0</span>-<span class="number">20190109181859</span>-<span class="number">24206601</span>af6c</span><br><span class="line">    </span><br><span class="line">    replace github.com<span class="regexp">/alexedwards/</span>argon2id =&gt; <span class="regexp">/home/</span>alex<span class="regexp">/Projects/</span>playground/argon2id</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>一旦不需要本地版本了，就可以用下面这个命令来移除替换规则：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go mod <span class="builtin-name">edit</span> <span class="attribute">-dropreplace</span>=github.com/alexedwards/argon2id</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以使用<a href="https://github.com/golang/go/wiki/Modules#can-i-work-entirely-outside-of-vcs-on-my-local-filesystem">同样的技巧</a>来导入_只_存在于你自己文件系统上的包。如果你同时处理开发中的多个模块，其中一个模块依赖另一个模块，那么这将会很有用。</p><p>注意：如果不想使用 <code>go mod edit</code> 命令，可以手动编辑 <code>go.mod</code> 文件来进行修改。无论哪种方式都能行得通。</p><h2 id="升级到新版本">升级到新版本</h2><p><code>go fix</code> 文件最初于 2011 年发布（当时对于 Go 的 API 仍有定期修改），用以帮助用户自动更新旧代码至与 Go 的新版本兼容。从此，Go 的<a href="https://golang.org/doc/go1compat">兼容性承诺</a>意味着，如果你从一个 Go 1.x 版本升级至更新的 1.x 版本，那么将一切正常，故而通常没有必要使用 <code>go fix</code>。</p><p>但是，它确实处理了一些非常具体的问题。可以运行 <code>go tool fix -help</code> 来查看这些问题的摘要。如果你决定升级之后想要或者需要运行 <code>go fix</code>，那么应该运行以下命令，然后在提交前检查更改的差异。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">go</span> <span class="built_in">fix</span> ./...</span><br></pre></td></tr></table></figure><h2 id="报告错误">报告错误</h2><p>如果你确信找到了 Go 的标注库、工具或者文档中未报告的错误，那么可以使用 <code>go bug</code> 命令来创建一个新的 Github issue。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>go bug</span><br></pre></td></tr></table></figure><p>这个命令将会打开一个浏览器窗口，其中打开了 issue 页面，并且与填充了系统信息和报告模板。</p><h2 id="备忘">备忘</h2><p><em>2019-04-19 更新：<span class="citation" data-cites="FedirFR">[@FedirFR]</span>(https://twitter.com/FedirFR) 根据这篇文章制作了一份备忘。你可以<a href="https://github.com/fedir/go-tooling-cheat-sheet/blob/master/go-tooling-cheat-sheet.pdf">在这里下载</a>.</em></p><p><a href="https://github.com/fedir/go-tooling-cheat-sheet/blob/master/go-tooling-cheat-sheet.pdf"><img src="https://www.alexedwards.net/static/images/tooling-7.png" /></a></p>]]></content>
    
    
    <summary type="html">原文：An Overview of Go&#39;s Tooling




偶尔会有人问我，“为什么你会喜欢用 Go 呢？” 在我的回答中，有一个我经常提到的原因，那就是和 Go 一起存在的那些好用的工具，并且它们是作为 go 命令的一部分存在的。其中有一些工具我每天都在用，例如 go fmt 和 go build。而其他像 go tool pprof 这样的工具，则只在解决特定问题的时候会用到。但是无论如何，我很感激它们，让我的项目管理和维护变得更加容易。

在这篇文章中，我希望说明一些我认为最有用的工具的背景和使用场景。更重要的是，解释清楚可以如何将其用于典型项目的工作流程中。如果你刚接触 Go</summary>
    
    
    
    <category term="golang" scheme="http://ictar.github.io/categories/golang/"/>
    
    
  </entry>
  
</feed>
